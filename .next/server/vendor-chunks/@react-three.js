"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-three";
exports.ids = ["vendor-chunks/@react-three"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-three/drei/core/ContactShadows.js":
/*!***************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/ContactShadows.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContactShadows: () => (/* binding */ ContactShadows)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-29b7121b.esm.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/shaders/HorizontalBlurShader.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/shaders/VerticalBlurShader.js\");\n\n\n\n\n\nconst ContactShadows = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ scale = 10, frames = Infinity, opacity = 1, width = 1, height = 1, blur = 1, near = 0, far = 10, resolution = 512, smooth = true, color = \"#000000\", depthWrite = false, renderOrder, ...props }, fref)=>{\n    const ref = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const scene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.scene);\n    const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.gl);\n    const shadowCamera = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    width = width * (Array.isArray(scale) ? scale[0] : scale || 1);\n    height = height * (Array.isArray(scale) ? scale[1] : scale || 1);\n    const [renderTarget, planeGeometry, depthMaterial, blurPlane, horizontalBlurMaterial, verticalBlurMaterial, renderTargetBlur] = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>{\n        const renderTarget = new three__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderTarget(resolution, resolution);\n        const renderTargetBlur = new three__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderTarget(resolution, resolution);\n        renderTargetBlur.texture.generateMipmaps = renderTarget.texture.generateMipmaps = false;\n        const planeGeometry = new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(width, height).rotateX(Math.PI / 2);\n        const blurPlane = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(planeGeometry);\n        const depthMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.MeshDepthMaterial();\n        depthMaterial.depthTest = depthMaterial.depthWrite = false;\n        depthMaterial.onBeforeCompile = (shader)=>{\n            shader.uniforms = {\n                ...shader.uniforms,\n                ucolor: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_3__.Color(color)\n                }\n            };\n            shader.fragmentShader = shader.fragmentShader.replace(`void main() {`, //\n            `uniform vec3 ucolor;\n           void main() {\n          `);\n            shader.fragmentShader = shader.fragmentShader.replace(\"vec4( vec3( 1.0 - fragCoordZ ), opacity );\", // Colorize the shadow, multiply by the falloff so that the center can remain darker\n            \"vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );\");\n        };\n        const horizontalBlurMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.ShaderMaterial(three_stdlib__WEBPACK_IMPORTED_MODULE_4__.HorizontalBlurShader);\n        const verticalBlurMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.ShaderMaterial(three_stdlib__WEBPACK_IMPORTED_MODULE_5__.VerticalBlurShader);\n        verticalBlurMaterial.depthTest = horizontalBlurMaterial.depthTest = false;\n        return [\n            renderTarget,\n            planeGeometry,\n            depthMaterial,\n            blurPlane,\n            horizontalBlurMaterial,\n            verticalBlurMaterial,\n            renderTargetBlur\n        ];\n    }, [\n        resolution,\n        width,\n        height,\n        scale,\n        color\n    ]);\n    const blurShadows = (blur)=>{\n        blurPlane.visible = true;\n        blurPlane.material = horizontalBlurMaterial;\n        horizontalBlurMaterial.uniforms.tDiffuse.value = renderTarget.texture;\n        horizontalBlurMaterial.uniforms.h.value = blur * 1 / 256;\n        gl.setRenderTarget(renderTargetBlur);\n        gl.render(blurPlane, shadowCamera.current);\n        blurPlane.material = verticalBlurMaterial;\n        verticalBlurMaterial.uniforms.tDiffuse.value = renderTargetBlur.texture;\n        verticalBlurMaterial.uniforms.v.value = blur * 1 / 256;\n        gl.setRenderTarget(renderTarget);\n        gl.render(blurPlane, shadowCamera.current);\n        blurPlane.visible = false;\n    };\n    let count = 0;\n    let initialBackground;\n    let initialOverrideMaterial;\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(()=>{\n        if (shadowCamera.current && (frames === Infinity || count < frames)) {\n            count++;\n            initialBackground = scene.background;\n            initialOverrideMaterial = scene.overrideMaterial;\n            ref.current.visible = false;\n            scene.background = null;\n            scene.overrideMaterial = depthMaterial;\n            gl.setRenderTarget(renderTarget);\n            gl.render(scene, shadowCamera.current);\n            blurShadows(blur);\n            if (smooth) blurShadows(blur * 0.4);\n            gl.setRenderTarget(null);\n            ref.current.visible = true;\n            scene.overrideMaterial = initialOverrideMaterial;\n            scene.background = initialBackground;\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(fref, ()=>ref.current, []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        \"rotation-x\": Math.PI / 2\n    }, props, {\n        ref: ref\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", {\n        renderOrder: renderOrder,\n        geometry: planeGeometry,\n        scale: [\n            1,\n            -1,\n            1\n        ],\n        rotation: [\n            -Math.PI / 2,\n            0,\n            0\n        ]\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"meshBasicMaterial\", {\n        transparent: true,\n        map: renderTarget.texture,\n        opacity: opacity,\n        depthWrite: depthWrite\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"orthographicCamera\", {\n        ref: shadowCamera,\n        args: [\n            -width / 2,\n            width / 2,\n            height / 2,\n            -height / 2,\n            near,\n            far\n        ]\n    }));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9Db250YWN0U2hhZG93cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUEwRDtBQUMzQjtBQUNBO0FBQ3lCO0FBQ2dCO0FBRXhFLE1BQU1PLGlCQUFpQixhQUFhLGlCQUFFTiw2Q0FBZ0IsQ0FBQyxDQUFDLEVBQ3REUSxRQUFRLEVBQUUsRUFDVkMsU0FBU0MsUUFBUSxFQUNqQkMsVUFBVSxDQUFDLEVBQ1hDLFFBQVEsQ0FBQyxFQUNUQyxTQUFTLENBQUMsRUFDVkMsT0FBTyxDQUFDLEVBQ1JDLE9BQU8sQ0FBQyxFQUNSQyxNQUFNLEVBQUUsRUFDUkMsYUFBYSxHQUFHLEVBQ2hCQyxTQUFTLElBQUksRUFDYkMsUUFBUSxTQUFTLEVBQ2pCQyxhQUFhLEtBQUssRUFDbEJDLFdBQVcsRUFDWCxHQUFHQyxPQUNKLEVBQUVDO0lBQ0QsTUFBTUMsTUFBTXhCLHlDQUFZLENBQUM7SUFDekIsTUFBTTBCLFFBQVF4QixxREFBUUEsQ0FBQ3lCLENBQUFBLFFBQVNBLE1BQU1ELEtBQUs7SUFDM0MsTUFBTUUsS0FBSzFCLHFEQUFRQSxDQUFDeUIsQ0FBQUEsUUFBU0EsTUFBTUMsRUFBRTtJQUNyQyxNQUFNQyxlQUFlN0IseUNBQVksQ0FBQztJQUNsQ1ksUUFBUUEsUUFBU2tCLENBQUFBLE1BQU1DLE9BQU8sQ0FBQ3ZCLFNBQVNBLEtBQUssQ0FBQyxFQUFFLEdBQUdBLFNBQVM7SUFDNURLLFNBQVNBLFNBQVVpQixDQUFBQSxNQUFNQyxPQUFPLENBQUN2QixTQUFTQSxLQUFLLENBQUMsRUFBRSxHQUFHQSxTQUFTO0lBQzlELE1BQU0sQ0FBQ3dCLGNBQWNDLGVBQWVDLGVBQWVDLFdBQVdDLHdCQUF3QkMsc0JBQXNCQyxpQkFBaUIsR0FBR3RDLDBDQUFhLENBQUM7UUFDNUksTUFBTWdDLGVBQWUsSUFBSS9CLG9EQUF1QixDQUFDZ0IsWUFBWUE7UUFDN0QsTUFBTXFCLG1CQUFtQixJQUFJckMsb0RBQXVC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dEJsQyxNQUFNOEMsZ0JBQWdCLEdBQUdGO1lBQ3pCNUMsTUFBTTZDLFVBQVUsR0FBR0Y7UUFDckI7SUFDRjtJQUNBckUsc0RBQXlCLENBQUN1QixNQUFNLElBQU1DLElBQUkwQyxPQUFPLEVBQUUsRUFBRTtJQUNyRCxPQUFPLFdBQVcsR0FBRWxFLGdEQUFtQixDQUFDLFNBQVNELDhFQUFRQSxDQUFDO1FBQ3hELGNBQWM4QyxLQUFLQyxFQUFFLEdBQUc7SUFDMUIsR0FBR3hCLE9BQU87UUFDUkUsS0FBS0E7SUFDUCxJQUFJLFdBQVcsR0FBRXhCLGdEQUFtQixDQUFDLFFBQVE7UUFDM0NxQixhQUFhQTtRQUNic0QsVUFBVTFDO1FBQ1Z6QixPQUFPO1lBQUM7WUFBRyxDQUFDO1lBQUc7U0FBRTtRQUNqQm9FLFVBQVU7WUFBQyxDQUFDL0IsS0FBS0MsRUFBRSxHQUFHO1lBQUc7WUFBRztTQUFFO0lBQ2hDLEdBQUcsV0FBVyxHQUFFOUMsZ0RBQW1CLENBQUMscUJBQXFCO1FBQ3ZENkUsYUFBYTtRQUNiQyxLQUFLOUMsYUFBYVMsT0FBTztRQUN6QjlCLFNBQVNBO1FBQ1RTLFlBQVlBO0lBQ2QsS0FBSyxXQUFXLEdBQUVwQixnREFBbUIsQ0FBQyxzQkFBc0I7UUFDMUR3QixLQUFLSztRQUNMa0QsTUFBTTtZQUFDLENBQUNuRSxRQUFRO1lBQUdBLFFBQVE7WUFBR0MsU0FBUztZQUFHLENBQUNBLFNBQVM7WUFBR0U7WUFBTUM7U0FBSTtJQUNuRTtBQUNGO0FBRTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2hhaXNhYm0vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9Db250YWN0U2hhZG93cy5qcz8zNzU1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB7IHVzZVRocmVlLCB1c2VGcmFtZSB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgeyBIb3Jpem9udGFsQmx1clNoYWRlciwgVmVydGljYWxCbHVyU2hhZGVyIH0gZnJvbSAndGhyZWUtc3RkbGliJztcblxuY29uc3QgQ29udGFjdFNoYWRvd3MgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIHNjYWxlID0gMTAsXG4gIGZyYW1lcyA9IEluZmluaXR5LFxuICBvcGFjaXR5ID0gMSxcbiAgd2lkdGggPSAxLFxuICBoZWlnaHQgPSAxLFxuICBibHVyID0gMSxcbiAgbmVhciA9IDAsXG4gIGZhciA9IDEwLFxuICByZXNvbHV0aW9uID0gNTEyLFxuICBzbW9vdGggPSB0cnVlLFxuICBjb2xvciA9ICcjMDAwMDAwJyxcbiAgZGVwdGhXcml0ZSA9IGZhbHNlLFxuICByZW5kZXJPcmRlcixcbiAgLi4ucHJvcHNcbn0sIGZyZWYpID0+IHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBzY2VuZSA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLnNjZW5lKTtcbiAgY29uc3QgZ2wgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5nbCk7XG4gIGNvbnN0IHNoYWRvd0NhbWVyYSA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgd2lkdGggPSB3aWR0aCAqIChBcnJheS5pc0FycmF5KHNjYWxlKSA/IHNjYWxlWzBdIDogc2NhbGUgfHwgMSk7XG4gIGhlaWdodCA9IGhlaWdodCAqIChBcnJheS5pc0FycmF5KHNjYWxlKSA/IHNjYWxlWzFdIDogc2NhbGUgfHwgMSk7XG4gIGNvbnN0IFtyZW5kZXJUYXJnZXQsIHBsYW5lR2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwsIGJsdXJQbGFuZSwgaG9yaXpvbnRhbEJsdXJNYXRlcmlhbCwgdmVydGljYWxCbHVyTWF0ZXJpYWwsIHJlbmRlclRhcmdldEJsdXJdID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0KHJlc29sdXRpb24sIHJlc29sdXRpb24pO1xuICAgIGNvbnN0IHJlbmRlclRhcmdldEJsdXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQocmVzb2x1dGlvbiwgcmVzb2x1dGlvbik7XG4gICAgcmVuZGVyVGFyZ2V0Qmx1ci50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgIGNvbnN0IHBsYW5lR2VvbWV0cnkgPSBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeSh3aWR0aCwgaGVpZ2h0KS5yb3RhdGVYKE1hdGguUEkgLyAyKTtcbiAgICBjb25zdCBibHVyUGxhbmUgPSBuZXcgVEhSRUUuTWVzaChwbGFuZUdlb21ldHJ5KTtcbiAgICBjb25zdCBkZXB0aE1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsKCk7XG4gICAgZGVwdGhNYXRlcmlhbC5kZXB0aFRlc3QgPSBkZXB0aE1hdGVyaWFsLmRlcHRoV3JpdGUgPSBmYWxzZTtcbiAgICBkZXB0aE1hdGVyaWFsLm9uQmVmb3JlQ29tcGlsZSA9IHNoYWRlciA9PiB7XG4gICAgICBzaGFkZXIudW5pZm9ybXMgPSB7XG4gICAgICAgIC4uLnNoYWRlci51bmlmb3JtcyxcbiAgICAgICAgdWNvbG9yOiB7XG4gICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcihjb2xvcilcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNoYWRlci5mcmFnbWVudFNoYWRlciA9IHNoYWRlci5mcmFnbWVudFNoYWRlci5yZXBsYWNlKGB2b2lkIG1haW4oKSB7YCxcbiAgICAgIC8vXG4gICAgICBgdW5pZm9ybSB2ZWMzIHVjb2xvcjtcbiAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgIGApO1xuICAgICAgc2hhZGVyLmZyYWdtZW50U2hhZGVyID0gc2hhZGVyLmZyYWdtZW50U2hhZGVyLnJlcGxhY2UoJ3ZlYzQoIHZlYzMoIDEuMCAtIGZyYWdDb29yZFogKSwgb3BhY2l0eSApOycsXG4gICAgICAvLyBDb2xvcml6ZSB0aGUgc2hhZG93LCBtdWx0aXBseSBieSB0aGUgZmFsbG9mZiBzbyB0aGF0IHRoZSBjZW50ZXIgY2FuIHJlbWFpbiBkYXJrZXJcbiAgICAgICd2ZWM0KCB1Y29sb3IgKiBmcmFnQ29vcmRaICogMi4wLCAoIDEuMCAtIGZyYWdDb29yZFogKSAqIDEuMCApOycpO1xuICAgIH07XG4gICAgY29uc3QgaG9yaXpvbnRhbEJsdXJNYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbChIb3Jpem9udGFsQmx1clNoYWRlcik7XG4gICAgY29uc3QgdmVydGljYWxCbHVyTWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoVmVydGljYWxCbHVyU2hhZGVyKTtcbiAgICB2ZXJ0aWNhbEJsdXJNYXRlcmlhbC5kZXB0aFRlc3QgPSBob3Jpem9udGFsQmx1ck1hdGVyaWFsLmRlcHRoVGVzdCA9IGZhbHNlO1xuICAgIHJldHVybiBbcmVuZGVyVGFyZ2V0LCBwbGFuZUdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBibHVyUGxhbmUsIGhvcml6b250YWxCbHVyTWF0ZXJpYWwsIHZlcnRpY2FsQmx1ck1hdGVyaWFsLCByZW5kZXJUYXJnZXRCbHVyXTtcbiAgfSwgW3Jlc29sdXRpb24sIHdpZHRoLCBoZWlnaHQsIHNjYWxlLCBjb2xvcl0pO1xuICBjb25zdCBibHVyU2hhZG93cyA9IGJsdXIgPT4ge1xuICAgIGJsdXJQbGFuZS52aXNpYmxlID0gdHJ1ZTtcbiAgICBibHVyUGxhbmUubWF0ZXJpYWwgPSBob3Jpem9udGFsQmx1ck1hdGVyaWFsO1xuICAgIGhvcml6b250YWxCbHVyTWF0ZXJpYWwudW5pZm9ybXMudERpZmZ1c2UudmFsdWUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgICBob3Jpem9udGFsQmx1ck1hdGVyaWFsLnVuaWZvcm1zLmgudmFsdWUgPSBibHVyICogMSAvIDI1NjtcbiAgICBnbC5zZXRSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0Qmx1cik7XG4gICAgZ2wucmVuZGVyKGJsdXJQbGFuZSwgc2hhZG93Q2FtZXJhLmN1cnJlbnQpO1xuICAgIGJsdXJQbGFuZS5tYXRlcmlhbCA9IHZlcnRpY2FsQmx1ck1hdGVyaWFsO1xuICAgIHZlcnRpY2FsQmx1ck1hdGVyaWFsLnVuaWZvcm1zLnREaWZmdXNlLnZhbHVlID0gcmVuZGVyVGFyZ2V0Qmx1ci50ZXh0dXJlO1xuICAgIHZlcnRpY2FsQmx1ck1hdGVyaWFsLnVuaWZvcm1zLnYudmFsdWUgPSBibHVyICogMSAvIDI1NjtcbiAgICBnbC5zZXRSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KTtcbiAgICBnbC5yZW5kZXIoYmx1clBsYW5lLCBzaGFkb3dDYW1lcmEuY3VycmVudCk7XG4gICAgYmx1clBsYW5lLnZpc2libGUgPSBmYWxzZTtcbiAgfTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IGluaXRpYWxCYWNrZ3JvdW5kO1xuICBsZXQgaW5pdGlhbE92ZXJyaWRlTWF0ZXJpYWw7XG4gIHVzZUZyYW1lKCgpID0+IHtcbiAgICBpZiAoc2hhZG93Q2FtZXJhLmN1cnJlbnQgJiYgKGZyYW1lcyA9PT0gSW5maW5pdHkgfHwgY291bnQgPCBmcmFtZXMpKSB7XG4gICAgICBjb3VudCsrO1xuICAgICAgaW5pdGlhbEJhY2tncm91bmQgPSBzY2VuZS5iYWNrZ3JvdW5kO1xuICAgICAgaW5pdGlhbE92ZXJyaWRlTWF0ZXJpYWwgPSBzY2VuZS5vdmVycmlkZU1hdGVyaWFsO1xuICAgICAgcmVmLmN1cnJlbnQudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgc2NlbmUuYmFja2dyb3VuZCA9IG51bGw7XG4gICAgICBzY2VuZS5vdmVycmlkZU1hdGVyaWFsID0gZGVwdGhNYXRlcmlhbDtcbiAgICAgIGdsLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpO1xuICAgICAgZ2wucmVuZGVyKHNjZW5lLCBzaGFkb3dDYW1lcmEuY3VycmVudCk7XG4gICAgICBibHVyU2hhZG93cyhibHVyKTtcbiAgICAgIGlmIChzbW9vdGgpIGJsdXJTaGFkb3dzKGJsdXIgKiAwLjQpO1xuICAgICAgZ2wuc2V0UmVuZGVyVGFyZ2V0KG51bGwpO1xuICAgICAgcmVmLmN1cnJlbnQudmlzaWJsZSA9IHRydWU7XG4gICAgICBzY2VuZS5vdmVycmlkZU1hdGVyaWFsID0gaW5pdGlhbE92ZXJyaWRlTWF0ZXJpYWw7XG4gICAgICBzY2VuZS5iYWNrZ3JvdW5kID0gaW5pdGlhbEJhY2tncm91bmQ7XG4gICAgfVxuICB9KTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShmcmVmLCAoKSA9PiByZWYuY3VycmVudCwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLCBfZXh0ZW5kcyh7XG4gICAgXCJyb3RhdGlvbi14XCI6IE1hdGguUEkgLyAyXG4gIH0sIHByb3BzLCB7XG4gICAgcmVmOiByZWZcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLCB7XG4gICAgcmVuZGVyT3JkZXI6IHJlbmRlck9yZGVyLFxuICAgIGdlb21ldHJ5OiBwbGFuZUdlb21ldHJ5LFxuICAgIHNjYWxlOiBbMSwgLTEsIDFdLFxuICAgIHJvdGF0aW9uOiBbLU1hdGguUEkgLyAyLCAwLCAwXVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1lc2hCYXNpY01hdGVyaWFsXCIsIHtcbiAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICBtYXA6IHJlbmRlclRhcmdldC50ZXh0dXJlLFxuICAgIG9wYWNpdHk6IG9wYWNpdHksXG4gICAgZGVwdGhXcml0ZTogZGVwdGhXcml0ZVxuICB9KSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwib3J0aG9ncmFwaGljQ2FtZXJhXCIsIHtcbiAgICByZWY6IHNoYWRvd0NhbWVyYSxcbiAgICBhcmdzOiBbLXdpZHRoIC8gMiwgd2lkdGggLyAyLCBoZWlnaHQgLyAyLCAtaGVpZ2h0IC8gMiwgbmVhciwgZmFyXVxuICB9KSk7XG59KTtcblxuZXhwb3J0IHsgQ29udGFjdFNoYWRvd3MgfTtcbiJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsIlJlYWN0IiwiVEhSRUUiLCJ1c2VUaHJlZSIsInVzZUZyYW1lIiwiSG9yaXpvbnRhbEJsdXJTaGFkZXIiLCJWZXJ0aWNhbEJsdXJTaGFkZXIiLCJDb250YWN0U2hhZG93cyIsImZvcndhcmRSZWYiLCJzY2FsZSIsImZyYW1lcyIsIkluZmluaXR5Iiwib3BhY2l0eSIsIndpZHRoIiwiaGVpZ2h0IiwiYmx1ciIsIm5lYXIiLCJmYXIiLCJyZXNvbHV0aW9uIiwic21vb3RoIiwiY29sb3IiLCJkZXB0aFdyaXRlIiwicmVuZGVyT3JkZXIiLCJwcm9wcyIsImZyZWYiLCJyZWYiLCJ1c2VSZWYiLCJzY2VuZSIsInN0YXRlIiwiZ2wiLCJzaGFkb3dDYW1lcmEiLCJBcnJheSIsImlzQXJyYXkiLCJyZW5kZXJUYXJnZXQiLCJwbGFuZUdlb21ldHJ5IiwiZGVwdGhNYXRlcmlhbCIsImJsdXJQbGFuZSIsImhvcml6b250YWxCbHVyTWF0ZXJpYWwiLCJ2ZXJ0aWNhbEJsdXJNYXRlcmlhbCIsInJlbmRlclRhcmdldEJsdXIiLCJ1c2VNZW1vIiwiV2ViR0xSZW5kZXJUYXJnZXQiLCJ0ZXh0dXJlIiwiZ2VuZXJhdGVNaXBtYXBzIiwiUGxhbmVHZW9tZXRyeSIsInJvdGF0ZVgiLCJNYXRoIiwiUEkiLCJNZXNoIiwiTWVzaERlcHRoTWF0ZXJpYWwiLCJkZXB0aFRlc3QiLCJvbkJlZm9yZUNvbXBpbGUiLCJzaGFkZXIiLCJ1bmlmb3JtcyIsInVjb2xvciIsInZhbHVlIiwiQ29sb3IiLCJmcmFnbWVudFNoYWRlciIsInJlcGxhY2UiLCJTaGFkZXJNYXRlcmlhbCIsImJsdXJTaGFkb3dzIiwidmlzaWJsZSIsIm1hdGVyaWFsIiwidERpZmZ1c2UiLCJoIiwic2V0UmVuZGVyVGFyZ2V0IiwicmVuZGVyIiwiY3VycmVudCIsInYiLCJjb3VudCIsImluaXRpYWxCYWNrZ3JvdW5kIiwiaW5pdGlhbE92ZXJyaWRlTWF0ZXJpYWwiLCJiYWNrZ3JvdW5kIiwib3ZlcnJpZGVNYXRlcmlhbCIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJjcmVhdGVFbGVtZW50IiwiZ2VvbWV0cnkiLCJyb3RhdGlvbiIsInRyYW5zcGFyZW50IiwibWFwIiwiYXJncyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/ContactShadows.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Environment.js":
/*!************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Environment.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   EnvironmentCube: () => (/* binding */ EnvironmentCube),\n/* harmony export */   EnvironmentMap: () => (/* binding */ EnvironmentMap),\n/* harmony export */   EnvironmentPortal: () => (/* binding */ EnvironmentPortal)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-29b7121b.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/objects/GroundProjectedEnv.js\");\n/* harmony import */ var _useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useEnvironment.js */ \"(ssr)/./node_modules/@react-three/drei/core/useEnvironment.js\");\n\n\n\n\n\n\nconst isRef = (obj)=>obj.current && obj.current.isScene;\nconst resolveScene = (scene)=>isRef(scene) ? scene.current : scene;\nfunction setEnvProps(background, scene, defaultScene, texture, blur = 0) {\n    const target = resolveScene(scene || defaultScene);\n    const oldbg = target.background;\n    const oldenv = target.environment;\n    // @ts-ignore\n    const oldBlur = target.backgroundBlurriness || 0;\n    if (background !== \"only\") target.environment = texture;\n    if (background) target.background = texture;\n    // @ts-ignore\n    if (background && target.backgroundBlurriness !== undefined) target.backgroundBlurriness = blur;\n    return ()=>{\n        if (background !== \"only\") target.environment = oldenv;\n        if (background) target.background = oldbg;\n        // @ts-ignore\n        if (background && target.backgroundBlurriness !== undefined) target.backgroundBlurriness = oldBlur;\n    };\n}\nfunction EnvironmentMap({ scene, background = false, blur, map }) {\n    const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.scene);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        if (map) return setEnvProps(background, scene, defaultScene, map, blur);\n    }, [\n        defaultScene,\n        scene,\n        map,\n        background,\n        blur\n    ]);\n    return null;\n}\nfunction EnvironmentCube({ background = false, scene, blur, ...rest }) {\n    const texture = (0,_useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__.useEnvironment)(rest);\n    const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.scene);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        return setEnvProps(background, scene, defaultScene, texture, blur);\n    }, [\n        texture,\n        background,\n        scene,\n        defaultScene,\n        blur\n    ]);\n    return null;\n}\nfunction EnvironmentPortal({ children, near = 1, far = 1000, resolution = 256, frames = 1, map, background = false, blur, scene, files, path, preset = undefined, extensions }) {\n    const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.gl);\n    const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.scene);\n    const camera = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const [virtualScene] = react__WEBPACK_IMPORTED_MODULE_1__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Scene());\n    const fbo = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>{\n        const fbo = new three__WEBPACK_IMPORTED_MODULE_4__.WebGLCubeRenderTarget(resolution);\n        fbo.texture.type = three__WEBPACK_IMPORTED_MODULE_4__.HalfFloatType;\n        return fbo;\n    }, [\n        resolution\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        if (frames === 1) camera.current.update(gl, virtualScene);\n        return setEnvProps(background, scene, defaultScene, fbo.texture, blur);\n    }, [\n        children,\n        virtualScene,\n        fbo.texture,\n        scene,\n        defaultScene,\n        background,\n        frames,\n        gl\n    ]);\n    let count = 1;\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(()=>{\n        if (frames === Infinity || count < frames) {\n            camera.current.update(gl, virtualScene);\n            count++;\n        }\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.g)(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, children, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"cubeCamera\", {\n        ref: camera,\n        args: [\n            near,\n            far,\n            fbo\n        ]\n    }), files || preset ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentCube, {\n        background: true,\n        files: files,\n        preset: preset,\n        path: path,\n        extensions: extensions\n    }) : map ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, {\n        background: true,\n        map: map,\n        extensions: extensions\n    }) : null), virtualScene));\n}\nfunction EnvironmentGround(props) {\n    var _props$ground, _props$ground2, _scale, _props$ground3;\n    const textureDefault = (0,_useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__.useEnvironment)(props);\n    const texture = props.map || textureDefault;\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.e)({\n            GroundProjectedEnvImpl: three_stdlib__WEBPACK_IMPORTED_MODULE_5__.GroundProjectedEnv\n        }), []);\n    const args = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>[\n            texture\n        ], [\n        texture\n    ]);\n    const height = (_props$ground = props.ground) == null ? void 0 : _props$ground.height;\n    const radius = (_props$ground2 = props.ground) == null ? void 0 : _props$ground2.radius;\n    const scale = (_scale = (_props$ground3 = props.ground) == null ? void 0 : _props$ground3.scale) !== null && _scale !== void 0 ? _scale : 1000;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n        map: texture\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"groundProjectedEnvImpl\", {\n        args: args,\n        scale: scale,\n        height: height,\n        radius: radius\n    }));\n}\nfunction Environment(props) {\n    return props.ground ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentGround, props) : props.map ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, props) : props.children ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentPortal, props) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentCube, props);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9FbnZpcm9ubWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUMzQjtBQUMrQztBQUNWO0FBQ2xCO0FBQ0c7QUFFckQsTUFBTVcsUUFBUUMsQ0FBQUEsTUFBT0EsSUFBSUMsT0FBTyxJQUFJRCxJQUFJQyxPQUFPLENBQUNDLE9BQU87QUFDdkQsTUFBTUMsZUFBZUMsQ0FBQUEsUUFBU0wsTUFBTUssU0FBU0EsTUFBTUgsT0FBTyxHQUFHRztBQUM3RCxTQUFTQyxZQUFZQyxVQUFVLEVBQUVGLEtBQUssRUFBRUcsWUFBWSxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sQ0FBQztJQUNyRSxNQUFNQyxTQUFTUCxhQUFhQyxTQUFTRztJQUNyQyxNQUFNSSxRQUFRRCxPQUFPSixVQUFVO0lBQy9CLE1BQU1NLFNBQVNGLE9BQU9HLFdBQVc7SUFDakMsYUFBYTtJQUNiLE1BQU1DLFVBQVVKLE9BQU9LLG9CQUFvQixJQUFJO0lBQy9DLElBQUlULGVBQWUsUUFBUUksT0FBT0csV0FBVyxHQUFHTDtJQUNoRCxJQUFJRixZQUFZSSxPQUFPSixVQUFVLEdBQUdFO0lBQ3BDLGFBQWE7SUFDYixJQUFJRixjQUFjSSxPQUFPSyxvQkFBb0IsS0FBS0MsV0FBV04sT0FBT0ssb0JBQW9CLEdBQUdOO0lBQzNGLE9BQU87UUFDTCxJQUFJSCxlQUFlLFFBQVFJLE9BQU9HLFdBQVcsR0FBR0Q7UUFDaEQsSUFBSU4sWUFBWUksT0FBT0osVUFBVSxHQUFHSztRQUNwQyxhQUFhO1FBQ2IsSUFBSUwsY0FBY0ksT0FBT0ssb0JBQW9CLEtBQUtDLFdBQVdOLE9BQU9LLG9CQUFvQixHQUFHRDtJQUM3RjtBQUNGO0FBQ0EsU0FBU0csZUFBZSxFQUN0QmIsS0FBSyxFQUNMRSxhQUFhLEtBQUssRUFDbEJHLElBQUksRUFDSlMsR0FBRyxFQUNKO0lBQ0MsTUFBTVgsZUFBZWpCLHFEQUFRQSxDQUFDNkIsQ0FBQUEs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QUNrQyxtQkFBbUIwQixTQUFTLFdBQVcsR0FBRTVELGdEQUFtQixDQUFDZ0MsaUJBQWlCNEI7QUFDM1I7QUFFMkUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaGFpc2FibS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL0Vudmlyb25tZW50LmpzPzYwNDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlVGhyZWUsIHVzZUZyYW1lLCBjcmVhdGVQb3J0YWwsIGV4dGVuZCB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgeyBTY2VuZSwgV2ViR0xDdWJlUmVuZGVyVGFyZ2V0LCBIYWxmRmxvYXRUeXBlIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgR3JvdW5kUHJvamVjdGVkRW52IH0gZnJvbSAndGhyZWUtc3RkbGliJztcbmltcG9ydCB7IHVzZUVudmlyb25tZW50IH0gZnJvbSAnLi91c2VFbnZpcm9ubWVudC5qcyc7XG5cbmNvbnN0IGlzUmVmID0gb2JqID0+IG9iai5jdXJyZW50ICYmIG9iai5jdXJyZW50LmlzU2NlbmU7XG5jb25zdCByZXNvbHZlU2NlbmUgPSBzY2VuZSA9PiBpc1JlZihzY2VuZSkgPyBzY2VuZS5jdXJyZW50IDogc2NlbmU7XG5mdW5jdGlvbiBzZXRFbnZQcm9wcyhiYWNrZ3JvdW5kLCBzY2VuZSwgZGVmYXVsdFNjZW5lLCB0ZXh0dXJlLCBibHVyID0gMCkge1xuICBjb25zdCB0YXJnZXQgPSByZXNvbHZlU2NlbmUoc2NlbmUgfHwgZGVmYXVsdFNjZW5lKTtcbiAgY29uc3Qgb2xkYmcgPSB0YXJnZXQuYmFja2dyb3VuZDtcbiAgY29uc3Qgb2xkZW52ID0gdGFyZ2V0LmVudmlyb25tZW50O1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IG9sZEJsdXIgPSB0YXJnZXQuYmFja2dyb3VuZEJsdXJyaW5lc3MgfHwgMDtcbiAgaWYgKGJhY2tncm91bmQgIT09ICdvbmx5JykgdGFyZ2V0LmVudmlyb25tZW50ID0gdGV4dHVyZTtcbiAgaWYgKGJhY2tncm91bmQpIHRhcmdldC5iYWNrZ3JvdW5kID0gdGV4dHVyZTtcbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAoYmFja2dyb3VuZCAmJiB0YXJnZXQuYmFja2dyb3VuZEJsdXJyaW5lc3MgIT09IHVuZGVmaW5lZCkgdGFyZ2V0LmJhY2tncm91bmRCbHVycmluZXNzID0gYmx1cjtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBpZiAoYmFja2dyb3VuZCAhPT0gJ29ubHknKSB0YXJnZXQuZW52aXJvbm1lbnQgPSBvbGRlbnY7XG4gICAgaWYgKGJhY2tncm91bmQpIHRhcmdldC5iYWNrZ3JvdW5kID0gb2xkYmc7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChiYWNrZ3JvdW5kICYmIHRhcmdldC5iYWNrZ3JvdW5kQmx1cnJpbmVzcyAhPT0gdW5kZWZpbmVkKSB0YXJnZXQuYmFja2dyb3VuZEJsdXJyaW5lc3MgPSBvbGRCbHVyO1xuICB9O1xufVxuZnVuY3Rpb24gRW52aXJvbm1lbnRNYXAoe1xuICBzY2VuZSxcbiAgYmFja2dyb3VuZCA9IGZhbHNlLFxuICBibHVyLFxuICBtYXBcbn0pIHtcbiAgY29uc3QgZGVmYXVsdFNjZW5lID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuc2NlbmUpO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYXApIHJldHVybiBzZXRFbnZQcm9wcyhiYWNrZ3JvdW5kLCBzY2VuZSwgZGVmYXVsdFNjZW5lLCBtYXAsIGJsdXIpO1xuICB9LCBbZGVmYXVsdFNjZW5lLCBzY2VuZSwgbWFwLCBiYWNrZ3JvdW5kLCBibHVyXSk7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gRW52aXJvbm1lbnRDdWJlKHtcbiAgYmFja2dyb3VuZCA9IGZhbHNlLFxuICBzY2VuZSxcbiAgYmx1cixcbiAgLi4ucmVzdFxufSkge1xuICBjb25zdCB0ZXh0dXJlID0gdXNlRW52aXJvbm1lbnQocmVzdCk7XG4gIGNvbnN0IGRlZmF1bHRTY2VuZSA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLnNjZW5lKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gc2V0RW52UHJvcHMoYmFja2dyb3VuZCwgc2NlbmUsIGRlZmF1bHRTY2VuZSwgdGV4dHVyZSwgYmx1cik7XG4gIH0sIFt0ZXh0dXJlLCBiYWNrZ3JvdW5kLCBzY2VuZSwgZGVmYXVsdFNjZW5lLCBibHVyXSk7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gRW52aXJvbm1lbnRQb3J0YWwoe1xuICBjaGlsZHJlbixcbiAgbmVhciA9IDEsXG4gIGZhciA9IDEwMDAsXG4gIHJlc29sdXRpb24gPSAyNTYsXG4gIGZyYW1lcyA9IDEsXG4gIG1hcCxcbiAgYmFja2dyb3VuZCA9IGZhbHNlLFxuICBibHVyLFxuICBzY2VuZSxcbiAgZmlsZXMsXG4gIHBhdGgsXG4gIHByZXNldCA9IHVuZGVmaW5lZCxcbiAgZXh0ZW5zaW9uc1xufSkge1xuICBjb25zdCBnbCA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLmdsKTtcbiAgY29uc3QgZGVmYXVsdFNjZW5lID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuc2NlbmUpO1xuICBjb25zdCBjYW1lcmEgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IFt2aXJ0dWFsU2NlbmVdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gbmV3IFNjZW5lKCkpO1xuICBjb25zdCBmYm8gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBmYm8gPSBuZXcgV2ViR0xDdWJlUmVuZGVyVGFyZ2V0KHJlc29sdXRpb24pO1xuICAgIGZiby50ZXh0dXJlLnR5cGUgPSBIYWxmRmxvYXRUeXBlO1xuICAgIHJldHVybiBmYm87XG4gIH0sIFtyZXNvbHV0aW9uXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGZyYW1lcyA9PT0gMSkgY2FtZXJhLmN1cnJlbnQudXBkYXRlKGdsLCB2aXJ0dWFsU2NlbmUpO1xuICAgIHJldHVybiBzZXRFbnZQcm9wcyhiYWNrZ3JvdW5kLCBzY2VuZSwgZGVmYXVsdFNjZW5lLCBmYm8udGV4dHVyZSwgYmx1cik7XG4gIH0sIFtjaGlsZHJlbiwgdmlydHVhbFNjZW5lLCBmYm8udGV4dHVyZSwgc2NlbmUsIGRlZmF1bHRTY2VuZSwgYmFja2dyb3VuZCwgZnJhbWVzLCBnbF0pO1xuICBsZXQgY291bnQgPSAxO1xuICB1c2VGcmFtZSgoKSA9PiB7XG4gICAgaWYgKGZyYW1lcyA9PT0gSW5maW5pdHkgfHwgY291bnQgPCBmcmFtZXMpIHtcbiAgICAgIGNhbWVyYS5jdXJyZW50LnVwZGF0ZShnbCwgdmlydHVhbFNjZW5lKTtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjcmVhdGVQb3J0YWwoIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbiwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjdWJlQ2FtZXJhXCIsIHtcbiAgICByZWY6IGNhbWVyYSxcbiAgICBhcmdzOiBbbmVhciwgZmFyLCBmYm9dXG4gIH0pLCBmaWxlcyB8fCBwcmVzZXQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbnZpcm9ubWVudEN1YmUsIHtcbiAgICBiYWNrZ3JvdW5kOiB0cnVlLFxuICAgIGZpbGVzOiBmaWxlcyxcbiAgICBwcmVzZXQ6IHByZXNldCxcbiAgICBwYXRoOiBwYXRoLFxuICAgIGV4dGVuc2lvbnM6IGV4dGVuc2lvbnNcbiAgfSkgOiBtYXAgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbnZpcm9ubWVudE1hcCwge1xuICAgIGJhY2tncm91bmQ6IHRydWUsXG4gICAgbWFwOiBtYXAsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9uc1xuICB9KSA6IG51bGwpLCB2aXJ0dWFsU2NlbmUpKTtcbn1cbmZ1bmN0aW9uIEVudmlyb25tZW50R3JvdW5kKHByb3BzKSB7XG4gIHZhciBfcHJvcHMkZ3JvdW5kLCBfcHJvcHMkZ3JvdW5kMiwgX3NjYWxlLCBfcHJvcHMkZ3JvdW5kMztcbiAgY29uc3QgdGV4dHVyZURlZmF1bHQgPSB1c2VFbnZpcm9ubWVudChwcm9wcyk7XG4gIGNvbnN0IHRleHR1cmUgPSBwcm9wcy5tYXAgfHwgdGV4dHVyZURlZmF1bHQ7XG4gIFJlYWN0LnVzZU1lbW8oKCkgPT4gZXh0ZW5kKHtcbiAgICBHcm91bmRQcm9qZWN0ZWRFbnZJbXBsOiBHcm91bmRQcm9qZWN0ZWRFbnZcbiAgfSksIFtdKTtcbiAgY29uc3QgYXJncyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gW3RleHR1cmVdLCBbdGV4dHVyZV0pO1xuICBjb25zdCBoZWlnaHQgPSAoX3Byb3BzJGdyb3VuZCA9IHByb3BzLmdyb3VuZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcm9wcyRncm91bmQuaGVpZ2h0O1xuICBjb25zdCByYWRpdXMgPSAoX3Byb3BzJGdyb3VuZDIgPSBwcm9wcy5ncm91bmQpID09IG51bGwgPyB2b2lkIDAgOiBfcHJvcHMkZ3JvdW5kMi5yYWRpdXM7XG4gIGNvbnN0IHNjYWxlID0gKF9zY2FsZSA9IChfcHJvcHMkZ3JvdW5kMyA9IHByb3BzLmdyb3VuZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcm9wcyRncm91bmQzLnNjYWxlKSAhPT0gbnVsbCAmJiBfc2NhbGUgIT09IHZvaWQgMCA/IF9zY2FsZSA6IDEwMDA7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRW52aXJvbm1lbnRNYXAsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIG1hcDogdGV4dHVyZVxuICB9KSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZ3JvdW5kUHJvamVjdGVkRW52SW1wbFwiLCB7XG4gICAgYXJnczogYXJncyxcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgcmFkaXVzOiByYWRpdXNcbiAgfSkpO1xufVxuZnVuY3Rpb24gRW52aXJvbm1lbnQocHJvcHMpIHtcbiAgcmV0dXJuIHByb3BzLmdyb3VuZCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVudmlyb25tZW50R3JvdW5kLCBwcm9wcykgOiBwcm9wcy5tYXAgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbnZpcm9ubWVudE1hcCwgcHJvcHMpIDogcHJvcHMuY2hpbGRyZW4gPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbnZpcm9ubWVudFBvcnRhbCwgcHJvcHMpIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRW52aXJvbm1lbnRDdWJlLCBwcm9wcyk7XG59XG5cbmV4cG9ydCB7IEVudmlyb25tZW50LCBFbnZpcm9ubWVudEN1YmUsIEVudmlyb25tZW50TWFwLCBFbnZpcm9ubWVudFBvcnRhbCB9O1xuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwiUmVhY3QiLCJ1c2VUaHJlZSIsInVzZUZyYW1lIiwiY3JlYXRlUG9ydGFsIiwiZXh0ZW5kIiwiU2NlbmUiLCJXZWJHTEN1YmVSZW5kZXJUYXJnZXQiLCJIYWxmRmxvYXRUeXBlIiwiR3JvdW5kUHJvamVjdGVkRW52IiwidXNlRW52aXJvbm1lbnQiLCJpc1JlZiIsIm9iaiIsImN1cnJlbnQiLCJpc1NjZW5lIiwicmVzb2x2ZVNjZW5lIiwic2NlbmUiLCJzZXRFbnZQcm9wcyIsImJhY2tncm91bmQiLCJkZWZhdWx0U2NlbmUiLCJ0ZXh0dXJlIiwiYmx1ciIsInRhcmdldCIsIm9sZGJnIiwib2xkZW52IiwiZW52aXJvbm1lbnQiLCJvbGRCbHVyIiwiYmFja2dyb3VuZEJsdXJyaW5lc3MiLCJ1bmRlZmluZWQiLCJFbnZpcm9ubWVudE1hcCIsIm1hcCIsInN0YXRlIiwidXNlTGF5b3V0RWZmZWN0IiwiRW52aXJvbm1lbnRDdWJlIiwicmVzdCIsIkVudmlyb25tZW50UG9ydGFsIiwiY2hpbGRyZW4iLCJuZWFyIiwiZmFyIiwicmVzb2x1dGlvbiIsImZyYW1lcyIsImZpbGVzIiwicGF0aCIsInByZXNldCIsImV4dGVuc2lvbnMiLCJnbCIsImNhbWVyYSIsInVzZVJlZiIsInZpcnR1YWxTY2VuZSIsInVzZVN0YXRlIiwiZmJvIiwidXNlTWVtbyIsInR5cGUiLCJ1cGRhdGUiLCJjb3VudCIsIkluZmluaXR5IiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwicmVmIiwiYXJncyIsIkVudmlyb25tZW50R3JvdW5kIiwicHJvcHMiLCJfcHJvcHMkZ3JvdW5kIiwiX3Byb3BzJGdyb3VuZDIiLCJfc2NhbGUiLCJfcHJvcHMkZ3JvdW5kMyIsInRleHR1cmVEZWZhdWx0IiwiR3JvdW5kUHJvamVjdGVkRW52SW1wbCIsImhlaWdodCIsImdyb3VuZCIsInJhZGl1cyIsInNjYWxlIiwiRW52aXJvbm1lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Environment.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Float.js":
/*!******************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Float.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Float: () => (/* binding */ Float)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-29b7121b.esm.js\");\n/* harmony import */ var react_merge_refs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-merge-refs */ \"(ssr)/./node_modules/react-merge-refs/dist/react-merge-refs.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\n\n\n\nconst Float = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ children, enabled = true, speed = 1, rotationIntensity = 1, floatIntensity = 1, floatingRange = [\n    -0.1,\n    0.1\n], ...props }, forwardRef)=>{\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const offset = react__WEBPACK_IMPORTED_MODULE_0__.useRef(Math.random() * 10000);\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)((state)=>{\n        var _floatingRange$, _floatingRange$2;\n        if (!enabled || speed === 0) return;\n        const t = offset.current + state.clock.getElapsedTime();\n        ref.current.rotation.x = Math.cos(t / 4 * speed) / 8 * rotationIntensity;\n        ref.current.rotation.y = Math.sin(t / 4 * speed) / 8 * rotationIntensity;\n        ref.current.rotation.z = Math.sin(t / 4 * speed) / 20 * rotationIntensity;\n        let yPosition = Math.sin(t / 4 * speed) / 10;\n        yPosition = three__WEBPACK_IMPORTED_MODULE_3__.MathUtils.mapLinear(yPosition, -0.1, 0.1, (_floatingRange$ = floatingRange == null ? void 0 : floatingRange[0]) !== null && _floatingRange$ !== void 0 ? _floatingRange$ : -0.1, (_floatingRange$2 = floatingRange == null ? void 0 : floatingRange[1]) !== null && _floatingRange$2 !== void 0 ? _floatingRange$2 : 0.1);\n        ref.current.position.y = yPosition * floatIntensity;\n        ref.current.updateMatrix();\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"group\", props, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"group\", {\n        ref: (0,react_merge_refs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n            ref,\n            forwardRef\n        ]),\n        matrixAutoUpdate: false\n    }, children));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9GbG9hdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBK0I7QUFDZTtBQUNMO0FBQ1Y7QUFFL0IsTUFBTUksUUFBUSxhQUFhLGlCQUFFSiw2Q0FBZ0IsQ0FBQyxDQUFDLEVBQzdDTSxRQUFRLEVBQ1JDLFVBQVUsSUFBSSxFQUNkQyxRQUFRLENBQUMsRUFDVEMsb0JBQW9CLENBQUMsRUFDckJDLGlCQUFpQixDQUFDLEVBQ2xCQyxnQkFBZ0I7SUFBQyxDQUFDO0lBQUs7Q0FBSSxFQUMzQixHQUFHQyxPQUNKLEVBQUVQO0lBQ0QsTUFBTVEsTUFBTWIseUNBQVksQ0FBQztJQUN6QixNQUFNZSxTQUFTZix5Q0FBWSxDQUFDZ0IsS0FBS0MsTUFBTSxLQUFLO0lBQzVDaEIscURBQVFBLENBQUNpQixDQUFBQTtRQUNQLElBQUlDLGlCQUFpQkM7UUFDckIsSUFBSSxDQUFDYixXQUFXQyxVQUFVLEdBQUc7UUFDN0IsTUFBTWEsSUFBSU4sT0FBT08sT0FBTyxHQUFHSixNQUFNSyxLQUFLLENBQUNDLGNBQWM7UUFDckRYLElBQUlTLE9BQU8sQ0FBQ0csUUFBUSxDQUFDQyxDQUFDLEdBQUdWLEtBQUtXLEdBQUcsQ0FBQ04sSUFBSSxJQUFJYixTQUFTLElBQUlDO1FBQ3ZESSxJQUFJUyxPQUFPLENBQUNHLFFBQVEsQ0FBQ0csQ0FBQyxHQUFHWixLQUFLYSxHQUFHLENBQUNSLElBQUksSUFBSWIsU0FBUyxJQUFJQztRQUN2REksSUFBSVMsT0FBTyxDQUFDRyxRQUFRLENBQUNLLENBQUMsR0FBR2QsS0FBS2EsR0FBRyxDQUFDUixJQUFJLElBQUliLFNBQVMsS0FBS0M7UUFDeEQsSUFBSXNCLFlBQVlmLEtBQUthLEdBQUcsQ0FBQ1IsSUFBSSxJQUFJYixTQUFTO1FBQzFDdUIsWUFBWTVCLDRDQUFlLENBQUM4QixTQUFTLENBQUNGLFdBQVcsQ0FBQyxLQUFLLEtBQUssQ0FBQ1osa0JBQWtCUixpQkFBaUIsT0FBTyxLQUFLLElBQUlBLGFBQWEsQ0FBQyxFQUFFLE1BQU0sUUFBUVEsb0JBQW9CLEtBQUssSUFBSUEsa0JBQWtCLENBQUMsS0FBSyxDQUFDQyxtQkFBbUJULGlCQUFpQixPQUFPLEtBQUssSUFBSUEsYUFBYSxDQUFDLEVBQUUsTUFBTSxRQUFRUyxxQkFBcUIsS0FBSyxJQUFJQSxtQkFBbUI7UUFDdlVQLElBQUlTLE9BQU8sQ0FBQ1ksUUFBUSxDQUFDTixDQUFDLEdBQUdHLFlBQVlyQjtRQUNyQ0csSUFBSVMsT0FBTyxDQUFDYSxZQUFZO0lBQzFCO0lBQ0EsT0FBTyxXQUFXLEdBQUVuQyxnREFBbUIsQ0FBQyxTQUFTWSxPQUFPLFdBQVcsR0FBRVosZ0RBQW1CLENBQUMsU0FBUztRQUNoR2EsS0FBS1gsNERBQVNBLENBQUM7WUFBQ1c7WUFBS1I7U0FBVztRQUNoQ2dDLGtCQUFrQjtJQUNwQixHQUFHL0I7QUFDTDtBQUVpQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NoYWlzYWJtLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvRmxvYXQuanM/MmVhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VGcmFtZSB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgbWVyZ2VSZWZzIGZyb20gJ3JlYWN0LW1lcmdlLXJlZnMnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuXG5jb25zdCBGbG9hdCA9IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmZvcndhcmRSZWYoKHtcbiAgY2hpbGRyZW4sXG4gIGVuYWJsZWQgPSB0cnVlLFxuICBzcGVlZCA9IDEsXG4gIHJvdGF0aW9uSW50ZW5zaXR5ID0gMSxcbiAgZmxvYXRJbnRlbnNpdHkgPSAxLFxuICBmbG9hdGluZ1JhbmdlID0gWy0wLjEsIDAuMV0sXG4gIC4uLnByb3BzXG59LCBmb3J3YXJkUmVmKSA9PiB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qgb2Zmc2V0ID0gUmVhY3QudXNlUmVmKE1hdGgucmFuZG9tKCkgKiAxMDAwMCk7XG4gIHVzZUZyYW1lKHN0YXRlID0+IHtcbiAgICB2YXIgX2Zsb2F0aW5nUmFuZ2UkLCBfZmxvYXRpbmdSYW5nZSQyO1xuICAgIGlmICghZW5hYmxlZCB8fCBzcGVlZCA9PT0gMCkgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSBvZmZzZXQuY3VycmVudCArIHN0YXRlLmNsb2NrLmdldEVsYXBzZWRUaW1lKCk7XG4gICAgcmVmLmN1cnJlbnQucm90YXRpb24ueCA9IE1hdGguY29zKHQgLyA0ICogc3BlZWQpIC8gOCAqIHJvdGF0aW9uSW50ZW5zaXR5O1xuICAgIHJlZi5jdXJyZW50LnJvdGF0aW9uLnkgPSBNYXRoLnNpbih0IC8gNCAqIHNwZWVkKSAvIDggKiByb3RhdGlvbkludGVuc2l0eTtcbiAgICByZWYuY3VycmVudC5yb3RhdGlvbi56ID0gTWF0aC5zaW4odCAvIDQgKiBzcGVlZCkgLyAyMCAqIHJvdGF0aW9uSW50ZW5zaXR5O1xuICAgIGxldCB5UG9zaXRpb24gPSBNYXRoLnNpbih0IC8gNCAqIHNwZWVkKSAvIDEwO1xuICAgIHlQb3NpdGlvbiA9IFRIUkVFLk1hdGhVdGlscy5tYXBMaW5lYXIoeVBvc2l0aW9uLCAtMC4xLCAwLjEsIChfZmxvYXRpbmdSYW5nZSQgPSBmbG9hdGluZ1JhbmdlID09IG51bGwgPyB2b2lkIDAgOiBmbG9hdGluZ1JhbmdlWzBdKSAhPT0gbnVsbCAmJiBfZmxvYXRpbmdSYW5nZSQgIT09IHZvaWQgMCA/IF9mbG9hdGluZ1JhbmdlJCA6IC0wLjEsIChfZmxvYXRpbmdSYW5nZSQyID0gZmxvYXRpbmdSYW5nZSA9PSBudWxsID8gdm9pZCAwIDogZmxvYXRpbmdSYW5nZVsxXSkgIT09IG51bGwgJiYgX2Zsb2F0aW5nUmFuZ2UkMiAhPT0gdm9pZCAwID8gX2Zsb2F0aW5nUmFuZ2UkMiA6IDAuMSk7XG4gICAgcmVmLmN1cnJlbnQucG9zaXRpb24ueSA9IHlQb3NpdGlvbiAqIGZsb2F0SW50ZW5zaXR5O1xuICAgIHJlZi5jdXJyZW50LnVwZGF0ZU1hdHJpeCgpO1xuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIiwgcHJvcHMsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIiwge1xuICAgIHJlZjogbWVyZ2VSZWZzKFtyZWYsIGZvcndhcmRSZWZdKSxcbiAgICBtYXRyaXhBdXRvVXBkYXRlOiBmYWxzZVxuICB9LCBjaGlsZHJlbikpO1xufSk7XG5cbmV4cG9ydCB7IEZsb2F0IH07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VGcmFtZSIsIm1lcmdlUmVmcyIsIlRIUkVFIiwiRmxvYXQiLCJmb3J3YXJkUmVmIiwiY2hpbGRyZW4iLCJlbmFibGVkIiwic3BlZWQiLCJyb3RhdGlvbkludGVuc2l0eSIsImZsb2F0SW50ZW5zaXR5IiwiZmxvYXRpbmdSYW5nZSIsInByb3BzIiwicmVmIiwidXNlUmVmIiwib2Zmc2V0IiwiTWF0aCIsInJhbmRvbSIsInN0YXRlIiwiX2Zsb2F0aW5nUmFuZ2UkIiwiX2Zsb2F0aW5nUmFuZ2UkMiIsInQiLCJjdXJyZW50IiwiY2xvY2siLCJnZXRFbGFwc2VkVGltZSIsInJvdGF0aW9uIiwieCIsImNvcyIsInkiLCJzaW4iLCJ6IiwieVBvc2l0aW9uIiwiTWF0aFV0aWxzIiwibWFwTGluZWFyIiwicG9zaXRpb24iLCJ1cGRhdGVNYXRyaXgiLCJjcmVhdGVFbGVtZW50IiwibWF0cml4QXV0b1VwZGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Float.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/useEnvironment.js":
/*!***************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/useEnvironment.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useEnvironment: () => (/* binding */ useEnvironment)\n/* harmony export */ });\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-29b7121b.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/loaders/RGBELoader.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/loaders/EXRLoader.js\");\n/* harmony import */ var _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/environment-assets.js */ \"(ssr)/./node_modules/@react-three/drei/helpers/environment-assets.js\");\n\n\n\n\nconst CUBEMAP_ROOT = \"https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/\";\nconst isArray = (arr)=>Array.isArray(arr);\nfunction useEnvironment({ files = [\n    \"/px.png\",\n    \"/nx.png\",\n    \"/py.png\",\n    \"/ny.png\",\n    \"/pz.png\",\n    \"/nz.png\"\n], path = \"\", preset = undefined, encoding = undefined, extensions } = {}) {\n    var _files$split$pop;\n    let loader = null;\n    let isCubeMap = false;\n    let extension;\n    if (preset) {\n        if (!(preset in _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_0__.presetsObj)) throw new Error(\"Preset must be one of: \" + Object.keys(_helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_0__.presetsObj).join(\", \"));\n        files = _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_0__.presetsObj[preset];\n        path = CUBEMAP_ROOT;\n    }\n    // Everything else\n    isCubeMap = isArray(files);\n    extension = isArray(files) ? \"cube\" : files.startsWith(\"data:application/exr\") ? \"exr\" : files.startsWith(\"data:application/hdr\") ? \"hdr\" : (_files$split$pop = files.split(\".\").pop()) == null || (_files$split$pop = _files$split$pop.split(\"?\")) == null || (_files$split$pop = _files$split$pop.shift()) == null ? void 0 : _files$split$pop.toLowerCase();\n    loader = isCubeMap ? three__WEBPACK_IMPORTED_MODULE_1__.CubeTextureLoader : extension === \"hdr\" ? three_stdlib__WEBPACK_IMPORTED_MODULE_2__.RGBELoader : extension === \"exr\" ? three_stdlib__WEBPACK_IMPORTED_MODULE_3__.EXRLoader : null;\n    if (!loader) throw new Error(\"useEnvironment: Unrecognized file extension: \" + files);\n    const loaderResult = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.F)(// @ts-expect-error\n    loader, isCubeMap ? [\n        files\n    ] : files, (loader)=>{\n        loader.setPath == null || loader.setPath(path);\n        if (extensions) extensions(loader);\n    });\n    const texture = isCubeMap ? // @ts-ignore\n    loaderResult[0] : loaderResult;\n    texture.mapping = isCubeMap ? three__WEBPACK_IMPORTED_MODULE_1__.CubeReflectionMapping : three__WEBPACK_IMPORTED_MODULE_1__.EquirectangularReflectionMapping;\n    const sRGBEncoding = 3001;\n    const LinearEncoding = 3000;\n    if (\"colorSpace\" in texture) texture.colorSpace = (encoding !== null && encoding !== void 0 ? encoding : isCubeMap) ? \"srgb\" : \"srgb-linear\";\n    else texture.encoding = (encoding !== null && encoding !== void 0 ? encoding : isCubeMap) ? sRGBEncoding : LinearEncoding;\n    return texture;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS91c2VFbnZpcm9ubWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBK0M7QUFDb0Q7QUFDOUM7QUFDUztBQUU5RCxNQUFNTyxlQUFlO0FBQ3JCLE1BQU1DLFVBQVVDLENBQUFBLE1BQU9DLE1BQU1GLE9BQU8sQ0FBQ0M7QUFDckMsU0FBU0UsZUFBZSxFQUN0QkMsUUFBUTtJQUFDO0lBQVc7SUFBVztJQUFXO0lBQVc7SUFBVztDQUFVLEVBQzFFQyxPQUFPLEVBQUUsRUFDVEMsU0FBU0MsU0FBUyxFQUNsQkMsV0FBV0QsU0FBUyxFQUNwQkUsVUFBVSxFQUNYLEdBQUcsQ0FBQyxDQUFDO0lBQ0osSUFBSUM7SUFDSixJQUFJQyxTQUFTO0lBQ2IsSUFBSUMsWUFBWTtJQUNoQixJQUFJQztJQUNKLElBQUlQLFFBQVE7UUFDVixJQUFJLENBQUVBLENBQUFBLFVBQVVSLHNFQUFTLEdBQUksTUFBTSxJQUFJZ0IsTUFBTSw0QkFBNEJDLE9BQU9DLElBQUksQ0FBQ2xCLHNFQUFVQSxFQUFFbUIsSUFBSSxDQUFDO1FBQ3RHYixRQUFRTixzRUFBVSxDQUFDUSxPQUFPO1FBQzFCRCxPQUFPTjtJQUNUO0lBRUEsa0JBQWtCO0lBQ2xCYSxZQUFZWixRQUFRSTtJQUNwQlMsWUFBWWIsUUFBUUksU0FBUyxTQUFTQSxNQUFNYyxVQUFVLENBQUMsMEJBQTBCLFFBQVFkLE1BQU1jLFVBQVUsQ0FBQywwQkFBMEIsUUFBUSxDQUFDUixtQkFBbUJOLE1BQU1lLEtBQUssQ0FBQyxLQUFLQyxHQUFHLEVBQUMsS0FBTSxRQUFRLENBQUNWLG1CQUFtQkEsaUJBQWlCUyxLQUFLLENBQUMsSUFBRyxLQUFNLFFBQVEsQ0FBQ1QsbUJBQW1CQSxpQkFBaUJXLEtBQUssRUFBQyxLQUFNLE9BQU8sS0FBSyxJQUFJWCxpQkFBaUJZLFdBQVc7SUFDNVZYLFNBQVNDLFlBQVlqQixvREFBaUJBLEdBQUdrQixjQUFjLFFBQVFqQixvREFBVUEsR0FBR2lCLGNBQWMsUUFBUWhCLG1EQUFTQSxHQUFHO0lBQzlHLElBQUksQ0FBQ2MsUUFBUSxNQUFNLElBQUlHLE1BQU0sa0RBQWtEVjtJQUMvRSxNQUFNbUIsZUFBZS9CLHFEQUFTQSxDQUM5QixtQkFBbUI7SUFDbkJtQixRQUFRQyxZQUFZO1FBQUNSO0tBQU0sR0FBR0EsT0FBT08sQ0FBQUE7UUFDbkNBLE9BQU9hLE9BQU8sSUFBSSxRQUFRYixPQUFPYSxPQUFPLENBQUNuQjtRQUN6QyxJQUFJSSxZQUFZQSxXQUFXRTtJQUM3QjtJQUNBLE1BQU1jLFVBQVViLFlBQ2hCLGFBQWE7SUFDYlcsWUFBWSxDQUFDLEVBQUUsR0FBR0E7SUFDbEJFLFFBQVFDLE9BQU8sR0FBR2QsWUFBWW5CLHdEQUFxQkEsR0FBR0MsbUVBQWdDQTtJQUN0RixNQUFNaUMsZUFBZTtJQUNyQixNQUFNQyxpQkFBaUI7SUFDdkIsSUFBSSxnQkFBZ0JILFNBQVNBLFFBQVFJLFVBQVUsR0FBRyxDQUFDckIsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSUEsV0FBV0ksU0FBUSxJQUFLLFNBQVM7U0FBbUJhLFFBQVFqQixRQUFRLEdBQUcsQ0FBQ0EsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSUEsV0FBV0ksU0FBUSxJQUFLZSxlQUFlQztJQUN4UCxPQUFPSDtBQUNUO0FBRTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2hhaXNhYm0vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS91c2VFbnZpcm9ubWVudC5qcz83MGM5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUxvYWRlciB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgeyBDdWJlUmVmbGVjdGlvbk1hcHBpbmcsIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLCBDdWJlVGV4dHVyZUxvYWRlciB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IFJHQkVMb2FkZXIsIEVYUkxvYWRlciB9IGZyb20gJ3RocmVlLXN0ZGxpYic7XG5pbXBvcnQgeyBwcmVzZXRzT2JqIH0gZnJvbSAnLi4vaGVscGVycy9lbnZpcm9ubWVudC1hc3NldHMuanMnO1xuXG5jb25zdCBDVUJFTUFQX1JPT1QgPSAnaHR0cHM6Ly9yYXcuZ2l0aGFjay5jb20vcG1uZHJzL2RyZWktYXNzZXRzLzQ1NjA2MGEyNmJiZWI4ZmRmNzkzMjZmMjI0YjZkOTliOGJjY2U3MzYvaGRyaS8nO1xuY29uc3QgaXNBcnJheSA9IGFyciA9PiBBcnJheS5pc0FycmF5KGFycik7XG5mdW5jdGlvbiB1c2VFbnZpcm9ubWVudCh7XG4gIGZpbGVzID0gWycvcHgucG5nJywgJy9ueC5wbmcnLCAnL3B5LnBuZycsICcvbnkucG5nJywgJy9wei5wbmcnLCAnL256LnBuZyddLFxuICBwYXRoID0gJycsXG4gIHByZXNldCA9IHVuZGVmaW5lZCxcbiAgZW5jb2RpbmcgPSB1bmRlZmluZWQsXG4gIGV4dGVuc2lvbnNcbn0gPSB7fSkge1xuICB2YXIgX2ZpbGVzJHNwbGl0JHBvcDtcbiAgbGV0IGxvYWRlciA9IG51bGw7XG4gIGxldCBpc0N1YmVNYXAgPSBmYWxzZTtcbiAgbGV0IGV4dGVuc2lvbjtcbiAgaWYgKHByZXNldCkge1xuICAgIGlmICghKHByZXNldCBpbiBwcmVzZXRzT2JqKSkgdGhyb3cgbmV3IEVycm9yKCdQcmVzZXQgbXVzdCBiZSBvbmUgb2Y6ICcgKyBPYmplY3Qua2V5cyhwcmVzZXRzT2JqKS5qb2luKCcsICcpKTtcbiAgICBmaWxlcyA9IHByZXNldHNPYmpbcHJlc2V0XTtcbiAgICBwYXRoID0gQ1VCRU1BUF9ST09UO1xuICB9XG5cbiAgLy8gRXZlcnl0aGluZyBlbHNlXG4gIGlzQ3ViZU1hcCA9IGlzQXJyYXkoZmlsZXMpO1xuICBleHRlbnNpb24gPSBpc0FycmF5KGZpbGVzKSA/ICdjdWJlJyA6IGZpbGVzLnN0YXJ0c1dpdGgoJ2RhdGE6YXBwbGljYXRpb24vZXhyJykgPyAnZXhyJyA6IGZpbGVzLnN0YXJ0c1dpdGgoJ2RhdGE6YXBwbGljYXRpb24vaGRyJykgPyAnaGRyJyA6IChfZmlsZXMkc3BsaXQkcG9wID0gZmlsZXMuc3BsaXQoJy4nKS5wb3AoKSkgPT0gbnVsbCB8fCAoX2ZpbGVzJHNwbGl0JHBvcCA9IF9maWxlcyRzcGxpdCRwb3Auc3BsaXQoJz8nKSkgPT0gbnVsbCB8fCAoX2ZpbGVzJHNwbGl0JHBvcCA9IF9maWxlcyRzcGxpdCRwb3Auc2hpZnQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9maWxlcyRzcGxpdCRwb3AudG9Mb3dlckNhc2UoKTtcbiAgbG9hZGVyID0gaXNDdWJlTWFwID8gQ3ViZVRleHR1cmVMb2FkZXIgOiBleHRlbnNpb24gPT09ICdoZHInID8gUkdCRUxvYWRlciA6IGV4dGVuc2lvbiA9PT0gJ2V4cicgPyBFWFJMb2FkZXIgOiBudWxsO1xuICBpZiAoIWxvYWRlcikgdGhyb3cgbmV3IEVycm9yKCd1c2VFbnZpcm9ubWVudDogVW5yZWNvZ25pemVkIGZpbGUgZXh0ZW5zaW9uOiAnICsgZmlsZXMpO1xuICBjb25zdCBsb2FkZXJSZXN1bHQgPSB1c2VMb2FkZXIoXG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgbG9hZGVyLCBpc0N1YmVNYXAgPyBbZmlsZXNdIDogZmlsZXMsIGxvYWRlciA9PiB7XG4gICAgbG9hZGVyLnNldFBhdGggPT0gbnVsbCB8fCBsb2FkZXIuc2V0UGF0aChwYXRoKTtcbiAgICBpZiAoZXh0ZW5zaW9ucykgZXh0ZW5zaW9ucyhsb2FkZXIpO1xuICB9KTtcbiAgY29uc3QgdGV4dHVyZSA9IGlzQ3ViZU1hcCA/XG4gIC8vIEB0cy1pZ25vcmVcbiAgbG9hZGVyUmVzdWx0WzBdIDogbG9hZGVyUmVzdWx0O1xuICB0ZXh0dXJlLm1hcHBpbmcgPSBpc0N1YmVNYXAgPyBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgOiBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZztcbiAgY29uc3Qgc1JHQkVuY29kaW5nID0gMzAwMTtcbiAgY29uc3QgTGluZWFyRW5jb2RpbmcgPSAzMDAwO1xuICBpZiAoJ2NvbG9yU3BhY2UnIGluIHRleHR1cmUpIHRleHR1cmUuY29sb3JTcGFjZSA9IChlbmNvZGluZyAhPT0gbnVsbCAmJiBlbmNvZGluZyAhPT0gdm9pZCAwID8gZW5jb2RpbmcgOiBpc0N1YmVNYXApID8gJ3NyZ2InIDogJ3NyZ2ItbGluZWFyJztlbHNlIHRleHR1cmUuZW5jb2RpbmcgPSAoZW5jb2RpbmcgIT09IG51bGwgJiYgZW5jb2RpbmcgIT09IHZvaWQgMCA/IGVuY29kaW5nIDogaXNDdWJlTWFwKSA/IHNSR0JFbmNvZGluZyA6IExpbmVhckVuY29kaW5nO1xuICByZXR1cm4gdGV4dHVyZTtcbn1cblxuZXhwb3J0IHsgdXNlRW52aXJvbm1lbnQgfTtcbiJdLCJuYW1lcyI6WyJ1c2VMb2FkZXIiLCJDdWJlUmVmbGVjdGlvbk1hcHBpbmciLCJFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyIsIkN1YmVUZXh0dXJlTG9hZGVyIiwiUkdCRUxvYWRlciIsIkVYUkxvYWRlciIsInByZXNldHNPYmoiLCJDVUJFTUFQX1JPT1QiLCJpc0FycmF5IiwiYXJyIiwiQXJyYXkiLCJ1c2VFbnZpcm9ubWVudCIsImZpbGVzIiwicGF0aCIsInByZXNldCIsInVuZGVmaW5lZCIsImVuY29kaW5nIiwiZXh0ZW5zaW9ucyIsIl9maWxlcyRzcGxpdCRwb3AiLCJsb2FkZXIiLCJpc0N1YmVNYXAiLCJleHRlbnNpb24iLCJFcnJvciIsIk9iamVjdCIsImtleXMiLCJqb2luIiwic3RhcnRzV2l0aCIsInNwbGl0IiwicG9wIiwic2hpZnQiLCJ0b0xvd2VyQ2FzZSIsImxvYWRlclJlc3VsdCIsInNldFBhdGgiLCJ0ZXh0dXJlIiwibWFwcGluZyIsInNSR0JFbmNvZGluZyIsIkxpbmVhckVuY29kaW5nIiwiY29sb3JTcGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/useEnvironment.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/helpers/environment-assets.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@react-three/drei/helpers/environment-assets.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   presetsObj: () => (/* binding */ presetsObj)\n/* harmony export */ });\nconst presetsObj = {\n    apartment: \"lebombo_1k.hdr\",\n    city: \"potsdamer_platz_1k.hdr\",\n    dawn: \"kiara_1_dawn_1k.hdr\",\n    forest: \"forest_slope_1k.hdr\",\n    lobby: \"st_fagans_interior_1k.hdr\",\n    night: \"dikhololo_night_1k.hdr\",\n    park: \"rooitou_park_1k.hdr\",\n    studio: \"studio_small_03_1k.hdr\",\n    sunset: \"venice_sunset_1k.hdr\",\n    warehouse: \"empty_warehouse_01_1k.hdr\"\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9lbnZpcm9ubWVudC1hc3NldHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLGFBQWE7SUFDakJDLFdBQVc7SUFDWEMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsT0FBTztJQUNQQyxPQUFPO0lBQ1BDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFdBQVc7QUFDYjtBQUVzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NoYWlzYWJtLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2hlbHBlcnMvZW52aXJvbm1lbnQtYXNzZXRzLmpzPzE2NTEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcHJlc2V0c09iaiA9IHtcbiAgYXBhcnRtZW50OiAnbGVib21ib18xay5oZHInLFxuICBjaXR5OiAncG90c2RhbWVyX3BsYXR6XzFrLmhkcicsXG4gIGRhd246ICdraWFyYV8xX2Rhd25fMWsuaGRyJyxcbiAgZm9yZXN0OiAnZm9yZXN0X3Nsb3BlXzFrLmhkcicsXG4gIGxvYmJ5OiAnc3RfZmFnYW5zX2ludGVyaW9yXzFrLmhkcicsXG4gIG5pZ2h0OiAnZGlraG9sb2xvX25pZ2h0XzFrLmhkcicsXG4gIHBhcms6ICdyb29pdG91X3BhcmtfMWsuaGRyJyxcbiAgc3R1ZGlvOiAnc3R1ZGlvX3NtYWxsXzAzXzFrLmhkcicsXG4gIHN1bnNldDogJ3ZlbmljZV9zdW5zZXRfMWsuaGRyJyxcbiAgd2FyZWhvdXNlOiAnZW1wdHlfd2FyZWhvdXNlXzAxXzFrLmhkcidcbn07XG5cbmV4cG9ydCB7IHByZXNldHNPYmogfTtcbiJdLCJuYW1lcyI6WyJwcmVzZXRzT2JqIiwiYXBhcnRtZW50IiwiY2l0eSIsImRhd24iLCJmb3Jlc3QiLCJsb2JieSIsIm5pZ2h0IiwicGFyayIsInN0dWRpbyIsInN1bnNldCIsIndhcmVob3VzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/helpers/environment-assets.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/index-29b7121b.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/index-29b7121b.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ useThree),\n/* harmony export */   B: () => (/* binding */ Block),\n/* harmony export */   C: () => (/* binding */ useFrame),\n/* harmony export */   D: () => (/* binding */ useGraph),\n/* harmony export */   E: () => (/* binding */ ErrorBoundary),\n/* harmony export */   F: () => (/* binding */ useLoader),\n/* harmony export */   a: () => (/* binding */ useIsomorphicLayoutEffect),\n/* harmony export */   b: () => (/* binding */ createRoot),\n/* harmony export */   c: () => (/* binding */ createEvents),\n/* harmony export */   d: () => (/* binding */ unmountComponentAtNode),\n/* harmony export */   e: () => (/* binding */ extend),\n/* harmony export */   f: () => (/* binding */ context),\n/* harmony export */   g: () => (/* binding */ createPortal),\n/* harmony export */   h: () => (/* binding */ reconciler),\n/* harmony export */   i: () => (/* binding */ isRef),\n/* harmony export */   j: () => (/* binding */ applyProps),\n/* harmony export */   k: () => (/* binding */ dispose),\n/* harmony export */   l: () => (/* binding */ invalidate),\n/* harmony export */   m: () => (/* binding */ advance),\n/* harmony export */   n: () => (/* binding */ addEffect),\n/* harmony export */   o: () => (/* binding */ addAfterEffect),\n/* harmony export */   p: () => (/* binding */ addTail),\n/* harmony export */   q: () => (/* binding */ flushGlobalEffects),\n/* harmony export */   r: () => (/* binding */ render),\n/* harmony export */   s: () => (/* binding */ getRootState),\n/* harmony export */   t: () => (/* binding */ threeTypes),\n/* harmony export */   u: () => (/* binding */ useMutableCallback),\n/* harmony export */   v: () => (/* binding */ act),\n/* harmony export */   w: () => (/* binding */ buildGraph),\n/* harmony export */   x: () => (/* binding */ roots),\n/* harmony export */   y: () => (/* binding */ useInstanceHandle),\n/* harmony export */   z: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand */ \"(ssr)/./node_modules/zustand/esm/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.js\");\n\n\n\n\n\n\n\nvar threeTypes = /*#__PURE__*/ Object.freeze({\n    __proto__: null\n});\nconst catalogue = {};\nconst extend = (objects)=>void Object.assign(catalogue, objects);\nfunction createRenderer(_roots, _getEventPriority) {\n    function createInstance(type, { args = [], attach, ...props }, root) {\n        let name = `${type[0].toUpperCase()}${type.slice(1)}`;\n        let instance;\n        if (type === \"primitive\") {\n            if (props.object === undefined) throw new Error(\"R3F: Primitives without 'object' are invalid!\");\n            const object = props.object;\n            instance = prepare(object, {\n                type,\n                root,\n                attach,\n                primitive: true\n            });\n        } else {\n            const target = catalogue[name];\n            if (!target) {\n                throw new Error(`R3F: ${name} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);\n            }\n            // Throw if an object or literal was passed for args\n            if (!Array.isArray(args)) throw new Error(\"R3F: The args prop must be an array!\");\n            // Instanciate new object, link it to the root\n            // Append memoized props with args so it's not forgotten\n            instance = prepare(new target(...args), {\n                type,\n                root,\n                attach,\n                // Save args in case we need to reconstruct later for HMR\n                memoizedProps: {\n                    args\n                }\n            });\n        }\n        // Auto-attach geometries and materials\n        if (instance.__r3f.attach === undefined) {\n            if (instance instanceof three__WEBPACK_IMPORTED_MODULE_4__.BufferGeometry) instance.__r3f.attach = \"geometry\";\n            else if (instance instanceof three__WEBPACK_IMPORTED_MODULE_4__.Material) instance.__r3f.attach = \"material\";\n        }\n        // It should NOT call onUpdate on object instanciation, because it hasn't been added to the\n        // view yet. If the callback relies on references for instance, they won't be ready yet, this is\n        // why it passes \"true\" here\n        // There is no reason to apply props to injects\n        if (name !== \"inject\") applyProps$1(instance, props);\n        return instance;\n    }\n    function appendChild(parentInstance, child) {\n        let added = false;\n        if (child) {\n            var _child$__r3f, _parentInstance$__r3f;\n            // The attach attribute implies that the object attaches itself on the parent\n            if ((_child$__r3f = child.__r3f) != null && _child$__r3f.attach) {\n                attach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                // add in the usual parent-child way\n                parentInstance.add(child);\n                added = true;\n            }\n            // This is for anything that used attach, and for non-Object3Ds that don't get attached to props;\n            // that is, anything that's a child in React but not a child in the scenegraph.\n            if (!added) (_parentInstance$__r3f = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f.objects.push(child);\n            if (!child.__r3f) prepare(child, {});\n            child.__r3f.parent = parentInstance;\n            updateInstance(child);\n            invalidateInstance(child);\n        }\n    }\n    function insertBefore(parentInstance, child, beforeChild) {\n        let added = false;\n        if (child) {\n            var _child$__r3f2, _parentInstance$__r3f2;\n            if ((_child$__r3f2 = child.__r3f) != null && _child$__r3f2.attach) {\n                attach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                child.parent = parentInstance;\n                child.dispatchEvent({\n                    type: \"added\"\n                });\n                const restSiblings = parentInstance.children.filter((sibling)=>sibling !== child);\n                const index = restSiblings.indexOf(beforeChild);\n                parentInstance.children = [\n                    ...restSiblings.slice(0, index),\n                    child,\n                    ...restSiblings.slice(index)\n                ];\n                added = true;\n            }\n            if (!added) (_parentInstance$__r3f2 = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f2.objects.push(child);\n            if (!child.__r3f) prepare(child, {});\n            child.__r3f.parent = parentInstance;\n            updateInstance(child);\n            invalidateInstance(child);\n        }\n    }\n    function removeRecursive(array, parent, dispose = false) {\n        if (array) [\n            ...array\n        ].forEach((child)=>removeChild(parent, child, dispose));\n    }\n    function removeChild(parentInstance, child, dispose) {\n        if (child) {\n            var _parentInstance$__r3f3, _child$__r3f3, _child$__r3f5;\n            // Clear the parent reference\n            if (child.__r3f) child.__r3f.parent = null;\n            // Remove child from the parents objects\n            if ((_parentInstance$__r3f3 = parentInstance.__r3f) != null && _parentInstance$__r3f3.objects) parentInstance.__r3f.objects = parentInstance.__r3f.objects.filter((x)=>x !== child);\n            // Remove attachment\n            if ((_child$__r3f3 = child.__r3f) != null && _child$__r3f3.attach) {\n                detach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                var _child$__r3f4;\n                parentInstance.remove(child);\n                // @ts-ignore\n                // Remove interactivity on the initial root\n                if ((_child$__r3f4 = child.__r3f) != null && _child$__r3f4.root) {\n                    removeInteractivity(findInitialRoot(child), child);\n                }\n            }\n            // Allow objects to bail out of recursive dispose altogether by passing dispose={null}\n            // Never dispose of primitives because their state may be kept outside of React!\n            // In order for an object to be able to dispose it has to have\n            //   - a dispose method,\n            //   - it cannot be a <primitive object={...} />\n            //   - it cannot be a THREE.Scene, because three has broken it's own api\n            //\n            // Since disposal is recursive, we can check the optional dispose arg, which will be undefined\n            // when the reconciler calls it, but then carry our own check recursively\n            const isPrimitive = (_child$__r3f5 = child.__r3f) == null ? void 0 : _child$__r3f5.primitive;\n            const shouldDispose = !isPrimitive && (dispose === undefined ? child.dispose !== null : dispose);\n            // Remove nested child objects. Primitives should not have objects and children that are\n            // attached to them declaratively ...\n            if (!isPrimitive) {\n                var _child$__r3f6;\n                removeRecursive((_child$__r3f6 = child.__r3f) == null ? void 0 : _child$__r3f6.objects, child, shouldDispose);\n                removeRecursive(child.children, child, shouldDispose);\n            }\n            // Remove references\n            delete child.__r3f;\n            // Dispose item whenever the reconciler feels like it\n            if (shouldDispose && child.dispose && child.type !== \"Scene\") {\n                const callback = ()=>{\n                    try {\n                        child.dispose();\n                    } catch (e) {\n                    /* ... */ }\n                };\n                // Schedule async at runtime, flush sync in testing\n                if (typeof IS_REACT_ACT_ENVIRONMENT === \"undefined\") {\n                    (0,scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_scheduleCallback)(scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_IdlePriority, callback);\n                } else {\n                    callback();\n                }\n            }\n            invalidateInstance(parentInstance);\n        }\n    }\n    function switchInstance(instance, type, newProps, fiber) {\n        var _instance$__r3f;\n        const parent = (_instance$__r3f = instance.__r3f) == null ? void 0 : _instance$__r3f.parent;\n        if (!parent) return;\n        const newInstance = createInstance(type, newProps, instance.__r3f.root);\n        // https://github.com/pmndrs/react-three-fiber/issues/1348\n        // When args change the instance has to be re-constructed, which then\n        // forces r3f to re-parent the children and non-scene objects\n        if (instance.children) {\n            for (const child of instance.children){\n                if (child.__r3f) appendChild(newInstance, child);\n            }\n            instance.children = instance.children.filter((child)=>!child.__r3f);\n        }\n        instance.__r3f.objects.forEach((child)=>appendChild(newInstance, child));\n        instance.__r3f.objects = [];\n        if (!instance.__r3f.autoRemovedBeforeAppend) {\n            removeChild(parent, instance);\n        }\n        if (newInstance.parent) {\n            newInstance.__r3f.autoRemovedBeforeAppend = true;\n        }\n        appendChild(parent, newInstance);\n        // Re-bind event handlers on the initial root\n        if (newInstance.raycast && newInstance.__r3f.eventCount) {\n            const rootState = findInitialRoot(newInstance).getState();\n            rootState.internal.interaction.push(newInstance);\n        }\n        [\n            fiber,\n            fiber.alternate\n        ].forEach((fiber)=>{\n            if (fiber !== null) {\n                fiber.stateNode = newInstance;\n                if (fiber.ref) {\n                    if (typeof fiber.ref === \"function\") fiber.ref(newInstance);\n                    else fiber.ref.current = newInstance;\n                }\n            }\n        });\n    }\n    // Don't handle text instances, warn on undefined behavior\n    const handleTextInstance = ()=>console.warn(\"Text is not allowed in the R3F tree! This could be stray whitespace or characters.\");\n    const reconciler = react_reconciler__WEBPACK_IMPORTED_MODULE_2___default()({\n        createInstance,\n        removeChild,\n        appendChild,\n        appendInitialChild: appendChild,\n        insertBefore,\n        supportsMutation: true,\n        isPrimaryRenderer: false,\n        supportsPersistence: false,\n        supportsHydration: false,\n        noTimeout: -1,\n        appendChildToContainer: (container, child)=>{\n            if (!child) return;\n            // Don't append to unmounted container\n            const scene = container.getState().scene;\n            if (!scene.__r3f) return;\n            // Link current root to the default scene\n            scene.__r3f.root = container;\n            appendChild(scene, child);\n        },\n        removeChildFromContainer: (container, child)=>{\n            if (!child) return;\n            removeChild(container.getState().scene, child);\n        },\n        insertInContainerBefore: (container, child, beforeChild)=>{\n            if (!child || !beforeChild) return;\n            // Don't append to unmounted container\n            const scene = container.getState().scene;\n            if (!scene.__r3f) return;\n            insertBefore(scene, child, beforeChild);\n        },\n        getRootHostContext: ()=>null,\n        getChildHostContext: (parentHostContext)=>parentHostContext,\n        finalizeInitialChildren (instance) {\n            var _instance$__r3f2;\n            const localState = (_instance$__r3f2 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f2 : {};\n            // https://github.com/facebook/react/issues/20271\n            // Returning true will trigger commitMount\n            return Boolean(localState.handlers);\n        },\n        prepareUpdate (instance, _type, oldProps, newProps) {\n            var _instance$__r3f3;\n            const localState = (_instance$__r3f3 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f3 : {};\n            // Create diff-sets\n            if (localState.primitive && newProps.object && newProps.object !== instance) {\n                return [\n                    true\n                ];\n            } else {\n                // This is a data object, let's extract critical information about it\n                const { args: argsNew = [], children: cN, ...restNew } = newProps;\n                const { args: argsOld = [], children: cO, ...restOld } = oldProps;\n                // Throw if an object or literal was passed for args\n                if (!Array.isArray(argsNew)) throw new Error(\"R3F: the args prop must be an array!\");\n                // If it has new props or arguments, then it needs to be re-instantiated\n                if (argsNew.some((value, index)=>value !== argsOld[index])) return [\n                    true\n                ];\n                // Create a diff-set, flag if there are any changes\n                const diff = diffProps(instance, restNew, restOld, true);\n                if (diff.changes.length) return [\n                    false,\n                    diff\n                ];\n                // Otherwise do not touch the instance\n                return null;\n            }\n        },\n        commitUpdate (instance, [reconstruct, diff], type, _oldProps, newProps, fiber) {\n            // Reconstruct when args or <primitive object={...} have changes\n            if (reconstruct) switchInstance(instance, type, newProps, fiber);\n            else applyProps$1(instance, diff);\n        },\n        commitMount (instance, _type, _props, _int) {\n            var _instance$__r3f4;\n            // https://github.com/facebook/react/issues/20271\n            // This will make sure events are only added once to the central container on the initial root\n            const localState = (_instance$__r3f4 = instance.__r3f) != null ? _instance$__r3f4 : {};\n            if (instance.raycast && localState.handlers && localState.eventCount) {\n                findInitialRoot(instance).getState().internal.interaction.push(instance);\n            }\n        },\n        getPublicInstance: (instance)=>instance,\n        prepareForCommit: ()=>null,\n        preparePortalMount: (container)=>prepare(container.getState().scene),\n        resetAfterCommit: ()=>{},\n        shouldSetTextContent: ()=>false,\n        clearContainer: ()=>false,\n        hideInstance (instance) {\n            var _instance$__r3f5;\n            // Detach while the instance is hidden\n            const { attach: type, parent } = (_instance$__r3f5 = instance.__r3f) != null ? _instance$__r3f5 : {};\n            if (type && parent) detach(parent, instance, type);\n            if (instance.isObject3D) instance.visible = false;\n            invalidateInstance(instance);\n        },\n        unhideInstance (instance, props) {\n            var _instance$__r3f6;\n            // Re-attach when the instance is unhidden\n            const { attach: type, parent } = (_instance$__r3f6 = instance.__r3f) != null ? _instance$__r3f6 : {};\n            if (type && parent) attach(parent, instance, type);\n            if (instance.isObject3D && props.visible == null || props.visible) instance.visible = true;\n            invalidateInstance(instance);\n        },\n        createTextInstance: handleTextInstance,\n        hideTextInstance: handleTextInstance,\n        unhideTextInstance: handleTextInstance,\n        // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874\n        // @ts-ignore\n        getCurrentEventPriority: ()=>_getEventPriority ? _getEventPriority() : react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority,\n        beforeActiveInstanceBlur: ()=>{},\n        afterActiveInstanceBlur: ()=>{},\n        detachDeletedInstance: ()=>{},\n        now: typeof performance !== \"undefined\" && is.fun(performance.now) ? performance.now : is.fun(Date.now) ? Date.now : ()=>0,\n        // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503\n        scheduleTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n        cancelTimeout: is.fun(clearTimeout) ? clearTimeout : undefined\n    });\n    return {\n        reconciler,\n        applyProps: applyProps$1\n    };\n}\nvar _window$document, _window$navigator;\n/**\n * Returns `true` with correct TS type inference if an object has a configurable color space (since r152).\n */ const hasColorSpace = (object)=>\"colorSpace\" in object || \"outputColorSpace\" in object;\n/**\n * The current THREE.ColorManagement instance, if present.\n */ const getColorManagement = ()=>{\n    var _ColorManagement;\n    return (_ColorManagement = catalogue.ColorManagement) != null ? _ColorManagement : null;\n};\nconst isOrthographicCamera = (def)=>def && def.isOrthographicCamera;\nconst isRef = (obj)=>obj && obj.hasOwnProperty(\"current\");\n/**\n * An SSR-friendly useLayoutEffect.\n *\n * React currently throws a warning when using useLayoutEffect on the server.\n * To get around it, we can conditionally useEffect on the server (no-op) and\n * useLayoutEffect elsewhere.\n *\n * @see https://github.com/facebook/react/issues/14927\n */ const useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useMutableCallback(fn) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(fn);\n    useIsomorphicLayoutEffect(()=>void (ref.current = fn), [\n        fn\n    ]);\n    return ref;\n}\nfunction Block({ set }) {\n    useIsomorphicLayoutEffect(()=>{\n        set(new Promise(()=>null));\n        return ()=>set(false);\n    }, [\n        set\n    ]);\n    return null;\n}\nclass ErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(...args){\n        super(...args);\n        this.state = {\n            error: false\n        };\n    }\n    componentDidCatch(err) {\n        this.props.set(err);\n    }\n    render() {\n        return this.state.error ? null : this.props.children;\n    }\n}\nErrorBoundary.getDerivedStateFromError = ()=>({\n        error: true\n    });\nconst DEFAULT = \"__default\";\nconst DEFAULTS = new Map();\nconst isDiffSet = (def)=>def && !!def.memoized && !!def.changes;\nfunction calculateDpr(dpr) {\n    var _window$devicePixelRa;\n    // Err on the side of progress by assuming 2x dpr if we can't detect it\n    // This will happen in workers where window is defined but dpr isn't.\n    const target =  false ? 0 : 1;\n    return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], target), dpr[1]) : dpr;\n}\n/**\n * Returns instance root state\n */ const getRootState = (obj)=>{\n    var _r3f;\n    return (_r3f = obj.__r3f) == null ? void 0 : _r3f.root.getState();\n};\n/**\n * Returns the instances initial (outmost) root\n */ function findInitialRoot(child) {\n    let root = child.__r3f.root;\n    while(root.getState().previousRoot)root = root.getState().previousRoot;\n    return root;\n}\n// A collection of compare functions\nconst is = {\n    obj: (a)=>a === Object(a) && !is.arr(a) && typeof a !== \"function\",\n    fun: (a)=>typeof a === \"function\",\n    str: (a)=>typeof a === \"string\",\n    num: (a)=>typeof a === \"number\",\n    boo: (a)=>typeof a === \"boolean\",\n    und: (a)=>a === void 0,\n    arr: (a)=>Array.isArray(a),\n    equ (a, b, { arrays = \"shallow\", objects = \"reference\", strict = true } = {}) {\n        // Wrong type or one of the two undefined, doesn't match\n        if (typeof a !== typeof b || !!a !== !!b) return false;\n        // Atomic, just compare a against b\n        if (is.str(a) || is.num(a)) return a === b;\n        const isObj = is.obj(a);\n        if (isObj && objects === \"reference\") return a === b;\n        const isArr = is.arr(a);\n        if (isArr && arrays === \"reference\") return a === b;\n        // Array or Object, shallow compare first to see if it's a match\n        if ((isArr || isObj) && a === b) return true;\n        // Last resort, go through keys\n        let i;\n        // Check if a has all the keys of b\n        for(i in a)if (!(i in b)) return false;\n        // Check if values between keys match\n        if (isObj && arrays === \"shallow\" && objects === \"shallow\") {\n            for(i in strict ? b : a)if (!is.equ(a[i], b[i], {\n                strict,\n                objects: \"reference\"\n            })) return false;\n        } else {\n            for(i in strict ? b : a)if (a[i] !== b[i]) return false;\n        }\n        // If i is undefined\n        if (is.und(i)) {\n            // If both arrays are empty we consider them equal\n            if (isArr && a.length === 0 && b.length === 0) return true;\n            // If both objects are empty we consider them equal\n            if (isObj && Object.keys(a).length === 0 && Object.keys(b).length === 0) return true;\n            // Otherwise match them by value\n            if (a !== b) return false;\n        }\n        return true;\n    }\n};\n/**\n * Collects nodes and materials from a THREE.Object3D.\n */ function buildGraph(object) {\n    const data = {\n        nodes: {},\n        materials: {}\n    };\n    if (object) {\n        object.traverse((obj)=>{\n            if (obj.name) data.nodes[obj.name] = obj;\n            if (obj.material && !data.materials[obj.material.name]) data.materials[obj.material.name] = obj.material;\n        });\n    }\n    return data;\n}\n// Disposes an object and all its properties\nfunction dispose(obj) {\n    if (obj.dispose && obj.type !== \"Scene\") obj.dispose();\n    for(const p in obj){\n        p.dispose == null ? void 0 : p.dispose();\n        delete obj[p];\n    }\n}\n// Each object in the scene carries a small LocalState descriptor\nfunction prepare(object, state) {\n    const instance = object;\n    instance.__r3f = {\n        type: \"\",\n        root: null,\n        previousAttach: null,\n        memoizedProps: {},\n        eventCount: 0,\n        handlers: {},\n        objects: [],\n        parent: null,\n        ...state\n    };\n    return object;\n}\nfunction resolve(instance, key) {\n    let target = instance;\n    if (key.includes(\"-\")) {\n        const entries = key.split(\"-\");\n        const last = entries.pop();\n        target = entries.reduce((acc, key)=>acc[key], instance);\n        return {\n            target,\n            key: last\n        };\n    } else return {\n        target,\n        key\n    };\n}\n// Checks if a dash-cased string ends with an integer\nconst INDEX_REGEX = /-\\d+$/;\nfunction attach(parent, child, type) {\n    if (is.str(type)) {\n        // If attaching into an array (foo-0), create one\n        if (INDEX_REGEX.test(type)) {\n            const root = type.replace(INDEX_REGEX, \"\");\n            const { target, key } = resolve(parent, root);\n            if (!Array.isArray(target[key])) target[key] = [];\n        }\n        const { target, key } = resolve(parent, type);\n        child.__r3f.previousAttach = target[key];\n        target[key] = child;\n    } else child.__r3f.previousAttach = type(parent, child);\n}\nfunction detach(parent, child, type) {\n    var _child$__r3f, _child$__r3f2;\n    if (is.str(type)) {\n        const { target, key } = resolve(parent, type);\n        const previous = child.__r3f.previousAttach;\n        // When the previous value was undefined, it means the value was never set to begin with\n        if (previous === undefined) delete target[key];\n        else target[key] = previous;\n    } else (_child$__r3f = child.__r3f) == null ? void 0 : _child$__r3f.previousAttach == null ? void 0 : _child$__r3f.previousAttach(parent, child);\n    (_child$__r3f2 = child.__r3f) == null ? true : delete _child$__r3f2.previousAttach;\n}\n// This function prepares a set of changes to be applied to the instance\nfunction diffProps(instance, { children: cN, key: kN, ref: rN, ...props }, { children: cP, key: kP, ref: rP, ...previous } = {}, remove = false) {\n    var _instance$__r3f;\n    const localState = (_instance$__r3f = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f : {};\n    const entries = Object.entries(props);\n    const changes = [];\n    // Catch removed props, prepend them so they can be reset or removed\n    if (remove) {\n        const previousKeys = Object.keys(previous);\n        for(let i = 0; i < previousKeys.length; i++){\n            if (!props.hasOwnProperty(previousKeys[i])) entries.unshift([\n                previousKeys[i],\n                DEFAULT + \"remove\"\n            ]);\n        }\n    }\n    entries.forEach(([key, value])=>{\n        var _instance$__r3f2;\n        // Bail out on primitive object\n        if ((_instance$__r3f2 = instance.__r3f) != null && _instance$__r3f2.primitive && key === \"object\") return;\n        // When props match bail out\n        if (is.equ(value, previous[key])) return;\n        // Collect handlers and bail out\n        if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(key)) return changes.push([\n            key,\n            value,\n            true,\n            []\n        ]);\n        // Split dashed props\n        let entries = [];\n        if (key.includes(\"-\")) entries = key.split(\"-\");\n        changes.push([\n            key,\n            value,\n            false,\n            entries\n        ]);\n        // Reset pierced props\n        for(const prop in props){\n            const value = props[prop];\n            if (prop.startsWith(`${key}-`)) changes.push([\n                prop,\n                value,\n                false,\n                prop.split(\"-\")\n            ]);\n        }\n    });\n    const memoized = {\n        ...props\n    };\n    if (localState.memoizedProps && localState.memoizedProps.args) memoized.args = localState.memoizedProps.args;\n    if (localState.memoizedProps && localState.memoizedProps.attach) memoized.attach = localState.memoizedProps.attach;\n    return {\n        memoized,\n        changes\n    };\n}\nconst __DEV__ = typeof process !== \"undefined\" && \"development\" !== \"production\";\n// This function applies a set of changes to the instance\nfunction applyProps$1(instance, data) {\n    var _instance$__r3f3, _root$getState, _instance$__r3f4;\n    // Filter equals, events and reserved props\n    const localState = (_instance$__r3f3 = instance.__r3f) != null ? _instance$__r3f3 : {};\n    const root = localState.root;\n    const rootState = (_root$getState = root == null ? void 0 : root.getState == null ? void 0 : root.getState()) != null ? _root$getState : {};\n    const { memoized, changes } = isDiffSet(data) ? data : diffProps(instance, data);\n    const prevHandlers = localState.eventCount;\n    // Prepare memoized props\n    if (instance.__r3f) instance.__r3f.memoizedProps = memoized;\n    for(let i = 0; i < changes.length; i++){\n        let [key, value, isEvent, keys] = changes[i];\n        // Alias (output)encoding => (output)colorSpace (since r152)\n        // https://github.com/pmndrs/react-three-fiber/pull/2829\n        if (hasColorSpace(instance)) {\n            const sRGBEncoding = 3001;\n            const SRGBColorSpace = \"srgb\";\n            const LinearSRGBColorSpace = \"srgb-linear\";\n            if (key === \"encoding\") {\n                key = \"colorSpace\";\n                value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n            } else if (key === \"outputEncoding\") {\n                key = \"outputColorSpace\";\n                value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n            }\n        }\n        let currentInstance = instance;\n        let targetProp = currentInstance[key];\n        // Revolve dashed props\n        if (keys.length) {\n            targetProp = keys.reduce((acc, key)=>acc[key], instance);\n            // If the target is atomic, it forces us to switch the root\n            if (!(targetProp && targetProp.set)) {\n                const [name, ...reverseEntries] = keys.reverse();\n                currentInstance = reverseEntries.reverse().reduce((acc, key)=>acc[key], instance);\n                key = name;\n            }\n        }\n        // https://github.com/mrdoob/three.js/issues/21209\n        // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n        // has no means to do this. Hence we curate a small collection of value-classes\n        // with their respective constructor/set arguments\n        // For removed props, try to set default values, if possible\n        if (value === DEFAULT + \"remove\") {\n            if (currentInstance.constructor) {\n                // create a blank slate of the instance and copy the particular parameter.\n                let ctor = DEFAULTS.get(currentInstance.constructor);\n                if (!ctor) {\n                    // @ts-ignore\n                    ctor = new currentInstance.constructor();\n                    DEFAULTS.set(currentInstance.constructor, ctor);\n                }\n                value = ctor[key];\n            } else {\n                // instance does not have constructor, just set it to 0\n                value = 0;\n            }\n        }\n        // Deal with pointer events ...\n        if (isEvent) {\n            if (value) localState.handlers[key] = value;\n            else delete localState.handlers[key];\n            localState.eventCount = Object.keys(localState.handlers).length;\n        } else if (targetProp && targetProp.set && (targetProp.copy || targetProp instanceof three__WEBPACK_IMPORTED_MODULE_4__.Layers)) {\n            // If value is an array\n            if (Array.isArray(value)) {\n                if (targetProp.fromArray) targetProp.fromArray(value);\n                else targetProp.set(...value);\n            } else if (targetProp.copy && value && value.constructor && // Some environments may break strict identity checks by duplicating versions of three.js.\n            // Loosen to unminified names, ignoring descendents.\n            // https://github.com/pmndrs/react-three-fiber/issues/2856\n            // TODO: fix upstream and remove in v9\n            (__DEV__ ? targetProp.constructor.name === value.constructor.name : targetProp.constructor === value.constructor)) {\n                targetProp.copy(value);\n            } else if (value !== undefined) {\n                const isColor = targetProp instanceof three__WEBPACK_IMPORTED_MODULE_4__.Color;\n                // Allow setting array scalars\n                if (!isColor && targetProp.setScalar) targetProp.setScalar(value);\n                else if (targetProp instanceof three__WEBPACK_IMPORTED_MODULE_4__.Layers && value instanceof three__WEBPACK_IMPORTED_MODULE_4__.Layers) targetProp.mask = value.mask;\n                else targetProp.set(value);\n                // For versions of three which don't support THREE.ColorManagement,\n                // Auto-convert sRGB colors\n                // https://github.com/pmndrs/react-three-fiber/issues/344\n                if (!getColorManagement() && !rootState.linear && isColor) targetProp.convertSRGBToLinear();\n            }\n        // Else, just overwrite the value\n        } else {\n            currentInstance[key] = value;\n            // Auto-convert sRGB textures, for now ...\n            // https://github.com/pmndrs/react-three-fiber/issues/344\n            if (currentInstance[key] instanceof three__WEBPACK_IMPORTED_MODULE_4__.Texture && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129\n            currentInstance[key].format === three__WEBPACK_IMPORTED_MODULE_4__.RGBAFormat && currentInstance[key].type === three__WEBPACK_IMPORTED_MODULE_4__.UnsignedByteType) {\n                const texture = currentInstance[key];\n                if (hasColorSpace(texture) && hasColorSpace(rootState.gl)) texture.colorSpace = rootState.gl.outputColorSpace;\n                else texture.encoding = rootState.gl.outputEncoding;\n            }\n        }\n        invalidateInstance(instance);\n    }\n    if (localState.parent && instance.raycast && prevHandlers !== localState.eventCount) {\n        // Get the initial root state's internals\n        const internal = findInitialRoot(instance).getState().internal;\n        // Pre-emptively remove the instance from the interaction manager\n        const index = internal.interaction.indexOf(instance);\n        if (index > -1) internal.interaction.splice(index, 1);\n        // Add the instance to the interaction manager only when it has handlers\n        if (localState.eventCount) internal.interaction.push(instance);\n    }\n    // Call the update lifecycle when it is being updated, but only when it is part of the scene.\n    // Skip updates to the `onUpdate` prop itself\n    const isCircular = changes.length === 1 && changes[0][0] === \"onUpdate\";\n    if (!isCircular && changes.length && (_instance$__r3f4 = instance.__r3f) != null && _instance$__r3f4.parent) updateInstance(instance);\n    return instance;\n}\nfunction invalidateInstance(instance) {\n    var _instance$__r3f5, _instance$__r3f5$root;\n    const state = (_instance$__r3f5 = instance.__r3f) == null ? void 0 : (_instance$__r3f5$root = _instance$__r3f5.root) == null ? void 0 : _instance$__r3f5$root.getState == null ? void 0 : _instance$__r3f5$root.getState();\n    if (state && state.internal.frames === 0) state.invalidate();\n}\nfunction updateInstance(instance) {\n    instance.onUpdate == null ? void 0 : instance.onUpdate(instance);\n}\nfunction updateCamera(camera, size) {\n    // https://github.com/pmndrs/react-three-fiber/issues/92\n    // Do not mess with the camera if it belongs to the user\n    if (!camera.manual) {\n        if (isOrthographicCamera(camera)) {\n            camera.left = size.width / -2;\n            camera.right = size.width / 2;\n            camera.top = size.height / 2;\n            camera.bottom = size.height / -2;\n        } else {\n            camera.aspect = size.width / size.height;\n        }\n        camera.updateProjectionMatrix();\n        // https://github.com/pmndrs/react-three-fiber/issues/178\n        // Update matrix world since the renderer is a frame late\n        camera.updateMatrixWorld();\n    }\n}\nfunction makeId(event) {\n    return (event.eventObject || event.object).uuid + \"/\" + event.index + event.instanceId;\n}\n// https://github.com/facebook/react/tree/main/packages/react-reconciler#getcurrenteventpriority\n// Gives React a clue as to how import the current interaction is\nfunction getEventPriority() {\n    var _globalScope$event;\n    // Get a handle to the current global scope in window and worker contexts if able\n    // https://github.com/pmndrs/react-three-fiber/pull/2493\n    const globalScope = typeof self !== \"undefined\" && self ||  false && 0;\n    if (!globalScope) return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n    const name = (_globalScope$event = globalScope.event) == null ? void 0 : _globalScope$event.type;\n    switch(name){\n        case \"click\":\n        case \"contextmenu\":\n        case \"dblclick\":\n        case \"pointercancel\":\n        case \"pointerdown\":\n        case \"pointerup\":\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DiscreteEventPriority;\n        case \"pointermove\":\n        case \"pointerout\":\n        case \"pointerover\":\n        case \"pointerenter\":\n        case \"pointerleave\":\n        case \"wheel\":\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ContinuousEventPriority;\n        default:\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n    }\n}\n/**\n * Release pointer captures.\n * This is called by releasePointerCapture in the API, and when an object is removed.\n */ function releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {\n    const captureData = captures.get(obj);\n    if (captureData) {\n        captures.delete(obj);\n        // If this was the last capturing object for this pointer\n        if (captures.size === 0) {\n            capturedMap.delete(pointerId);\n            captureData.target.releasePointerCapture(pointerId);\n        }\n    }\n}\nfunction removeInteractivity(store, object) {\n    const { internal } = store.getState();\n    // Removes every trace of an object from the data store\n    internal.interaction = internal.interaction.filter((o)=>o !== object);\n    internal.initialHits = internal.initialHits.filter((o)=>o !== object);\n    internal.hovered.forEach((value, key)=>{\n        if (value.eventObject === object || value.object === object) {\n            // Clear out intersects, they are outdated by now\n            internal.hovered.delete(key);\n        }\n    });\n    internal.capturedMap.forEach((captures, pointerId)=>{\n        releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);\n    });\n}\nfunction createEvents(store) {\n    /** Calculates delta */ function calculateDistance(event) {\n        const { internal } = store.getState();\n        const dx = event.offsetX - internal.initialClick[0];\n        const dy = event.offsetY - internal.initialClick[1];\n        return Math.round(Math.sqrt(dx * dx + dy * dy));\n    }\n    /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */ function filterPointerEvents(objects) {\n        return objects.filter((obj)=>[\n                \"Move\",\n                \"Over\",\n                \"Enter\",\n                \"Out\",\n                \"Leave\"\n            ].some((name)=>{\n                var _r3f;\n                return (_r3f = obj.__r3f) == null ? void 0 : _r3f.handlers[\"onPointer\" + name];\n            }));\n    }\n    function intersect(event, filter) {\n        const state = store.getState();\n        const duplicates = new Set();\n        const intersections = [];\n        // Allow callers to eliminate event objects\n        const eventsObjects = filter ? filter(state.internal.interaction) : state.internal.interaction;\n        // Reset all raycaster cameras to undefined\n        for(let i = 0; i < eventsObjects.length; i++){\n            const state = getRootState(eventsObjects[i]);\n            if (state) {\n                state.raycaster.camera = undefined;\n            }\n        }\n        if (!state.previousRoot) {\n            // Make sure root-level pointer and ray are set up\n            state.events.compute == null ? void 0 : state.events.compute(event, state);\n        }\n        function handleRaycast(obj) {\n            const state = getRootState(obj);\n            // Skip event handling when noEvents is set, or when the raycasters camera is null\n            if (!state || !state.events.enabled || state.raycaster.camera === null) return [];\n            // When the camera is undefined we have to call the event layers update function\n            if (state.raycaster.camera === undefined) {\n                var _state$previousRoot;\n                state.events.compute == null ? void 0 : state.events.compute(event, state, (_state$previousRoot = state.previousRoot) == null ? void 0 : _state$previousRoot.getState());\n                // If the camera is still undefined we have to skip this layer entirely\n                if (state.raycaster.camera === undefined) state.raycaster.camera = null;\n            }\n            // Intersect object by object\n            return state.raycaster.camera ? state.raycaster.intersectObject(obj, true) : [];\n        }\n        // Collect events\n        let hits = eventsObjects// Intersect objects\n        .flatMap(handleRaycast)// Sort by event priority and distance\n        .sort((a, b)=>{\n            const aState = getRootState(a.object);\n            const bState = getRootState(b.object);\n            if (!aState || !bState) return a.distance - b.distance;\n            return bState.events.priority - aState.events.priority || a.distance - b.distance;\n        })// Filter out duplicates\n        .filter((item)=>{\n            const id = makeId(item);\n            if (duplicates.has(id)) return false;\n            duplicates.add(id);\n            return true;\n        });\n        // https://github.com/mrdoob/three.js/issues/16031\n        // Allow custom userland intersect sort order, this likely only makes sense on the root filter\n        if (state.events.filter) hits = state.events.filter(hits, state);\n        // Bubble up the events, find the event source (eventObject)\n        for (const hit of hits){\n            let eventObject = hit.object;\n            // Bubble event up\n            while(eventObject){\n                var _r3f2;\n                if ((_r3f2 = eventObject.__r3f) != null && _r3f2.eventCount) intersections.push({\n                    ...hit,\n                    eventObject\n                });\n                eventObject = eventObject.parent;\n            }\n        }\n        // If the interaction is captured, make all capturing targets part of the intersect.\n        if (\"pointerId\" in event && state.internal.capturedMap.has(event.pointerId)) {\n            for (let captureData of state.internal.capturedMap.get(event.pointerId).values()){\n                if (!duplicates.has(makeId(captureData.intersection))) intersections.push(captureData.intersection);\n            }\n        }\n        return intersections;\n    }\n    /**  Handles intersections by forwarding them to handlers */ function handleIntersects(intersections, event, delta, callback) {\n        const rootState = store.getState();\n        // If anything has been found, forward it to the event listeners\n        if (intersections.length) {\n            const localState = {\n                stopped: false\n            };\n            for (const hit of intersections){\n                const state = getRootState(hit.object) || rootState;\n                const { raycaster, pointer, camera, internal } = state;\n                const unprojectedPoint = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(pointer.x, pointer.y, 0).unproject(camera);\n                const hasPointerCapture = (id)=>{\n                    var _internal$capturedMap, _internal$capturedMap2;\n                    return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\n                };\n                const setPointerCapture = (id)=>{\n                    const captureData = {\n                        intersection: hit,\n                        target: event.target\n                    };\n                    if (internal.capturedMap.has(id)) {\n                        // if the pointerId was previously captured, we add the hit to the\n                        // event capturedMap.\n                        internal.capturedMap.get(id).set(hit.eventObject, captureData);\n                    } else {\n                        // if the pointerId was not previously captured, we create a map\n                        // containing the hitObject, and the hit. hitObject is used for\n                        // faster access.\n                        internal.capturedMap.set(id, new Map([\n                            [\n                                hit.eventObject,\n                                captureData\n                            ]\n                        ]));\n                    }\n                    event.target.setPointerCapture(id);\n                };\n                const releasePointerCapture = (id)=>{\n                    const captures = internal.capturedMap.get(id);\n                    if (captures) {\n                        releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);\n                    }\n                };\n                // Add native event props\n                let extractEventProps = {};\n                // This iterates over the event's properties including the inherited ones. Native PointerEvents have most of their props as getters which are inherited, but polyfilled PointerEvents have them all as their own properties (i.e. not inherited). We can't use Object.keys() or Object.entries() as they only return \"own\" properties; nor Object.getPrototypeOf(event) as that *doesn't* return \"own\" properties, only inherited ones.\n                for(let prop in event){\n                    let property = event[prop];\n                    // Only copy over atomics, leave functions alone as these should be\n                    // called as event.nativeEvent.fn()\n                    if (typeof property !== \"function\") extractEventProps[prop] = property;\n                }\n                let raycastEvent = {\n                    ...hit,\n                    ...extractEventProps,\n                    pointer,\n                    intersections,\n                    stopped: localState.stopped,\n                    delta,\n                    unprojectedPoint,\n                    ray: raycaster.ray,\n                    camera: camera,\n                    // Hijack stopPropagation, which just sets a flag\n                    stopPropagation () {\n                        // https://github.com/pmndrs/react-three-fiber/issues/596\n                        // Events are not allowed to stop propagation if the pointer has been captured\n                        const capturesForPointer = \"pointerId\" in event && internal.capturedMap.get(event.pointerId);\n                        // We only authorize stopPropagation...\n                        if (// ...if this pointer hasn't been captured\n                        !capturesForPointer || // ... or if the hit object is capturing the pointer\n                        capturesForPointer.has(hit.eventObject)) {\n                            raycastEvent.stopped = localState.stopped = true;\n                            // Propagation is stopped, remove all other hover records\n                            // An event handler is only allowed to flush other handlers if it is hovered itself\n                            if (internal.hovered.size && Array.from(internal.hovered.values()).find((i)=>i.eventObject === hit.eventObject)) {\n                                // Objects cannot flush out higher up objects that have already caught the event\n                                const higher = intersections.slice(0, intersections.indexOf(hit));\n                                cancelPointer([\n                                    ...higher,\n                                    hit\n                                ]);\n                            }\n                        }\n                    },\n                    // there should be a distinction between target and currentTarget\n                    target: {\n                        hasPointerCapture,\n                        setPointerCapture,\n                        releasePointerCapture\n                    },\n                    currentTarget: {\n                        hasPointerCapture,\n                        setPointerCapture,\n                        releasePointerCapture\n                    },\n                    nativeEvent: event\n                };\n                // Call subscribers\n                callback(raycastEvent);\n                // Event bubbling may be interrupted by stopPropagation\n                if (localState.stopped === true) break;\n            }\n        }\n        return intersections;\n    }\n    function cancelPointer(intersections) {\n        const { internal } = store.getState();\n        for (const hoveredObj of internal.hovered.values()){\n            // When no objects were hit or the the hovered object wasn't found underneath the cursor\n            // we call onPointerOut and delete the object from the hovered-elements map\n            if (!intersections.length || !intersections.find((hit)=>hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId)) {\n                const eventObject = hoveredObj.eventObject;\n                const instance = eventObject.__r3f;\n                const handlers = instance == null ? void 0 : instance.handlers;\n                internal.hovered.delete(makeId(hoveredObj));\n                if (instance != null && instance.eventCount) {\n                    // Clear out intersects, they are outdated by now\n                    const data = {\n                        ...hoveredObj,\n                        intersections\n                    };\n                    handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\n                    handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\n                }\n            }\n        }\n    }\n    function pointerMissed(event, objects) {\n        for(let i = 0; i < objects.length; i++){\n            const instance = objects[i].__r3f;\n            instance == null ? void 0 : instance.handlers.onPointerMissed == null ? void 0 : instance.handlers.onPointerMissed(event);\n        }\n    }\n    function handlePointer(name) {\n        // Deal with cancelation\n        switch(name){\n            case \"onPointerLeave\":\n            case \"onPointerCancel\":\n                return ()=>cancelPointer([]);\n            case \"onLostPointerCapture\":\n                return (event)=>{\n                    const { internal } = store.getState();\n                    if (\"pointerId\" in event && internal.capturedMap.has(event.pointerId)) {\n                        // If the object event interface had onLostPointerCapture, we'd call it here on every\n                        // object that's getting removed. We call it on the next frame because onLostPointerCapture\n                        // fires before onPointerUp. Otherwise pointerUp would never be called if the event didn't\n                        // happen in the object it originated from, leaving components in a in-between state.\n                        requestAnimationFrame(()=>{\n                            // Only release if pointer-up didn't do it already\n                            if (internal.capturedMap.has(event.pointerId)) {\n                                internal.capturedMap.delete(event.pointerId);\n                                cancelPointer([]);\n                            }\n                        });\n                    }\n                };\n        }\n        // Any other pointer goes here ...\n        return function handleEvent(event) {\n            const { onPointerMissed, internal } = store.getState();\n            // prepareRay(event)\n            internal.lastEvent.current = event;\n            // Get fresh intersects\n            const isPointerMove = name === \"onPointerMove\";\n            const isClickEvent = name === \"onClick\" || name === \"onContextMenu\" || name === \"onDoubleClick\";\n            const filter = isPointerMove ? filterPointerEvents : undefined;\n            const hits = intersect(event, filter);\n            const delta = isClickEvent ? calculateDistance(event) : 0;\n            // Save initial coordinates on pointer-down\n            if (name === \"onPointerDown\") {\n                internal.initialClick = [\n                    event.offsetX,\n                    event.offsetY\n                ];\n                internal.initialHits = hits.map((hit)=>hit.eventObject);\n            }\n            // If a click yields no results, pass it back to the user as a miss\n            // Missed events have to come first in order to establish user-land side-effect clean up\n            if (isClickEvent && !hits.length) {\n                if (delta <= 2) {\n                    pointerMissed(event, internal.interaction);\n                    if (onPointerMissed) onPointerMissed(event);\n                }\n            }\n            // Take care of unhover\n            if (isPointerMove) cancelPointer(hits);\n            function onIntersect(data) {\n                const eventObject = data.eventObject;\n                const instance = eventObject.__r3f;\n                const handlers = instance == null ? void 0 : instance.handlers;\n                // Check presence of handlers\n                if (!(instance != null && instance.eventCount)) return;\n                /*\n        MAYBE TODO, DELETE IF NOT: \n          Check if the object is captured, captured events should not have intersects running in parallel\n          But wouldn't it be better to just replace capturedMap with a single entry?\n          Also, are we OK with straight up making picking up multiple objects impossible?\n          \n        const pointerId = (data as ThreeEvent<PointerEvent>).pointerId        \n        if (pointerId !== undefined) {\n          const capturedMeshSet = internal.capturedMap.get(pointerId)\n          if (capturedMeshSet) {\n            const captured = capturedMeshSet.get(eventObject)\n            if (captured && captured.localState.stopped) return\n          }\n        }*/ if (isPointerMove) {\n                    // Move event ...\n                    if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n                        // When enter or out is present take care of hover-state\n                        const id = makeId(data);\n                        const hoveredItem = internal.hovered.get(id);\n                        if (!hoveredItem) {\n                            // If the object wasn't previously hovered, book it and call its handler\n                            internal.hovered.set(id, data);\n                            handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\n                            handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\n                        } else if (hoveredItem.stopped) {\n                            // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n                            data.stopPropagation();\n                        }\n                    }\n                    // Call mouse move\n                    handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\n                } else {\n                    // All other events ...\n                    const handler = handlers[name];\n                    if (handler) {\n                        // Forward all events back to their respective handlers with the exception of click events,\n                        // which must use the initial target\n                        if (!isClickEvent || internal.initialHits.includes(eventObject)) {\n                            // Missed events have to come first\n                            pointerMissed(event, internal.interaction.filter((object)=>!internal.initialHits.includes(object)));\n                            // Now call the handler\n                            handler(data);\n                        }\n                    } else {\n                        // Trigger onPointerMissed on all elements that have pointer over/out handlers, but not click and weren't hit\n                        if (isClickEvent && internal.initialHits.includes(eventObject)) {\n                            pointerMissed(event, internal.interaction.filter((object)=>!internal.initialHits.includes(object)));\n                        }\n                    }\n                }\n            }\n            handleIntersects(hits, event, delta, onIntersect);\n        };\n    }\n    return {\n        handlePointer\n    };\n}\n// Keys that shouldn't be copied between R3F stores\nconst privateKeys = [\n    \"set\",\n    \"get\",\n    \"setSize\",\n    \"setFrameloop\",\n    \"setDpr\",\n    \"events\",\n    \"invalidate\",\n    \"advance\",\n    \"size\",\n    \"viewport\"\n];\nconst isRenderer = (def)=>!!(def != null && def.render);\nconst context = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst createStore = (invalidate, advance)=>{\n    const rootState = (0,zustand__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((set, get)=>{\n        const position = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3();\n        const defaultTarget = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3();\n        const tempTarget = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3();\n        function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\n            const { width, height, top, left } = size;\n            const aspect = width / height;\n            if (target instanceof three__WEBPACK_IMPORTED_MODULE_4__.Vector3) tempTarget.copy(target);\n            else tempTarget.set(...target);\n            const distance = camera.getWorldPosition(position).distanceTo(tempTarget);\n            if (isOrthographicCamera(camera)) {\n                return {\n                    width: width / camera.zoom,\n                    height: height / camera.zoom,\n                    top,\n                    left,\n                    factor: 1,\n                    distance,\n                    aspect\n                };\n            } else {\n                const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n                const h = 2 * Math.tan(fov / 2) * distance; // visible height\n                const w = h * (width / height);\n                return {\n                    width: w,\n                    height: h,\n                    top,\n                    left,\n                    factor: width / w,\n                    distance,\n                    aspect\n                };\n            }\n        }\n        let performanceTimeout = undefined;\n        const setPerformanceCurrent = (current)=>set((state)=>({\n                    performance: {\n                        ...state.performance,\n                        current\n                    }\n                }));\n        const pointer = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2();\n        const rootState = {\n            set,\n            get,\n            // Mock objects that have to be configured\n            gl: null,\n            camera: null,\n            raycaster: null,\n            events: {\n                priority: 1,\n                enabled: true,\n                connected: false\n            },\n            xr: null,\n            scene: null,\n            invalidate: (frames = 1)=>invalidate(get(), frames),\n            advance: (timestamp, runGlobalEffects)=>advance(timestamp, runGlobalEffects, get()),\n            legacy: false,\n            linear: false,\n            flat: false,\n            controls: null,\n            clock: new three__WEBPACK_IMPORTED_MODULE_4__.Clock(),\n            pointer,\n            mouse: pointer,\n            frameloop: \"always\",\n            onPointerMissed: undefined,\n            performance: {\n                current: 1,\n                min: 0.5,\n                max: 1,\n                debounce: 200,\n                regress: ()=>{\n                    const state = get();\n                    // Clear timeout\n                    if (performanceTimeout) clearTimeout(performanceTimeout);\n                    // Set lower bound performance\n                    if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min);\n                    // Go back to upper bound performance after a while unless something regresses meanwhile\n                    performanceTimeout = setTimeout(()=>setPerformanceCurrent(get().performance.max), state.performance.debounce);\n                }\n            },\n            size: {\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0,\n                updateStyle: false\n            },\n            viewport: {\n                initialDpr: 0,\n                dpr: 0,\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0,\n                aspect: 0,\n                distance: 0,\n                factor: 0,\n                getCurrentViewport\n            },\n            setEvents: (events)=>set((state)=>({\n                        ...state,\n                        events: {\n                            ...state.events,\n                            ...events\n                        }\n                    })),\n            setSize: (width, height, updateStyle, top, left)=>{\n                const camera = get().camera;\n                const size = {\n                    width,\n                    height,\n                    top: top || 0,\n                    left: left || 0,\n                    updateStyle\n                };\n                set((state)=>({\n                        size,\n                        viewport: {\n                            ...state.viewport,\n                            ...getCurrentViewport(camera, defaultTarget, size)\n                        }\n                    }));\n            },\n            setDpr: (dpr)=>set((state)=>{\n                    const resolved = calculateDpr(dpr);\n                    return {\n                        viewport: {\n                            ...state.viewport,\n                            dpr: resolved,\n                            initialDpr: state.viewport.initialDpr || resolved\n                        }\n                    };\n                }),\n            setFrameloop: (frameloop = \"always\")=>{\n                const clock = get().clock;\n                // if frameloop === \"never\" clock.elapsedTime is updated using advance(timestamp)\n                clock.stop();\n                clock.elapsedTime = 0;\n                if (frameloop !== \"never\") {\n                    clock.start();\n                    clock.elapsedTime = 0;\n                }\n                set(()=>({\n                        frameloop\n                    }));\n            },\n            previousRoot: undefined,\n            internal: {\n                active: false,\n                priority: 0,\n                frames: 0,\n                lastEvent: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef(),\n                interaction: [],\n                hovered: new Map(),\n                subscribers: [],\n                initialClick: [\n                    0,\n                    0\n                ],\n                initialHits: [],\n                capturedMap: new Map(),\n                subscribe: (ref, priority, store)=>{\n                    const internal = get().internal;\n                    // If this subscription was given a priority, it takes rendering into its own hands\n                    // For that reason we switch off automatic rendering and increase the manual flag\n                    // As long as this flag is positive there can be no internal rendering at all\n                    // because there could be multiple render subscriptions\n                    internal.priority = internal.priority + (priority > 0 ? 1 : 0);\n                    internal.subscribers.push({\n                        ref,\n                        priority,\n                        store\n                    });\n                    // Register subscriber and sort layers from lowest to highest, meaning,\n                    // highest priority renders last (on top of the other frames)\n                    internal.subscribers = internal.subscribers.sort((a, b)=>a.priority - b.priority);\n                    return ()=>{\n                        const internal = get().internal;\n                        if (internal != null && internal.subscribers) {\n                            // Decrease manual flag if this subscription had a priority\n                            internal.priority = internal.priority - (priority > 0 ? 1 : 0);\n                            // Remove subscriber from list\n                            internal.subscribers = internal.subscribers.filter((s)=>s.ref !== ref);\n                        }\n                    };\n                }\n            }\n        };\n        return rootState;\n    });\n    const state = rootState.getState();\n    let oldSize = state.size;\n    let oldDpr = state.viewport.dpr;\n    let oldCamera = state.camera;\n    rootState.subscribe(()=>{\n        const { camera, size, viewport, gl, set } = rootState.getState();\n        // Resize camera and renderer on changes to size and pixelratio\n        if (size.width !== oldSize.width || size.height !== oldSize.height || viewport.dpr !== oldDpr) {\n            var _size$updateStyle;\n            oldSize = size;\n            oldDpr = viewport.dpr;\n            // Update camera & renderer\n            updateCamera(camera, size);\n            gl.setPixelRatio(viewport.dpr);\n            const updateStyle = (_size$updateStyle = size.updateStyle) != null ? _size$updateStyle : typeof HTMLCanvasElement !== \"undefined\" && gl.domElement instanceof HTMLCanvasElement;\n            gl.setSize(size.width, size.height, updateStyle);\n        }\n        // Update viewport once the camera changes\n        if (camera !== oldCamera) {\n            oldCamera = camera;\n            // Update viewport\n            set((state)=>({\n                    viewport: {\n                        ...state.viewport,\n                        ...state.viewport.getCurrentViewport(camera)\n                    }\n                }));\n        }\n    });\n    // Invalidate on any change\n    rootState.subscribe((state)=>invalidate(state));\n    // Return root state\n    return rootState;\n};\nfunction createSubs(callback, subs) {\n    const sub = {\n        callback\n    };\n    subs.add(sub);\n    return ()=>void subs.delete(sub);\n}\nlet i;\nlet globalEffects = new Set();\nlet globalAfterEffects = new Set();\nlet globalTailEffects = new Set();\n/**\n * Adds a global render callback which is called each frame.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addEffect\n */ const addEffect = (callback)=>createSubs(callback, globalEffects);\n/**\n * Adds a global after-render callback which is called each frame.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addAfterEffect\n */ const addAfterEffect = (callback)=>createSubs(callback, globalAfterEffects);\n/**\n * Adds a global callback which is called when rendering stops.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addTail\n */ const addTail = (callback)=>createSubs(callback, globalTailEffects);\nfunction run(effects, timestamp) {\n    if (!effects.size) return;\n    for (const { callback } of effects.values()){\n        callback(timestamp);\n    }\n}\nfunction flushGlobalEffects(type, timestamp) {\n    switch(type){\n        case \"before\":\n            return run(globalEffects, timestamp);\n        case \"after\":\n            return run(globalAfterEffects, timestamp);\n        case \"tail\":\n            return run(globalTailEffects, timestamp);\n    }\n}\nlet subscribers;\nlet subscription;\nfunction render$1(timestamp, state, frame) {\n    // Run local effects\n    let delta = state.clock.getDelta();\n    // In frameloop='never' mode, clock times are updated using the provided timestamp\n    if (state.frameloop === \"never\" && typeof timestamp === \"number\") {\n        delta = timestamp - state.clock.elapsedTime;\n        state.clock.oldTime = state.clock.elapsedTime;\n        state.clock.elapsedTime = timestamp;\n    }\n    // Call subscribers (useFrame)\n    subscribers = state.internal.subscribers;\n    for(i = 0; i < subscribers.length; i++){\n        subscription = subscribers[i];\n        subscription.ref.current(subscription.store.getState(), delta, frame);\n    }\n    // Render content\n    if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera);\n    // Decrease frame count\n    state.internal.frames = Math.max(0, state.internal.frames - 1);\n    return state.frameloop === \"always\" ? 1 : state.internal.frames;\n}\nfunction createLoop(roots) {\n    let running = false;\n    let repeat;\n    let frame;\n    let state;\n    function loop(timestamp) {\n        frame = requestAnimationFrame(loop);\n        running = true;\n        repeat = 0;\n        // Run effects\n        flushGlobalEffects(\"before\", timestamp);\n        // Render all roots\n        for (const root of roots.values()){\n            var _state$gl$xr;\n            state = root.store.getState();\n            // If the frameloop is invalidated, do not run another frame\n            if (state.internal.active && (state.frameloop === \"always\" || state.internal.frames > 0) && !((_state$gl$xr = state.gl.xr) != null && _state$gl$xr.isPresenting)) {\n                repeat += render$1(timestamp, state);\n            }\n        }\n        // Run after-effects\n        flushGlobalEffects(\"after\", timestamp);\n        // Stop the loop if nothing invalidates it\n        if (repeat === 0) {\n            // Tail call effects, they are called when rendering stops\n            flushGlobalEffects(\"tail\", timestamp);\n            // Flag end of operation\n            running = false;\n            return cancelAnimationFrame(frame);\n        }\n    }\n    function invalidate(state, frames = 1) {\n        var _state$gl$xr2;\n        if (!state) return roots.forEach((root)=>invalidate(root.store.getState()), frames);\n        if ((_state$gl$xr2 = state.gl.xr) != null && _state$gl$xr2.isPresenting || !state.internal.active || state.frameloop === \"never\") return;\n        // Increase frames, do not go higher than 60\n        state.internal.frames = Math.min(60, state.internal.frames + frames);\n        // If the render-loop isn't active, start it\n        if (!running) {\n            running = true;\n            requestAnimationFrame(loop);\n        }\n    }\n    function advance(timestamp, runGlobalEffects = true, state, frame) {\n        if (runGlobalEffects) flushGlobalEffects(\"before\", timestamp);\n        if (!state) for (const root of roots.values())render$1(timestamp, root.store.getState());\n        else render$1(timestamp, state, frame);\n        if (runGlobalEffects) flushGlobalEffects(\"after\", timestamp);\n    }\n    return {\n        loop,\n        /**\n     * Invalidates the view, requesting a frame to be rendered. Will globally invalidate unless passed a root's state.\n     * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#invalidate\n     */ invalidate,\n        /**\n     * Advances the frameloop and runs render effects, useful for when manually rendering via `frameloop=\"never\"`.\n     * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#advance\n     */ advance\n    };\n}\n/**\n * Exposes an object's {@link LocalState}.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#useInstanceHandle\n *\n * **Note**: this is an escape hatch to react-internal fields. Expect this to change significantly between versions.\n */ function useInstanceHandle(ref) {\n    const instance = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    useIsomorphicLayoutEffect(()=>void (instance.current = ref.current.__r3f), [\n        ref\n    ]);\n    return instance;\n}\nfunction useStore() {\n    const store = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if (!store) throw new Error(\"R3F: Hooks can only be used within the Canvas component!\");\n    return store;\n}\n/**\n * Accesses R3F's internal state, containing renderer, canvas, scene, etc.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usethree\n */ function useThree(selector = (state)=>state, equalityFn) {\n    return useStore()(selector, equalityFn);\n}\n/**\n * Executes a callback before render in a shared frame loop.\n * Can order effects with render priority or manually render with a positive priority.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useframe\n */ function useFrame(callback, renderPriority = 0) {\n    const store = useStore();\n    const subscribe = store.getState().internal.subscribe;\n    // Memoize ref\n    const ref = useMutableCallback(callback);\n    // Subscribe on mount, unsubscribe on unmount\n    useIsomorphicLayoutEffect(()=>subscribe(ref, renderPriority, store), [\n        renderPriority,\n        subscribe,\n        store\n    ]);\n    return null;\n}\n/**\n * Returns a node graph of an object with named nodes & materials.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usegraph\n */ function useGraph(object) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>buildGraph(object), [\n        object\n    ]);\n}\nconst memoizedLoaders = new WeakMap();\nfunction loadingFn(extensions, onProgress) {\n    return function(Proto, ...input) {\n        // Construct new loader and run extensions\n        let loader = memoizedLoaders.get(Proto);\n        if (!loader) {\n            loader = new Proto();\n            memoizedLoaders.set(Proto, loader);\n        }\n        if (extensions) extensions(loader);\n        // Go through the urls and load them\n        return Promise.all(input.map((input)=>new Promise((res, reject)=>loader.load(input, (data)=>{\n                    if (data.scene) Object.assign(data, buildGraph(data.scene));\n                    res(data);\n                }, onProgress, (error)=>reject(new Error(`Could not load ${input}: ${error == null ? void 0 : error.message}`)))))).finally(()=>loader.dispose == null ? void 0 : loader.dispose());\n    };\n}\n/**\n * Synchronously loads and caches assets with a three loader.\n *\n * Note: this hook's caller must be wrapped with `React.Suspense`\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useloader\n */ function useLoader(Proto, input, extensions, onProgress) {\n    // Use suspense to load async assets\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    const results = (0,suspend_react__WEBPACK_IMPORTED_MODULE_6__.suspend)(loadingFn(extensions, onProgress), [\n        Proto,\n        ...keys\n    ], {\n        equal: is.equ\n    });\n    // Return the object/s\n    return Array.isArray(input) ? results : results[0];\n}\n/**\n * Preloads an asset into cache as a side-effect.\n */ useLoader.preload = function(Proto, input, extensions) {\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    return (0,suspend_react__WEBPACK_IMPORTED_MODULE_6__.preload)(loadingFn(extensions), [\n        Proto,\n        ...keys\n    ]);\n};\n/**\n * Removes a loaded asset from cache.\n */ useLoader.clear = function(Proto, input) {\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    return (0,suspend_react__WEBPACK_IMPORTED_MODULE_6__.clear)([\n        Proto,\n        ...keys\n    ]);\n};\nconst roots = new Map();\nconst { invalidate, advance } = createLoop(roots);\nconst { reconciler, applyProps } = createRenderer(roots, getEventPriority);\nconst shallowLoose = {\n    objects: \"shallow\",\n    strict: false\n};\nconst createRendererInstance = (gl, canvas)=>{\n    const customRenderer = typeof gl === \"function\" ? gl(canvas) : gl;\n    if (isRenderer(customRenderer)) return customRenderer;\n    else return new three__WEBPACK_IMPORTED_MODULE_4__.WebGLRenderer({\n        powerPreference: \"high-performance\",\n        canvas: canvas,\n        antialias: true,\n        alpha: true,\n        ...gl\n    });\n};\nfunction computeInitialSize(canvas, defaultSize) {\n    const defaultStyle = typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement;\n    if (defaultSize) {\n        const { width, height, top, left, updateStyle = defaultStyle } = defaultSize;\n        return {\n            width,\n            height,\n            top,\n            left,\n            updateStyle\n        };\n    } else if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement && canvas.parentElement) {\n        const { width, height, top, left } = canvas.parentElement.getBoundingClientRect();\n        return {\n            width,\n            height,\n            top,\n            left,\n            updateStyle: defaultStyle\n        };\n    } else if (typeof OffscreenCanvas !== \"undefined\" && canvas instanceof OffscreenCanvas) {\n        return {\n            width: canvas.width,\n            height: canvas.height,\n            top: 0,\n            left: 0,\n            updateStyle: defaultStyle\n        };\n    }\n    return {\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0\n    };\n}\nfunction createRoot(canvas) {\n    // Check against mistaken use of createRoot\n    const prevRoot = roots.get(canvas);\n    const prevFiber = prevRoot == null ? void 0 : prevRoot.fiber;\n    const prevStore = prevRoot == null ? void 0 : prevRoot.store;\n    if (prevRoot) console.warn(\"R3F.createRoot should only be called once!\");\n    // Report when an error was detected in a previous render\n    // https://github.com/pmndrs/react-three-fiber/pull/2261\n    const logRecoverableError = typeof reportError === \"function\" ? // In modern browsers, reportError will dispatch an error event,\n    // emulating an uncaught JavaScript error.\n    reportError : // In older browsers and test environments, fallback to console.error.\n    console.error;\n    // Create store\n    const store = prevStore || createStore(invalidate, advance);\n    // Create renderer\n    const fiber = prevFiber || reconciler.createContainer(store, react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ConcurrentRoot, null, false, null, \"\", logRecoverableError, null);\n    // Map it\n    if (!prevRoot) roots.set(canvas, {\n        fiber,\n        store\n    });\n    // Locals\n    let onCreated;\n    let configured = false;\n    let lastCamera;\n    return {\n        configure (props = {}) {\n            let { gl: glConfig, size: propsSize, scene: sceneOptions, events, onCreated: onCreatedCallback, shadows = false, linear = false, flat = false, legacy = false, orthographic = false, frameloop = \"always\", dpr = [\n                1,\n                2\n            ], performance: performance1, raycaster: raycastOptions, camera: cameraOptions, onPointerMissed } = props;\n            let state = store.getState();\n            // Set up renderer (one time only!)\n            let gl = state.gl;\n            if (!state.gl) state.set({\n                gl: gl = createRendererInstance(glConfig, canvas)\n            });\n            // Set up raycaster (one time only!)\n            let raycaster = state.raycaster;\n            if (!raycaster) state.set({\n                raycaster: raycaster = new three__WEBPACK_IMPORTED_MODULE_4__.Raycaster()\n            });\n            // Set raycaster options\n            const { params, ...options } = raycastOptions || {};\n            if (!is.equ(options, raycaster, shallowLoose)) applyProps(raycaster, {\n                ...options\n            });\n            if (!is.equ(params, raycaster.params, shallowLoose)) applyProps(raycaster, {\n                params: {\n                    ...raycaster.params,\n                    ...params\n                }\n            });\n            // Create default camera, don't overwrite any user-set state\n            if (!state.camera || state.camera === lastCamera && !is.equ(lastCamera, cameraOptions, shallowLoose)) {\n                lastCamera = cameraOptions;\n                const isCamera = cameraOptions instanceof three__WEBPACK_IMPORTED_MODULE_4__.Camera;\n                const camera = isCamera ? cameraOptions : orthographic ? new three__WEBPACK_IMPORTED_MODULE_4__.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new three__WEBPACK_IMPORTED_MODULE_4__.PerspectiveCamera(75, 0, 0.1, 1000);\n                if (!isCamera) {\n                    camera.position.z = 5;\n                    if (cameraOptions) applyProps(camera, cameraOptions);\n                    // Always look at center by default\n                    if (!state.camera && !(cameraOptions != null && cameraOptions.rotation)) camera.lookAt(0, 0, 0);\n                }\n                state.set({\n                    camera\n                });\n                // Configure raycaster\n                // https://github.com/pmndrs/react-xr/issues/300\n                raycaster.camera = camera;\n            }\n            // Set up scene (one time only!)\n            if (!state.scene) {\n                let scene;\n                if (sceneOptions instanceof three__WEBPACK_IMPORTED_MODULE_4__.Scene) {\n                    scene = sceneOptions;\n                } else {\n                    scene = new three__WEBPACK_IMPORTED_MODULE_4__.Scene();\n                    if (sceneOptions) applyProps(scene, sceneOptions);\n                }\n                state.set({\n                    scene: prepare(scene)\n                });\n            }\n            // Set up XR (one time only!)\n            if (!state.xr) {\n                var _gl$xr;\n                // Handle frame behavior in WebXR\n                const handleXRFrame = (timestamp, frame)=>{\n                    const state = store.getState();\n                    if (state.frameloop === \"never\") return;\n                    advance(timestamp, true, state, frame);\n                };\n                // Toggle render switching on session\n                const handleSessionChange = ()=>{\n                    const state = store.getState();\n                    state.gl.xr.enabled = state.gl.xr.isPresenting;\n                    state.gl.xr.setAnimationLoop(state.gl.xr.isPresenting ? handleXRFrame : null);\n                    if (!state.gl.xr.isPresenting) invalidate(state);\n                };\n                // WebXR session manager\n                const xr = {\n                    connect () {\n                        const gl = store.getState().gl;\n                        gl.xr.addEventListener(\"sessionstart\", handleSessionChange);\n                        gl.xr.addEventListener(\"sessionend\", handleSessionChange);\n                    },\n                    disconnect () {\n                        const gl = store.getState().gl;\n                        gl.xr.removeEventListener(\"sessionstart\", handleSessionChange);\n                        gl.xr.removeEventListener(\"sessionend\", handleSessionChange);\n                    }\n                };\n                // Subscribe to WebXR session events\n                if (typeof ((_gl$xr = gl.xr) == null ? void 0 : _gl$xr.addEventListener) === \"function\") xr.connect();\n                state.set({\n                    xr\n                });\n            }\n            // Set shadowmap\n            if (gl.shadowMap) {\n                const oldEnabled = gl.shadowMap.enabled;\n                const oldType = gl.shadowMap.type;\n                gl.shadowMap.enabled = !!shadows;\n                if (is.boo(shadows)) {\n                    gl.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_4__.PCFSoftShadowMap;\n                } else if (is.str(shadows)) {\n                    var _types$shadows;\n                    const types = {\n                        basic: three__WEBPACK_IMPORTED_MODULE_4__.BasicShadowMap,\n                        percentage: three__WEBPACK_IMPORTED_MODULE_4__.PCFShadowMap,\n                        soft: three__WEBPACK_IMPORTED_MODULE_4__.PCFSoftShadowMap,\n                        variance: three__WEBPACK_IMPORTED_MODULE_4__.VSMShadowMap\n                    };\n                    gl.shadowMap.type = (_types$shadows = types[shadows]) != null ? _types$shadows : three__WEBPACK_IMPORTED_MODULE_4__.PCFSoftShadowMap;\n                } else if (is.obj(shadows)) {\n                    Object.assign(gl.shadowMap, shadows);\n                }\n                if (oldEnabled !== gl.shadowMap.enabled || oldType !== gl.shadowMap.type) gl.shadowMap.needsUpdate = true;\n            }\n            // Safely set color management if available.\n            // Avoid accessing THREE.ColorManagement to play nice with older versions\n            const ColorManagement = getColorManagement();\n            if (ColorManagement) {\n                if (\"enabled\" in ColorManagement) ColorManagement.enabled = !legacy;\n                else if (\"legacyMode\" in ColorManagement) ColorManagement.legacyMode = legacy;\n            }\n            // Set color space and tonemapping preferences\n            const LinearEncoding = 3000;\n            const sRGBEncoding = 3001;\n            applyProps(gl, {\n                outputEncoding: linear ? LinearEncoding : sRGBEncoding,\n                toneMapping: flat ? three__WEBPACK_IMPORTED_MODULE_4__.NoToneMapping : three__WEBPACK_IMPORTED_MODULE_4__.ACESFilmicToneMapping\n            });\n            // Update color management state\n            if (state.legacy !== legacy) state.set(()=>({\n                    legacy\n                }));\n            if (state.linear !== linear) state.set(()=>({\n                    linear\n                }));\n            if (state.flat !== flat) state.set(()=>({\n                    flat\n                }));\n            // Set gl props\n            if (glConfig && !is.fun(glConfig) && !isRenderer(glConfig) && !is.equ(glConfig, gl, shallowLoose)) applyProps(gl, glConfig);\n            // Store events internally\n            if (events && !state.events.handlers) state.set({\n                events: events(store)\n            });\n            // Check size, allow it to take on container bounds initially\n            const size = computeInitialSize(canvas, propsSize);\n            if (!is.equ(size, state.size, shallowLoose)) {\n                state.setSize(size.width, size.height, size.updateStyle, size.top, size.left);\n            }\n            // Check pixelratio\n            if (dpr && state.viewport.dpr !== calculateDpr(dpr)) state.setDpr(dpr);\n            // Check frameloop\n            if (state.frameloop !== frameloop) state.setFrameloop(frameloop);\n            // Check pointer missed\n            if (!state.onPointerMissed) state.set({\n                onPointerMissed\n            });\n            // Check performance\n            if (performance1 && !is.equ(performance1, state.performance, shallowLoose)) state.set((state)=>({\n                    performance: {\n                        ...state.performance,\n                        ...performance1\n                    }\n                }));\n            // Set locals\n            onCreated = onCreatedCallback;\n            configured = true;\n            return this;\n        },\n        render (children) {\n            // The root has to be configured before it can be rendered\n            if (!configured) this.configure();\n            reconciler.updateContainer(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Provider, {\n                store: store,\n                children: children,\n                onCreated: onCreated,\n                rootElement: canvas\n            }), fiber, null, ()=>undefined);\n            return store;\n        },\n        unmount () {\n            unmountComponentAtNode(canvas);\n        }\n    };\n}\nfunction render(children, canvas, config) {\n    console.warn(\"R3F.render is no longer supported in React 18. Use createRoot instead!\");\n    const root = createRoot(canvas);\n    root.configure(config);\n    return root.render(children);\n}\nfunction Provider({ store, children, onCreated, rootElement }) {\n    useIsomorphicLayoutEffect(()=>{\n        const state = store.getState();\n        // Flag the canvas active, rendering will now begin\n        state.set((state)=>({\n                internal: {\n                    ...state.internal,\n                    active: true\n                }\n            }));\n        // Notifiy that init is completed, the scene graph exists, but nothing has yet rendered\n        if (onCreated) onCreated(state);\n        // Connect events to the targets parent, this is done to ensure events are registered on\n        // a shared target, and not on the canvas itself\n        if (!store.getState().events.connected) state.events.connect == null ? void 0 : state.events.connect(rootElement);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(context.Provider, {\n        value: store\n    }, children);\n}\nfunction unmountComponentAtNode(canvas, callback) {\n    const root = roots.get(canvas);\n    const fiber = root == null ? void 0 : root.fiber;\n    if (fiber) {\n        const state = root == null ? void 0 : root.store.getState();\n        if (state) state.internal.active = false;\n        reconciler.updateContainer(null, fiber, null, ()=>{\n            if (state) {\n                setTimeout(()=>{\n                    try {\n                        var _state$gl, _state$gl$renderLists, _state$gl2, _state$gl3;\n                        state.events.disconnect == null ? void 0 : state.events.disconnect();\n                        (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\n                        (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\n                        if ((_state$gl3 = state.gl) != null && _state$gl3.xr) state.xr.disconnect();\n                        dispose(state);\n                        roots.delete(canvas);\n                        if (callback) callback(canvas);\n                    } catch (e) {\n                    /* ... */ }\n                }, 500);\n            }\n        });\n    }\n}\nfunction createPortal(children, container, state) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Portal, {\n        key: container.uuid,\n        children: children,\n        container: container,\n        state: state\n    });\n}\nfunction Portal({ state = {}, children, container }) {\n    /** This has to be a component because it would not be able to call useThree/useStore otherwise since\n   *  if this is our environment, then we are not in r3f's renderer but in react-dom, it would trigger\n   *  the \"R3F hooks can only be used within the Canvas component!\" warning:\n   *  <Canvas>\n   *    {createPortal(...)} */ const { events, size, ...rest } = state;\n    const previousRoot = useStore();\n    const [raycaster] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Raycaster());\n    const [pointer] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Vector2());\n    const inject = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((rootState, injectState)=>{\n        const intersect = {\n            ...rootState\n        }; // all prev state props\n        // Only the fields of \"rootState\" that do not differ from injectState\n        // Some props should be off-limits\n        // Otherwise filter out the props that are different and let the inject layer take precedence\n        Object.keys(rootState).forEach((key)=>{\n            if (// Some props should be off-limits\n            privateKeys.includes(key) || // Otherwise filter out the props that are different and let the inject layer take precedence\n            // Unless the inject layer props is undefined, then we keep the root layer\n            rootState[key] !== injectState[key] && injectState[key]) {\n                delete intersect[key];\n            }\n        });\n        let viewport = undefined;\n        if (injectState && size) {\n            const camera = injectState.camera;\n            // Calculate the override viewport, if present\n            viewport = rootState.viewport.getCurrentViewport(camera, new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(), size);\n            // Update the portal camera, if it differs from the previous layer\n            if (camera !== rootState.camera) updateCamera(camera, size);\n        }\n        return {\n            // The intersect consists of the previous root state\n            ...intersect,\n            // Portals have their own scene, which forms the root, a raycaster and a pointer\n            scene: container,\n            raycaster,\n            pointer,\n            mouse: pointer,\n            // Their previous root is the layer before it\n            previousRoot,\n            // Events, size and viewport can be overridden by the inject layer\n            events: {\n                ...rootState.events,\n                ...injectState == null ? void 0 : injectState.events,\n                ...events\n            },\n            size: {\n                ...rootState.size,\n                ...size\n            },\n            viewport: {\n                ...rootState.viewport,\n                ...viewport\n            },\n            ...rest\n        };\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        state\n    ]);\n    const [usePortalStore] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>{\n        // Create a mirrored store, based on the previous root with a few overrides ...\n        const previousState = previousRoot.getState();\n        const store = (0,zustand__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((set, get)=>({\n                ...previousState,\n                scene: container,\n                raycaster,\n                pointer,\n                mouse: pointer,\n                previousRoot,\n                events: {\n                    ...previousState.events,\n                    ...events\n                },\n                size: {\n                    ...previousState.size,\n                    ...size\n                },\n                ...rest,\n                // Set and get refer to this root-state\n                set,\n                get,\n                // Layers are allowed to override events\n                setEvents: (events)=>set((state)=>({\n                            ...state,\n                            events: {\n                                ...state.events,\n                                ...events\n                            }\n                        }))\n            }));\n        return store;\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        // Subscribe to previous root-state and copy changes over to the mirrored portal-state\n        const unsub = previousRoot.subscribe((prev)=>usePortalStore.setState((state)=>inject(prev, state)));\n        return ()=>{\n            unsub();\n            usePortalStore.destroy();\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        usePortalStore.setState((injectState)=>inject(previousRoot.getState(), injectState));\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        inject\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, reconciler.createPortal(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(context.Provider, {\n        value: usePortalStore\n    }, children), usePortalStore, null));\n}\nreconciler.injectIntoDevTools({\n    bundleType:  false ? 0 : 1,\n    rendererPackageName: \"@react-three/fiber\",\n    version: react__WEBPACK_IMPORTED_MODULE_0__.version\n});\nconst act = react__WEBPACK_IMPORTED_MODULE_0__.unstable_act;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvaW5kZXgtMjliNzEyMWIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ0E7QUFDbUc7QUFDckc7QUFDYTtBQUNtQztBQUNyQjtBQUV4RCxJQUFJYSxhQUFhLFdBQVcsR0FBRUMsT0FBT0MsTUFBTSxDQUFDO0lBQzFDQyxXQUFXO0FBQ2I7QUFFQSxNQUFNQyxZQUFZLENBQUM7QUFDbkIsTUFBTUMsU0FBU0MsQ0FBQUEsVUFBVyxLQUFLTCxPQUFPTSxNQUFNLENBQUNILFdBQVdFO0FBQ3hELFNBQVNFLGVBQWVDLE1BQU0sRUFBRUMsaUJBQWlCO0lBQy9DLFNBQVNDLGVBQWVDLElBQUksRUFBRSxFQUM1QkMsT0FBTyxFQUFFLEVBQ1RDLE1BQU0sRUFDTixHQUFHQyxPQUNKLEVBQUVDLElBQUk7UUFDTCxJQUFJQyxPQUFPLENBQUMsRUFBRUwsSUFBSSxDQUFDLEVBQUUsQ0FBQ00sV0FBVyxHQUFHLEVBQUVOLEtBQUtPLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFDckQsSUFBSUM7UUFDSixJQUFJUixTQUFTLGFBQWE7WUFDeEIsSUFBSUcsTUFBTU0sTUFBTSxLQUFLQyxXQUFXLE1BQU0sSUFBSUMsTUFBTTtZQUNoRCxNQUFNRixTQUFTTixNQUFNTSxNQUFNO1lBQzNCRCxXQUFXSSxRQUFRSCxRQUFRO2dCQUN6QlQ7Z0JBQ0FJO2dCQUNBRjtnQkFDQVcsV0FBVztZQUNiO1FBQ0YsT0FBTztZQUNMLE1BQU1DLFNBQVN0QixTQUFTLENBQUNhLEtBQUs7WUFDOUIsSUFBSSxDQUFDUyxRQUFRO2dCQUNYLE1BQU0sSUFBSUgsTUFBTSxDQUFDLEtBQUssRUFBRU4sS0FBSyw0SkFBNEosQ0FBQztZQUM1TDtZQUVBLG9EQUFvRDtZQUNwRCxJQUFJLENBQUNVLE1BQU1DLE9BQU8sQ0FBQ2YsT0FBTyxNQUFNLElBQUlVLE1B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QUFRLENBQUNMLENBQUFBLGNBQWVGLE9BQU96WSxhQUFhakksUUFBUSxJQUFJNGdCO0lBQ3ZFLHVEQUF1RDtJQUN6RCxHQUFHO1FBQUNGO0tBQU87SUFDWCxPQUFPLFdBQVcsR0FBRTVtQixnREFBbUIsQ0FBQ0EsMkNBQWMsRUFBRSxNQUFNNEcsV0FBVzRmLFlBQVksQ0FBRSxXQUFXLEdBQUV4bUIsZ0RBQW1CLENBQUN3YSxRQUFRcUwsUUFBUSxFQUFFO1FBQ3hJbGQsT0FBT29lO0lBQ1QsR0FBRy9pQixXQUFXK2lCLGdCQUFnQjtBQUNoQztBQUNBbmdCLFdBQVcwZ0Isa0JBQWtCLENBQUM7SUFDNUJDLFlBQVl0VyxNQUF5QixHQUFlLENBQUMsR0FBRztJQUN4RHVXLHFCQUFxQjtJQUNyQkMsU0FBU3puQiwwQ0FBYTtBQUN4QjtBQUNBLE1BQU0wbkIsTUFBTTFuQiwrQ0FBa0I7QUFFdWhCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2hhaXNhYm0vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvaW5kZXgtMjliNzEyMWIuZXNtLmpzP2JjYWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRGVmYXVsdEV2ZW50UHJpb3JpdHksIENvbnRpbnVvdXNFdmVudFByaW9yaXR5LCBEaXNjcmV0ZUV2ZW50UHJpb3JpdHksIENvbmN1cnJlbnRSb290IH0gZnJvbSAncmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMnO1xuaW1wb3J0IGNyZWF0ZSBmcm9tICd6dXN0YW5kJztcbmltcG9ydCBSZWNvbmNpbGVyIGZyb20gJ3JlYWN0LXJlY29uY2lsZXInO1xuaW1wb3J0IHsgdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjaywgdW5zdGFibGVfSWRsZVByaW9yaXR5IH0gZnJvbSAnc2NoZWR1bGVyJztcbmltcG9ydCB7IHN1c3BlbmQsIHByZWxvYWQsIGNsZWFyIH0gZnJvbSAnc3VzcGVuZC1yZWFjdCc7XG5cbnZhciB0aHJlZVR5cGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG5jb25zdCBjYXRhbG9ndWUgPSB7fTtcbmNvbnN0IGV4dGVuZCA9IG9iamVjdHMgPT4gdm9pZCBPYmplY3QuYXNzaWduKGNhdGFsb2d1ZSwgb2JqZWN0cyk7XG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJlcihfcm9vdHMsIF9nZXRFdmVudFByaW9yaXR5KSB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKHR5cGUsIHtcbiAgICBhcmdzID0gW10sXG4gICAgYXR0YWNoLFxuICAgIC4uLnByb3BzXG4gIH0sIHJvb3QpIHtcbiAgICBsZXQgbmFtZSA9IGAke3R5cGVbMF0udG9VcHBlckNhc2UoKX0ke3R5cGUuc2xpY2UoMSl9YDtcbiAgICBsZXQgaW5zdGFuY2U7XG4gICAgaWYgKHR5cGUgPT09ICdwcmltaXRpdmUnKSB7XG4gICAgICBpZiAocHJvcHMub2JqZWN0ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcIlIzRjogUHJpbWl0aXZlcyB3aXRob3V0ICdvYmplY3QnIGFyZSBpbnZhbGlkIVwiKTtcbiAgICAgIGNvbnN0IG9iamVjdCA9IHByb3BzLm9iamVjdDtcbiAgICAgIGluc3RhbmNlID0gcHJlcGFyZShvYmplY3QsIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcm9vdCxcbiAgICAgICAgYXR0YWNoLFxuICAgICAgICBwcmltaXRpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBjYXRhbG9ndWVbbmFtZV07XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFIzRjogJHtuYW1lfSBpcyBub3QgcGFydCBvZiB0aGUgVEhSRUUgbmFtZXNwYWNlISBEaWQgeW91IGZvcmdldCB0byBleHRlbmQ/IFNlZTogaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL29iamVjdHMjdXNpbmctM3JkLXBhcnR5LW9iamVjdHMtZGVjbGFyYXRpdmVseWApO1xuICAgICAgfVxuXG4gICAgICAvLyBUaHJvdyBpZiBhbiBvYmplY3Qgb3IgbGl0ZXJhbCB3YXMgcGFzc2VkIGZvciBhcmdzXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJncykpIHRocm93IG5ldyBFcnJvcignUjNGOiBUaGUgYXJncyBwcm9wIG11c3QgYmUgYW4gYXJyYXkhJyk7XG5cbiAgICAgIC8vIEluc3RhbmNpYXRlIG5ldyBvYmplY3QsIGxpbmsgaXQgdG8gdGhlIHJvb3RcbiAgICAgIC8vIEFwcGVuZCBtZW1vaXplZCBwcm9wcyB3aXRoIGFyZ3Mgc28gaXQncyBub3QgZm9yZ290dGVuXG4gICAgICBpbnN0YW5jZSA9IHByZXBhcmUobmV3IHRhcmdldCguLi5hcmdzKSwge1xuICAgICAgICB0eXBlLFxuICAgICAgICByb290LFxuICAgICAgICBhdHRhY2gsXG4gICAgICAgIC8vIFNhdmUgYXJncyBpbiBjYXNlIHdlIG5lZWQgdG8gcmVjb25zdHJ1Y3QgbGF0ZXIgZm9yIEhNUlxuICAgICAgICBtZW1vaXplZFByb3BzOiB7XG4gICAgICAgICAgYXJnc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBdXRvLWF0dGFjaCBnZW9tZXRyaWVzIGFuZCBtYXRlcmlhbHNcbiAgICBpZiAoaW5zdGFuY2UuX19yM2YuYXR0YWNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5KSBpbnN0YW5jZS5fX3IzZi5hdHRhY2ggPSAnZ2VvbWV0cnknO2Vsc2UgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgVEhSRUUuTWF0ZXJpYWwpIGluc3RhbmNlLl9fcjNmLmF0dGFjaCA9ICdtYXRlcmlhbCc7XG4gICAgfVxuXG4gICAgLy8gSXQgc2hvdWxkIE5PVCBjYWxsIG9uVXBkYXRlIG9uIG9iamVjdCBpbnN0YW5jaWF0aW9uLCBiZWNhdXNlIGl0IGhhc24ndCBiZWVuIGFkZGVkIHRvIHRoZVxuICAgIC8vIHZpZXcgeWV0LiBJZiB0aGUgY2FsbGJhY2sgcmVsaWVzIG9uIHJlZmVyZW5jZXMgZm9yIGluc3RhbmNlLCB0aGV5IHdvbid0IGJlIHJlYWR5IHlldCwgdGhpcyBpc1xuICAgIC8vIHdoeSBpdCBwYXNzZXMgXCJ0cnVlXCIgaGVyZVxuICAgIC8vIFRoZXJlIGlzIG5vIHJlYXNvbiB0byBhcHBseSBwcm9wcyB0byBpbmplY3RzXG4gICAgaWYgKG5hbWUgIT09ICdpbmplY3QnKSBhcHBseVByb3BzJDEoaW5zdGFuY2UsIHByb3BzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgZnVuY3Rpb24gYXBwZW5kQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgbGV0IGFkZGVkID0gZmFsc2U7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICB2YXIgX2NoaWxkJF9fcjNmLCBfcGFyZW50SW5zdGFuY2UkX19yM2Y7XG4gICAgICAvLyBUaGUgYXR0YWNoIGF0dHJpYnV0ZSBpbXBsaWVzIHRoYXQgdGhlIG9iamVjdCBhdHRhY2hlcyBpdHNlbGYgb24gdGhlIHBhcmVudFxuICAgICAgaWYgKChfY2hpbGQkX19yM2YgPSBjaGlsZC5fX3IzZikgIT0gbnVsbCAmJiBfY2hpbGQkX19yM2YuYXR0YWNoKSB7XG4gICAgICAgIGF0dGFjaChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGNoaWxkLl9fcjNmLmF0dGFjaCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLmlzT2JqZWN0M0QgJiYgcGFyZW50SW5zdGFuY2UuaXNPYmplY3QzRCkge1xuICAgICAgICAvLyBhZGQgaW4gdGhlIHVzdWFsIHBhcmVudC1jaGlsZCB3YXlcbiAgICAgICAgcGFyZW50SW5zdGFuY2UuYWRkKGNoaWxkKTtcbiAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyBpcyBmb3IgYW55dGhpbmcgdGhhdCB1c2VkIGF0dGFjaCwgYW5kIGZvciBub24tT2JqZWN0M0RzIHRoYXQgZG9uJ3QgZ2V0IGF0dGFjaGVkIHRvIHByb3BzO1xuICAgICAgLy8gdGhhdCBpcywgYW55dGhpbmcgdGhhdCdzIGEgY2hpbGQgaW4gUmVhY3QgYnV0IG5vdCBhIGNoaWxkIGluIHRoZSBzY2VuZWdyYXBoLlxuICAgICAgaWYgKCFhZGRlZCkgKF9wYXJlbnRJbnN0YW5jZSRfX3IzZiA9IHBhcmVudEluc3RhbmNlLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3BhcmVudEluc3RhbmNlJF9fcjNmLm9iamVjdHMucHVzaChjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLl9fcjNmKSBwcmVwYXJlKGNoaWxkLCB7fSk7XG4gICAgICBjaGlsZC5fX3IzZi5wYXJlbnQgPSBwYXJlbnRJbnN0YW5jZTtcbiAgICAgIHVwZGF0ZUluc3RhbmNlKGNoaWxkKTtcbiAgICAgIGludmFsaWRhdGVJbnN0YW5jZShjaGlsZCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gICAgbGV0IGFkZGVkID0gZmFsc2U7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICB2YXIgX2NoaWxkJF9fcjNmMiwgX3BhcmVudEluc3RhbmNlJF9fcjNmMjtcbiAgICAgIGlmICgoX2NoaWxkJF9fcjNmMiA9IGNoaWxkLl9fcjNmKSAhPSBudWxsICYmIF9jaGlsZCRfX3IzZjIuYXR0YWNoKSB7XG4gICAgICAgIGF0dGFjaChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGNoaWxkLl9fcjNmLmF0dGFjaCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLmlzT2JqZWN0M0QgJiYgcGFyZW50SW5zdGFuY2UuaXNPYmplY3QzRCkge1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSBwYXJlbnRJbnN0YW5jZTtcbiAgICAgICAgY2hpbGQuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgdHlwZTogJ2FkZGVkJ1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdFNpYmxpbmdzID0gcGFyZW50SW5zdGFuY2UuY2hpbGRyZW4uZmlsdGVyKHNpYmxpbmcgPT4gc2libGluZyAhPT0gY2hpbGQpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHJlc3RTaWJsaW5ncy5pbmRleE9mKGJlZm9yZUNoaWxkKTtcbiAgICAgICAgcGFyZW50SW5zdGFuY2UuY2hpbGRyZW4gPSBbLi4ucmVzdFNpYmxpbmdzLnNsaWNlKDAsIGluZGV4KSwgY2hpbGQsIC4uLnJlc3RTaWJsaW5ncy5zbGljZShpbmRleCldO1xuICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIWFkZGVkKSAoX3BhcmVudEluc3RhbmNlJF9fcjNmMiA9IHBhcmVudEluc3RhbmNlLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3BhcmVudEluc3RhbmNlJF9fcjNmMi5vYmplY3RzLnB1c2goY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5fX3IzZikgcHJlcGFyZShjaGlsZCwge30pO1xuICAgICAgY2hpbGQuX19yM2YucGFyZW50ID0gcGFyZW50SW5zdGFuY2U7XG4gICAgICB1cGRhdGVJbnN0YW5jZShjaGlsZCk7XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoY2hpbGQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZW1vdmVSZWN1cnNpdmUoYXJyYXksIHBhcmVudCwgZGlzcG9zZSA9IGZhbHNlKSB7XG4gICAgaWYgKGFycmF5KSBbLi4uYXJyYXldLmZvckVhY2goY2hpbGQgPT4gcmVtb3ZlQ2hpbGQocGFyZW50LCBjaGlsZCwgZGlzcG9zZSkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgZGlzcG9zZSkge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgdmFyIF9wYXJlbnRJbnN0YW5jZSRfX3IzZjMsIF9jaGlsZCRfX3IzZjMsIF9jaGlsZCRfX3IzZjU7XG4gICAgICAvLyBDbGVhciB0aGUgcGFyZW50IHJlZmVyZW5jZVxuICAgICAgaWYgKGNoaWxkLl9fcjNmKSBjaGlsZC5fX3IzZi5wYXJlbnQgPSBudWxsO1xuICAgICAgLy8gUmVtb3ZlIGNoaWxkIGZyb20gdGhlIHBhcmVudHMgb2JqZWN0c1xuICAgICAgaWYgKChfcGFyZW50SW5zdGFuY2UkX19yM2YzID0gcGFyZW50SW5zdGFuY2UuX19yM2YpICE9IG51bGwgJiYgX3BhcmVudEluc3RhbmNlJF9fcjNmMy5vYmplY3RzKSBwYXJlbnRJbnN0YW5jZS5fX3IzZi5vYmplY3RzID0gcGFyZW50SW5zdGFuY2UuX19yM2Yub2JqZWN0cy5maWx0ZXIoeCA9PiB4ICE9PSBjaGlsZCk7XG4gICAgICAvLyBSZW1vdmUgYXR0YWNobWVudFxuICAgICAgaWYgKChfY2hpbGQkX19yM2YzID0gY2hpbGQuX19yM2YpICE9IG51bGwgJiYgX2NoaWxkJF9fcjNmMy5hdHRhY2gpIHtcbiAgICAgICAgZGV0YWNoKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgY2hpbGQuX19yM2YuYXR0YWNoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQuaXNPYmplY3QzRCAmJiBwYXJlbnRJbnN0YW5jZS5pc09iamVjdDNEKSB7XG4gICAgICAgIHZhciBfY2hpbGQkX19yM2Y0O1xuICAgICAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmUoY2hpbGQpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIC8vIFJlbW92ZSBpbnRlcmFjdGl2aXR5IG9uIHRoZSBpbml0aWFsIHJvb3RcbiAgICAgICAgaWYgKChfY2hpbGQkX19yM2Y0ID0gY2hpbGQuX19yM2YpICE9IG51bGwgJiYgX2NoaWxkJF9fcjNmNC5yb290KSB7XG4gICAgICAgICAgcmVtb3ZlSW50ZXJhY3Rpdml0eShmaW5kSW5pdGlhbFJvb3QoY2hpbGQpLCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWxsb3cgb2JqZWN0cyB0byBiYWlsIG91dCBvZiByZWN1cnNpdmUgZGlzcG9zZSBhbHRvZ2V0aGVyIGJ5IHBhc3NpbmcgZGlzcG9zZT17bnVsbH1cbiAgICAgIC8vIE5ldmVyIGRpc3Bvc2Ugb2YgcHJpbWl0aXZlcyBiZWNhdXNlIHRoZWlyIHN0YXRlIG1heSBiZSBrZXB0IG91dHNpZGUgb2YgUmVhY3QhXG4gICAgICAvLyBJbiBvcmRlciBmb3IgYW4gb2JqZWN0IHRvIGJlIGFibGUgdG8gZGlzcG9zZSBpdCBoYXMgdG8gaGF2ZVxuICAgICAgLy8gICAtIGEgZGlzcG9zZSBtZXRob2QsXG4gICAgICAvLyAgIC0gaXQgY2Fubm90IGJlIGEgPHByaW1pdGl2ZSBvYmplY3Q9ey4uLn0gLz5cbiAgICAgIC8vICAgLSBpdCBjYW5ub3QgYmUgYSBUSFJFRS5TY2VuZSwgYmVjYXVzZSB0aHJlZSBoYXMgYnJva2VuIGl0J3Mgb3duIGFwaVxuICAgICAgLy9cbiAgICAgIC8vIFNpbmNlIGRpc3Bvc2FsIGlzIHJlY3Vyc2l2ZSwgd2UgY2FuIGNoZWNrIHRoZSBvcHRpb25hbCBkaXNwb3NlIGFyZywgd2hpY2ggd2lsbCBiZSB1bmRlZmluZWRcbiAgICAgIC8vIHdoZW4gdGhlIHJlY29uY2lsZXIgY2FsbHMgaXQsIGJ1dCB0aGVuIGNhcnJ5IG91ciBvd24gY2hlY2sgcmVjdXJzaXZlbHlcbiAgICAgIGNvbnN0IGlzUHJpbWl0aXZlID0gKF9jaGlsZCRfX3IzZjUgPSBjaGlsZC5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jaGlsZCRfX3IzZjUucHJpbWl0aXZlO1xuICAgICAgY29uc3Qgc2hvdWxkRGlzcG9zZSA9ICFpc1ByaW1pdGl2ZSAmJiAoZGlzcG9zZSA9PT0gdW5kZWZpbmVkID8gY2hpbGQuZGlzcG9zZSAhPT0gbnVsbCA6IGRpc3Bvc2UpO1xuXG4gICAgICAvLyBSZW1vdmUgbmVzdGVkIGNoaWxkIG9iamVjdHMuIFByaW1pdGl2ZXMgc2hvdWxkIG5vdCBoYXZlIG9iamVjdHMgYW5kIGNoaWxkcmVuIHRoYXQgYXJlXG4gICAgICAvLyBhdHRhY2hlZCB0byB0aGVtIGRlY2xhcmF0aXZlbHkgLi4uXG4gICAgICBpZiAoIWlzUHJpbWl0aXZlKSB7XG4gICAgICAgIHZhciBfY2hpbGQkX19yM2Y2O1xuICAgICAgICByZW1vdmVSZWN1cnNpdmUoKF9jaGlsZCRfX3IzZjYgPSBjaGlsZC5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jaGlsZCRfX3IzZjYub2JqZWN0cywgY2hpbGQsIHNob3VsZERpc3Bvc2UpO1xuICAgICAgICByZW1vdmVSZWN1cnNpdmUoY2hpbGQuY2hpbGRyZW4sIGNoaWxkLCBzaG91bGREaXNwb3NlKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHJlZmVyZW5jZXNcbiAgICAgIGRlbGV0ZSBjaGlsZC5fX3IzZjtcblxuICAgICAgLy8gRGlzcG9zZSBpdGVtIHdoZW5ldmVyIHRoZSByZWNvbmNpbGVyIGZlZWxzIGxpa2UgaXRcbiAgICAgIGlmIChzaG91bGREaXNwb3NlICYmIGNoaWxkLmRpc3Bvc2UgJiYgY2hpbGQudHlwZSAhPT0gJ1NjZW5lJykge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2hpbGQuZGlzcG9zZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8qIC4uLiAqL1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTY2hlZHVsZSBhc3luYyBhdCBydW50aW1lLCBmbHVzaCBzeW5jIGluIHRlc3RpbmdcbiAgICAgICAgaWYgKHR5cGVvZiBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayh1bnN0YWJsZV9JZGxlUHJpb3JpdHksIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UocGFyZW50SW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzd2l0Y2hJbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIGZpYmVyKSB7XG4gICAgdmFyIF9pbnN0YW5jZSRfX3IzZjtcbiAgICBjb25zdCBwYXJlbnQgPSAoX2luc3RhbmNlJF9fcjNmID0gaW5zdGFuY2UuX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2UkX19yM2YucGFyZW50O1xuICAgIGlmICghcGFyZW50KSByZXR1cm47XG4gICAgY29uc3QgbmV3SW5zdGFuY2UgPSBjcmVhdGVJbnN0YW5jZSh0eXBlLCBuZXdQcm9wcywgaW5zdGFuY2UuX19yM2Yucm9vdCk7XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8xMzQ4XG4gICAgLy8gV2hlbiBhcmdzIGNoYW5nZSB0aGUgaW5zdGFuY2UgaGFzIHRvIGJlIHJlLWNvbnN0cnVjdGVkLCB3aGljaCB0aGVuXG4gICAgLy8gZm9yY2VzIHIzZiB0byByZS1wYXJlbnQgdGhlIGNoaWxkcmVuIGFuZCBub24tc2NlbmUgb2JqZWN0c1xuICAgIGlmIChpbnN0YW5jZS5jaGlsZHJlbikge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBpbnN0YW5jZS5jaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGQuX19yM2YpIGFwcGVuZENoaWxkKG5ld0luc3RhbmNlLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBpbnN0YW5jZS5jaGlsZHJlbiA9IGluc3RhbmNlLmNoaWxkcmVuLmZpbHRlcihjaGlsZCA9PiAhY2hpbGQuX19yM2YpO1xuICAgIH1cbiAgICBpbnN0YW5jZS5fX3IzZi5vYmplY3RzLmZvckVhY2goY2hpbGQgPT4gYXBwZW5kQ2hpbGQobmV3SW5zdGFuY2UsIGNoaWxkKSk7XG4gICAgaW5zdGFuY2UuX19yM2Yub2JqZWN0cyA9IFtdO1xuICAgIGlmICghaW5zdGFuY2UuX19yM2YuYXV0b1JlbW92ZWRCZWZvcmVBcHBlbmQpIHtcbiAgICAgIHJlbW92ZUNoaWxkKHBhcmVudCwgaW5zdGFuY2UpO1xuICAgIH1cbiAgICBpZiAobmV3SW5zdGFuY2UucGFyZW50KSB7XG4gICAgICBuZXdJbnN0YW5jZS5fX3IzZi5hdXRvUmVtb3ZlZEJlZm9yZUFwcGVuZCA9IHRydWU7XG4gICAgfVxuICAgIGFwcGVuZENoaWxkKHBhcmVudCwgbmV3SW5zdGFuY2UpO1xuXG4gICAgLy8gUmUtYmluZCBldmVudCBoYW5kbGVycyBvbiB0aGUgaW5pdGlhbCByb290XG4gICAgaWYgKG5ld0luc3RhbmNlLnJheWNhc3QgJiYgbmV3SW5zdGFuY2UuX19yM2YuZXZlbnRDb3VudCkge1xuICAgICAgY29uc3Qgcm9vdFN0YXRlID0gZmluZEluaXRpYWxSb290KG5ld0luc3RhbmNlKS5nZXRTdGF0ZSgpO1xuICAgICAgcm9vdFN0YXRlLmludGVybmFsLmludGVyYWN0aW9uLnB1c2gobmV3SW5zdGFuY2UpO1xuICAgIH1cbiAgICBbZmliZXIsIGZpYmVyLmFsdGVybmF0ZV0uZm9yRWFjaChmaWJlciA9PiB7XG4gICAgICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gbmV3SW5zdGFuY2U7XG4gICAgICAgIGlmIChmaWJlci5yZWYpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGZpYmVyLnJlZiA9PT0gJ2Z1bmN0aW9uJykgZmliZXIucmVmKG5ld0luc3RhbmNlKTtlbHNlIGZpYmVyLnJlZi5jdXJyZW50ID0gbmV3SW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIERvbid0IGhhbmRsZSB0ZXh0IGluc3RhbmNlcywgd2FybiBvbiB1bmRlZmluZWQgYmVoYXZpb3JcbiAgY29uc3QgaGFuZGxlVGV4dEluc3RhbmNlID0gKCkgPT4gY29uc29sZS53YXJuKCdUZXh0IGlzIG5vdCBhbGxvd2VkIGluIHRoZSBSM0YgdHJlZSEgVGhpcyBjb3VsZCBiZSBzdHJheSB3aGl0ZXNwYWNlIG9yIGNoYXJhY3RlcnMuJyk7XG4gIGNvbnN0IHJlY29uY2lsZXIgPSBSZWNvbmNpbGVyKHtcbiAgICBjcmVhdGVJbnN0YW5jZSxcbiAgICByZW1vdmVDaGlsZCxcbiAgICBhcHBlbmRDaGlsZCxcbiAgICBhcHBlbmRJbml0aWFsQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICAgIGluc2VydEJlZm9yZSxcbiAgICBzdXBwb3J0c011dGF0aW9uOiB0cnVlLFxuICAgIGlzUHJpbWFyeVJlbmRlcmVyOiBmYWxzZSxcbiAgICBzdXBwb3J0c1BlcnNpc3RlbmNlOiBmYWxzZSxcbiAgICBzdXBwb3J0c0h5ZHJhdGlvbjogZmFsc2UsXG4gICAgbm9UaW1lb3V0OiAtMSxcbiAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyOiAoY29udGFpbmVyLCBjaGlsZCkgPT4ge1xuICAgICAgaWYgKCFjaGlsZCkgcmV0dXJuO1xuXG4gICAgICAvLyBEb24ndCBhcHBlbmQgdG8gdW5tb3VudGVkIGNvbnRhaW5lclxuICAgICAgY29uc3Qgc2NlbmUgPSBjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZTtcbiAgICAgIGlmICghc2NlbmUuX19yM2YpIHJldHVybjtcblxuICAgICAgLy8gTGluayBjdXJyZW50IHJvb3QgdG8gdGhlIGRlZmF1bHQgc2NlbmVcbiAgICAgIHNjZW5lLl9fcjNmLnJvb3QgPSBjb250YWluZXI7XG4gICAgICBhcHBlbmRDaGlsZChzY2VuZSwgY2hpbGQpO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyOiAoY29udGFpbmVyLCBjaGlsZCkgPT4ge1xuICAgICAgaWYgKCFjaGlsZCkgcmV0dXJuO1xuICAgICAgcmVtb3ZlQ2hpbGQoY29udGFpbmVyLmdldFN0YXRlKCkuc2NlbmUsIGNoaWxkKTtcbiAgICB9LFxuICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlOiAoY29udGFpbmVyLCBjaGlsZCwgYmVmb3JlQ2hpbGQpID0+IHtcbiAgICAgIGlmICghY2hpbGQgfHwgIWJlZm9yZUNoaWxkKSByZXR1cm47XG5cbiAgICAgIC8vIERvbid0IGFwcGVuZCB0byB1bm1vdW50ZWQgY29udGFpbmVyXG4gICAgICBjb25zdCBzY2VuZSA9IGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lO1xuICAgICAgaWYgKCFzY2VuZS5fX3IzZikgcmV0dXJuO1xuICAgICAgaW5zZXJ0QmVmb3JlKHNjZW5lLCBjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICAgIH0sXG4gICAgZ2V0Um9vdEhvc3RDb250ZXh0OiAoKSA9PiBudWxsLFxuICAgIGdldENoaWxkSG9zdENvbnRleHQ6IHBhcmVudEhvc3RDb250ZXh0ID0+IHBhcmVudEhvc3RDb250ZXh0LFxuICAgIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKGluc3RhbmNlKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmMjtcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSAoX2luc3RhbmNlJF9fcjNmMiA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjIgOiB7fTtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjAyNzFcbiAgICAgIC8vIFJldHVybmluZyB0cnVlIHdpbGwgdHJpZ2dlciBjb21taXRNb3VudFxuICAgICAgcmV0dXJuIEJvb2xlYW4obG9jYWxTdGF0ZS5oYW5kbGVycyk7XG4gICAgfSxcbiAgICBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCBfdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmMztcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSAoX2luc3RhbmNlJF9fcjNmMyA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjMgOiB7fTtcblxuICAgICAgLy8gQ3JlYXRlIGRpZmYtc2V0c1xuICAgICAgaWYgKGxvY2FsU3RhdGUucHJpbWl0aXZlICYmIG5ld1Byb3BzLm9iamVjdCAmJiBuZXdQcm9wcy5vYmplY3QgIT09IGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBbdHJ1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGEgZGF0YSBvYmplY3QsIGxldCdzIGV4dHJhY3QgY3JpdGljYWwgaW5mb3JtYXRpb24gYWJvdXQgaXRcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFyZ3M6IGFyZ3NOZXcgPSBbXSxcbiAgICAgICAgICBjaGlsZHJlbjogY04sXG4gICAgICAgICAgLi4ucmVzdE5ld1xuICAgICAgICB9ID0gbmV3UHJvcHM7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBhcmdzOiBhcmdzT2xkID0gW10sXG4gICAgICAgICAgY2hpbGRyZW46IGNPLFxuICAgICAgICAgIC4uLnJlc3RPbGRcbiAgICAgICAgfSA9IG9sZFByb3BzO1xuXG4gICAgICAgIC8vIFRocm93IGlmIGFuIG9iamVjdCBvciBsaXRlcmFsIHdhcyBwYXNzZWQgZm9yIGFyZ3NcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ3NOZXcpKSB0aHJvdyBuZXcgRXJyb3IoJ1IzRjogdGhlIGFyZ3MgcHJvcCBtdXN0IGJlIGFuIGFycmF5IScpO1xuXG4gICAgICAgIC8vIElmIGl0IGhhcyBuZXcgcHJvcHMgb3IgYXJndW1lbnRzLCB0aGVuIGl0IG5lZWRzIHRvIGJlIHJlLWluc3RhbnRpYXRlZFxuICAgICAgICBpZiAoYXJnc05ldy5zb21lKCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlICE9PSBhcmdzT2xkW2luZGV4XSkpIHJldHVybiBbdHJ1ZV07XG4gICAgICAgIC8vIENyZWF0ZSBhIGRpZmYtc2V0LCBmbGFnIGlmIHRoZXJlIGFyZSBhbnkgY2hhbmdlc1xuICAgICAgICBjb25zdCBkaWZmID0gZGlmZlByb3BzKGluc3RhbmNlLCByZXN0TmV3LCByZXN0T2xkLCB0cnVlKTtcbiAgICAgICAgaWYgKGRpZmYuY2hhbmdlcy5sZW5ndGgpIHJldHVybiBbZmFsc2UsIGRpZmZdO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSBkbyBub3QgdG91Y2ggdGhlIGluc3RhbmNlXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWl0VXBkYXRlKGluc3RhbmNlLCBbcmVjb25zdHJ1Y3QsIGRpZmZdLCB0eXBlLCBfb2xkUHJvcHMsIG5ld1Byb3BzLCBmaWJlcikge1xuICAgICAgLy8gUmVjb25zdHJ1Y3Qgd2hlbiBhcmdzIG9yIDxwcmltaXRpdmUgb2JqZWN0PXsuLi59IGhhdmUgY2hhbmdlc1xuICAgICAgaWYgKHJlY29uc3RydWN0KSBzd2l0Y2hJbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIGZpYmVyKTtcbiAgICAgIC8vIE90aGVyd2lzZSBqdXN0IG92ZXJ3cml0ZSBwcm9wc1xuICAgICAgZWxzZSBhcHBseVByb3BzJDEoaW5zdGFuY2UsIGRpZmYpO1xuICAgIH0sXG4gICAgY29tbWl0TW91bnQoaW5zdGFuY2UsIF90eXBlLCBfcHJvcHMsIF9pbnQpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkX19yM2Y0O1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDI3MVxuICAgICAgLy8gVGhpcyB3aWxsIG1ha2Ugc3VyZSBldmVudHMgYXJlIG9ubHkgYWRkZWQgb25jZSB0byB0aGUgY2VudHJhbCBjb250YWluZXIgb24gdGhlIGluaXRpYWwgcm9vdFxuICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IChfaW5zdGFuY2UkX19yM2Y0ID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2Y0IDoge307XG4gICAgICBpZiAoaW5zdGFuY2UucmF5Y2FzdCAmJiBsb2NhbFN0YXRlLmhhbmRsZXJzICYmIGxvY2FsU3RhdGUuZXZlbnRDb3VudCkge1xuICAgICAgICBmaW5kSW5pdGlhbFJvb3QoaW5zdGFuY2UpLmdldFN0YXRlKCkuaW50ZXJuYWwuaW50ZXJhY3Rpb24ucHVzaChpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRQdWJsaWNJbnN0YW5jZTogaW5zdGFuY2UgPT4gaW5zdGFuY2UsXG4gICAgcHJlcGFyZUZvckNvbW1pdDogKCkgPT4gbnVsbCxcbiAgICBwcmVwYXJlUG9ydGFsTW91bnQ6IGNvbnRhaW5lciA9PiBwcmVwYXJlKGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lKSxcbiAgICByZXNldEFmdGVyQ29tbWl0OiAoKSA9PiB7fSxcbiAgICBzaG91bGRTZXRUZXh0Q29udGVudDogKCkgPT4gZmFsc2UsXG4gICAgY2xlYXJDb250YWluZXI6ICgpID0+IGZhbHNlLFxuICAgIGhpZGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgICAgdmFyIF9pbnN0YW5jZSRfX3IzZjU7XG4gICAgICAvLyBEZXRhY2ggd2hpbGUgdGhlIGluc3RhbmNlIGlzIGhpZGRlblxuICAgICAgY29uc3Qge1xuICAgICAgICBhdHRhY2g6IHR5cGUsXG4gICAgICAgIHBhcmVudFxuICAgICAgfSA9IChfaW5zdGFuY2UkX19yM2Y1ID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2Y1IDoge307XG4gICAgICBpZiAodHlwZSAmJiBwYXJlbnQpIGRldGFjaChwYXJlbnQsIGluc3RhbmNlLCB0eXBlKTtcbiAgICAgIGlmIChpbnN0YW5jZS5pc09iamVjdDNEKSBpbnN0YW5jZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIH0sXG4gICAgdW5oaWRlSW5zdGFuY2UoaW5zdGFuY2UsIHByb3BzKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmNjtcbiAgICAgIC8vIFJlLWF0dGFjaCB3aGVuIHRoZSBpbnN0YW5jZSBpcyB1bmhpZGRlblxuICAgICAgY29uc3Qge1xuICAgICAgICBhdHRhY2g6IHR5cGUsXG4gICAgICAgIHBhcmVudFxuICAgICAgfSA9IChfaW5zdGFuY2UkX19yM2Y2ID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2Y2IDoge307XG4gICAgICBpZiAodHlwZSAmJiBwYXJlbnQpIGF0dGFjaChwYXJlbnQsIGluc3RhbmNlLCB0eXBlKTtcbiAgICAgIGlmIChpbnN0YW5jZS5pc09iamVjdDNEICYmIHByb3BzLnZpc2libGUgPT0gbnVsbCB8fCBwcm9wcy52aXNpYmxlKSBpbnN0YW5jZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgfSxcbiAgICBjcmVhdGVUZXh0SW5zdGFuY2U6IGhhbmRsZVRleHRJbnN0YW5jZSxcbiAgICBoaWRlVGV4dEluc3RhbmNlOiBoYW5kbGVUZXh0SW5zdGFuY2UsXG4gICAgdW5oaWRlVGV4dEluc3RhbmNlOiBoYW5kbGVUZXh0SW5zdGFuY2UsXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzIzNjAjZGlzY3Vzc2lvbl9yOTE2MzU2ODc0XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGdldEN1cnJlbnRFdmVudFByaW9yaXR5OiAoKSA9PiBfZ2V0RXZlbnRQcmlvcml0eSA/IF9nZXRFdmVudFByaW9yaXR5KCkgOiBEZWZhdWx0RXZlbnRQcmlvcml0eSxcbiAgICBiZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXI6ICgpID0+IHt9LFxuICAgIGFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyOiAoKSA9PiB7fSxcbiAgICBkZXRhY2hEZWxldGVkSW5zdGFuY2U6ICgpID0+IHt9LFxuICAgIG5vdzogdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiBpcy5mdW4ocGVyZm9ybWFuY2Uubm93KSA/IHBlcmZvcm1hbmNlLm5vdyA6IGlzLmZ1bihEYXRlLm5vdykgPyBEYXRlLm5vdyA6ICgpID0+IDAsXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzIzNjAjZGlzY3Vzc2lvbl9yOTIwODgzNTAzXG4gICAgc2NoZWR1bGVUaW1lb3V0OiBpcy5mdW4oc2V0VGltZW91dCkgPyBzZXRUaW1lb3V0IDogdW5kZWZpbmVkLFxuICAgIGNhbmNlbFRpbWVvdXQ6IGlzLmZ1bihjbGVhclRpbWVvdXQpID8gY2xlYXJUaW1lb3V0IDogdW5kZWZpbmVkXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHJlY29uY2lsZXIsXG4gICAgYXBwbHlQcm9wczogYXBwbHlQcm9wcyQxXG4gIH07XG59XG5cbnZhciBfd2luZG93JGRvY3VtZW50LCBfd2luZG93JG5hdmlnYXRvcjtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgd2l0aCBjb3JyZWN0IFRTIHR5cGUgaW5mZXJlbmNlIGlmIGFuIG9iamVjdCBoYXMgYSBjb25maWd1cmFibGUgY29sb3Igc3BhY2UgKHNpbmNlIHIxNTIpLlxuICovXG5jb25zdCBoYXNDb2xvclNwYWNlID0gb2JqZWN0ID0+ICdjb2xvclNwYWNlJyBpbiBvYmplY3QgfHwgJ291dHB1dENvbG9yU3BhY2UnIGluIG9iamVjdDtcbi8qKlxuICogVGhlIGN1cnJlbnQgVEhSRUUuQ29sb3JNYW5hZ2VtZW50IGluc3RhbmNlLCBpZiBwcmVzZW50LlxuICovXG5jb25zdCBnZXRDb2xvck1hbmFnZW1lbnQgPSAoKSA9PiB7XG4gIHZhciBfQ29sb3JNYW5hZ2VtZW50O1xuICByZXR1cm4gKF9Db2xvck1hbmFnZW1lbnQgPSBjYXRhbG9ndWUuQ29sb3JNYW5hZ2VtZW50KSAhPSBudWxsID8gX0NvbG9yTWFuYWdlbWVudCA6IG51bGw7XG59O1xuY29uc3QgaXNPcnRob2dyYXBoaWNDYW1lcmEgPSBkZWYgPT4gZGVmICYmIGRlZi5pc09ydGhvZ3JhcGhpY0NhbWVyYTtcbmNvbnN0IGlzUmVmID0gb2JqID0+IG9iaiAmJiBvYmouaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKTtcblxuLyoqXG4gKiBBbiBTU1ItZnJpZW5kbHkgdXNlTGF5b3V0RWZmZWN0LlxuICpcbiAqIFJlYWN0IGN1cnJlbnRseSB0aHJvd3MgYSB3YXJuaW5nIHdoZW4gdXNpbmcgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBzZXJ2ZXIuXG4gKiBUbyBnZXQgYXJvdW5kIGl0LCB3ZSBjYW4gY29uZGl0aW9uYWxseSB1c2VFZmZlY3Qgb24gdGhlIHNlcnZlciAobm8tb3ApIGFuZFxuICogdXNlTGF5b3V0RWZmZWN0IGVsc2V3aGVyZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQ5MjdcbiAqL1xuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICgoX3dpbmRvdyRkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCkgIT0gbnVsbCAmJiBfd2luZG93JGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgfHwgKChfd2luZG93JG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfd2luZG93JG5hdmlnYXRvci5wcm9kdWN0KSA9PT0gJ1JlYWN0TmF0aXZlJykgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG5mdW5jdGlvbiB1c2VNdXRhYmxlQ2FsbGJhY2soZm4pIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKGZuKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB2b2lkIChyZWYuY3VycmVudCA9IGZuKSwgW2ZuXSk7XG4gIHJldHVybiByZWY7XG59XG5mdW5jdGlvbiBCbG9jayh7XG4gIHNldFxufSkge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBzZXQobmV3IFByb21pc2UoKCkgPT4gbnVsbCkpO1xuICAgIHJldHVybiAoKSA9PiBzZXQoZmFsc2UpO1xuICB9LCBbc2V0XSk7XG4gIHJldHVybiBudWxsO1xufVxuY2xhc3MgRXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZXJyb3I6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjb21wb25lbnREaWRDYXRjaChlcnIpIHtcbiAgICB0aGlzLnByb3BzLnNldChlcnIpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5lcnJvciA/IG51bGwgOiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9XG59XG5FcnJvckJvdW5kYXJ5LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9ICgpID0+ICh7XG4gIGVycm9yOiB0cnVlXG59KTtcbmNvbnN0IERFRkFVTFQgPSAnX19kZWZhdWx0JztcbmNvbnN0IERFRkFVTFRTID0gbmV3IE1hcCgpO1xuY29uc3QgaXNEaWZmU2V0ID0gZGVmID0+IGRlZiAmJiAhIWRlZi5tZW1vaXplZCAmJiAhIWRlZi5jaGFuZ2VzO1xuZnVuY3Rpb24gY2FsY3VsYXRlRHByKGRwcikge1xuICB2YXIgX3dpbmRvdyRkZXZpY2VQaXhlbFJhO1xuICAvLyBFcnIgb24gdGhlIHNpZGUgb2YgcHJvZ3Jlc3MgYnkgYXNzdW1pbmcgMnggZHByIGlmIHdlIGNhbid0IGRldGVjdCBpdFxuICAvLyBUaGlzIHdpbGwgaGFwcGVuIGluIHdvcmtlcnMgd2hlcmUgd2luZG93IGlzIGRlZmluZWQgYnV0IGRwciBpc24ndC5cbiAgY29uc3QgdGFyZ2V0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyAoX3dpbmRvdyRkZXZpY2VQaXhlbFJhID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8pICE9IG51bGwgPyBfd2luZG93JGRldmljZVBpeGVsUmEgOiAyIDogMTtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZHByKSA/IE1hdGgubWluKE1hdGgubWF4KGRwclswXSwgdGFyZ2V0KSwgZHByWzFdKSA6IGRwcjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGluc3RhbmNlIHJvb3Qgc3RhdGVcbiAqL1xuY29uc3QgZ2V0Um9vdFN0YXRlID0gb2JqID0+IHtcbiAgdmFyIF9yM2Y7XG4gIHJldHVybiAoX3IzZiA9IG9iai5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9yM2Yucm9vdC5nZXRTdGF0ZSgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnN0YW5jZXMgaW5pdGlhbCAob3V0bW9zdCkgcm9vdFxuICovXG5mdW5jdGlvbiBmaW5kSW5pdGlhbFJvb3QoY2hpbGQpIHtcbiAgbGV0IHJvb3QgPSBjaGlsZC5fX3IzZi5yb290O1xuICB3aGlsZSAocm9vdC5nZXRTdGF0ZSgpLnByZXZpb3VzUm9vdCkgcm9vdCA9IHJvb3QuZ2V0U3RhdGUoKS5wcmV2aW91c1Jvb3Q7XG4gIHJldHVybiByb290O1xufVxuLy8gQSBjb2xsZWN0aW9uIG9mIGNvbXBhcmUgZnVuY3Rpb25zXG5jb25zdCBpcyA9IHtcbiAgb2JqOiBhID0+IGEgPT09IE9iamVjdChhKSAmJiAhaXMuYXJyKGEpICYmIHR5cGVvZiBhICE9PSAnZnVuY3Rpb24nLFxuICBmdW46IGEgPT4gdHlwZW9mIGEgPT09ICdmdW5jdGlvbicsXG4gIHN0cjogYSA9PiB0eXBlb2YgYSA9PT0gJ3N0cmluZycsXG4gIG51bTogYSA9PiB0eXBlb2YgYSA9PT0gJ251bWJlcicsXG4gIGJvbzogYSA9PiB0eXBlb2YgYSA9PT0gJ2Jvb2xlYW4nLFxuICB1bmQ6IGEgPT4gYSA9PT0gdm9pZCAwLFxuICBhcnI6IGEgPT4gQXJyYXkuaXNBcnJheShhKSxcbiAgZXF1KGEsIGIsIHtcbiAgICBhcnJheXMgPSAnc2hhbGxvdycsXG4gICAgb2JqZWN0cyA9ICdyZWZlcmVuY2UnLFxuICAgIHN0cmljdCA9IHRydWVcbiAgfSA9IHt9KSB7XG4gICAgLy8gV3JvbmcgdHlwZSBvciBvbmUgb2YgdGhlIHR3byB1bmRlZmluZWQsIGRvZXNuJ3QgbWF0Y2hcbiAgICBpZiAodHlwZW9mIGEgIT09IHR5cGVvZiBiIHx8ICEhYSAhPT0gISFiKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gQXRvbWljLCBqdXN0IGNvbXBhcmUgYSBhZ2FpbnN0IGJcbiAgICBpZiAoaXMuc3RyKGEpIHx8IGlzLm51bShhKSkgcmV0dXJuIGEgPT09IGI7XG4gICAgY29uc3QgaXNPYmogPSBpcy5vYmooYSk7XG4gICAgaWYgKGlzT2JqICYmIG9iamVjdHMgPT09ICdyZWZlcmVuY2UnKSByZXR1cm4gYSA9PT0gYjtcbiAgICBjb25zdCBpc0FyciA9IGlzLmFycihhKTtcbiAgICBpZiAoaXNBcnIgJiYgYXJyYXlzID09PSAncmVmZXJlbmNlJykgcmV0dXJuIGEgPT09IGI7XG4gICAgLy8gQXJyYXkgb3IgT2JqZWN0LCBzaGFsbG93IGNvbXBhcmUgZmlyc3QgdG8gc2VlIGlmIGl0J3MgYSBtYXRjaFxuICAgIGlmICgoaXNBcnIgfHwgaXNPYmopICYmIGEgPT09IGIpIHJldHVybiB0cnVlO1xuICAgIC8vIExhc3QgcmVzb3J0LCBnbyB0aHJvdWdoIGtleXNcbiAgICBsZXQgaTtcbiAgICAvLyBDaGVjayBpZiBhIGhhcyBhbGwgdGhlIGtleXMgb2YgYlxuICAgIGZvciAoaSBpbiBhKSBpZiAoIShpIGluIGIpKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gQ2hlY2sgaWYgdmFsdWVzIGJldHdlZW4ga2V5cyBtYXRjaFxuICAgIGlmIChpc09iaiAmJiBhcnJheXMgPT09ICdzaGFsbG93JyAmJiBvYmplY3RzID09PSAnc2hhbGxvdycpIHtcbiAgICAgIGZvciAoaSBpbiBzdHJpY3QgPyBiIDogYSkgaWYgKCFpcy5lcXUoYVtpXSwgYltpXSwge1xuICAgICAgICBzdHJpY3QsXG4gICAgICAgIG9iamVjdHM6ICdyZWZlcmVuY2UnXG4gICAgICB9KSkgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgaW4gc3RyaWN0ID8gYiA6IGEpIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIElmIGkgaXMgdW5kZWZpbmVkXG4gICAgaWYgKGlzLnVuZChpKSkge1xuICAgICAgLy8gSWYgYm90aCBhcnJheXMgYXJlIGVtcHR5IHdlIGNvbnNpZGVyIHRoZW0gZXF1YWxcbiAgICAgIGlmIChpc0FyciAmJiBhLmxlbmd0aCA9PT0gMCAmJiBiLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAvLyBJZiBib3RoIG9iamVjdHMgYXJlIGVtcHR5IHdlIGNvbnNpZGVyIHRoZW0gZXF1YWxcbiAgICAgIGlmIChpc09iaiAmJiBPYmplY3Qua2V5cyhhKS5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmtleXMoYikubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgIC8vIE90aGVyd2lzZSBtYXRjaCB0aGVtIGJ5IHZhbHVlXG4gICAgICBpZiAoYSAhPT0gYikgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLyoqXG4gKiBDb2xsZWN0cyBub2RlcyBhbmQgbWF0ZXJpYWxzIGZyb20gYSBUSFJFRS5PYmplY3QzRC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRHcmFwaChvYmplY3QpIHtcbiAgY29uc3QgZGF0YSA9IHtcbiAgICBub2Rlczoge30sXG4gICAgbWF0ZXJpYWxzOiB7fVxuICB9O1xuICBpZiAob2JqZWN0KSB7XG4gICAgb2JqZWN0LnRyYXZlcnNlKG9iaiA9PiB7XG4gICAgICBpZiAob2JqLm5hbWUpIGRhdGEubm9kZXNbb2JqLm5hbWVdID0gb2JqO1xuICAgICAgaWYgKG9iai5tYXRlcmlhbCAmJiAhZGF0YS5tYXRlcmlhbHNbb2JqLm1hdGVyaWFsLm5hbWVdKSBkYXRhLm1hdGVyaWFsc1tvYmoubWF0ZXJpYWwubmFtZV0gPSBvYmoubWF0ZXJpYWw7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8vIERpc3Bvc2VzIGFuIG9iamVjdCBhbmQgYWxsIGl0cyBwcm9wZXJ0aWVzXG5mdW5jdGlvbiBkaXNwb3NlKG9iaikge1xuICBpZiAob2JqLmRpc3Bvc2UgJiYgb2JqLnR5cGUgIT09ICdTY2VuZScpIG9iai5kaXNwb3NlKCk7XG4gIGZvciAoY29uc3QgcCBpbiBvYmopIHtcbiAgICBwLmRpc3Bvc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHAuZGlzcG9zZSgpO1xuICAgIGRlbGV0ZSBvYmpbcF07XG4gIH1cbn1cblxuLy8gRWFjaCBvYmplY3QgaW4gdGhlIHNjZW5lIGNhcnJpZXMgYSBzbWFsbCBMb2NhbFN0YXRlIGRlc2NyaXB0b3JcbmZ1bmN0aW9uIHByZXBhcmUob2JqZWN0LCBzdGF0ZSkge1xuICBjb25zdCBpbnN0YW5jZSA9IG9iamVjdDtcbiAgaW5zdGFuY2UuX19yM2YgPSB7XG4gICAgdHlwZTogJycsXG4gICAgcm9vdDogbnVsbCxcbiAgICBwcmV2aW91c0F0dGFjaDogbnVsbCxcbiAgICBtZW1vaXplZFByb3BzOiB7fSxcbiAgICBldmVudENvdW50OiAwLFxuICAgIGhhbmRsZXJzOiB7fSxcbiAgICBvYmplY3RzOiBbXSxcbiAgICBwYXJlbnQ6IG51bGwsXG4gICAgLi4uc3RhdGVcbiAgfTtcbiAgcmV0dXJuIG9iamVjdDtcbn1cbmZ1bmN0aW9uIHJlc29sdmUoaW5zdGFuY2UsIGtleSkge1xuICBsZXQgdGFyZ2V0ID0gaW5zdGFuY2U7XG4gIGlmIChrZXkuaW5jbHVkZXMoJy0nKSkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBrZXkuc3BsaXQoJy0nKTtcbiAgICBjb25zdCBsYXN0ID0gZW50cmllcy5wb3AoKTtcbiAgICB0YXJnZXQgPSBlbnRyaWVzLnJlZHVjZSgoYWNjLCBrZXkpID0+IGFjY1trZXldLCBpbnN0YW5jZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleTogbGFzdFxuICAgIH07XG4gIH0gZWxzZSByZXR1cm4ge1xuICAgIHRhcmdldCxcbiAgICBrZXlcbiAgfTtcbn1cblxuLy8gQ2hlY2tzIGlmIGEgZGFzaC1jYXNlZCBzdHJpbmcgZW5kcyB3aXRoIGFuIGludGVnZXJcbmNvbnN0IElOREVYX1JFR0VYID0gLy1cXGQrJC87XG5mdW5jdGlvbiBhdHRhY2gocGFyZW50LCBjaGlsZCwgdHlwZSkge1xuICBpZiAoaXMuc3RyKHR5cGUpKSB7XG4gICAgLy8gSWYgYXR0YWNoaW5nIGludG8gYW4gYXJyYXkgKGZvby0wKSwgY3JlYXRlIG9uZVxuICAgIGlmIChJTkRFWF9SRUdFWC50ZXN0KHR5cGUpKSB7XG4gICAgICBjb25zdCByb290ID0gdHlwZS5yZXBsYWNlKElOREVYX1JFR0VYLCAnJyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAga2V5XG4gICAgICB9ID0gcmVzb2x2ZShwYXJlbnQsIHJvb3QpO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRhcmdldFtrZXldKSkgdGFyZ2V0W2tleV0gPSBbXTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0LFxuICAgICAga2V5XG4gICAgfSA9IHJlc29sdmUocGFyZW50LCB0eXBlKTtcbiAgICBjaGlsZC5fX3IzZi5wcmV2aW91c0F0dGFjaCA9IHRhcmdldFtrZXldO1xuICAgIHRhcmdldFtrZXldID0gY2hpbGQ7XG4gIH0gZWxzZSBjaGlsZC5fX3IzZi5wcmV2aW91c0F0dGFjaCA9IHR5cGUocGFyZW50LCBjaGlsZCk7XG59XG5mdW5jdGlvbiBkZXRhY2gocGFyZW50LCBjaGlsZCwgdHlwZSkge1xuICB2YXIgX2NoaWxkJF9fcjNmLCBfY2hpbGQkX19yM2YyO1xuICBpZiAoaXMuc3RyKHR5cGUpKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0LFxuICAgICAga2V5XG4gICAgfSA9IHJlc29sdmUocGFyZW50LCB0eXBlKTtcbiAgICBjb25zdCBwcmV2aW91cyA9IGNoaWxkLl9fcjNmLnByZXZpb3VzQXR0YWNoO1xuICAgIC8vIFdoZW4gdGhlIHByZXZpb3VzIHZhbHVlIHdhcyB1bmRlZmluZWQsIGl0IG1lYW5zIHRoZSB2YWx1ZSB3YXMgbmV2ZXIgc2V0IHRvIGJlZ2luIHdpdGhcbiAgICBpZiAocHJldmlvdXMgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHRhcmdldFtrZXldO1xuICAgIC8vIE90aGVyd2lzZSBzZXQgdGhlIHByZXZpb3VzIHZhbHVlXG4gICAgZWxzZSB0YXJnZXRba2V5XSA9IHByZXZpb3VzO1xuICB9IGVsc2UgKF9jaGlsZCRfX3IzZiA9IGNoaWxkLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX2NoaWxkJF9fcjNmLnByZXZpb3VzQXR0YWNoID09IG51bGwgPyB2b2lkIDAgOiBfY2hpbGQkX19yM2YucHJldmlvdXNBdHRhY2gocGFyZW50LCBjaGlsZCk7XG4gIChfY2hpbGQkX19yM2YyID0gY2hpbGQuX19yM2YpID09IG51bGwgPyB0cnVlIDogZGVsZXRlIF9jaGlsZCRfX3IzZjIucHJldmlvdXNBdHRhY2g7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gcHJlcGFyZXMgYSBzZXQgb2YgY2hhbmdlcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBpbnN0YW5jZVxuZnVuY3Rpb24gZGlmZlByb3BzKGluc3RhbmNlLCB7XG4gIGNoaWxkcmVuOiBjTixcbiAga2V5OiBrTixcbiAgcmVmOiByTixcbiAgLi4ucHJvcHNcbn0sIHtcbiAgY2hpbGRyZW46IGNQLFxuICBrZXk6IGtQLFxuICByZWY6IHJQLFxuICAuLi5wcmV2aW91c1xufSA9IHt9LCByZW1vdmUgPSBmYWxzZSkge1xuICB2YXIgX2luc3RhbmNlJF9fcjNmO1xuICBjb25zdCBsb2NhbFN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZiA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZiA6IHt9O1xuICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMocHJvcHMpO1xuICBjb25zdCBjaGFuZ2VzID0gW107XG5cbiAgLy8gQ2F0Y2ggcmVtb3ZlZCBwcm9wcywgcHJlcGVuZCB0aGVtIHNvIHRoZXkgY2FuIGJlIHJlc2V0IG9yIHJlbW92ZWRcbiAgaWYgKHJlbW92ZSkge1xuICAgIGNvbnN0IHByZXZpb3VzS2V5cyA9IE9iamVjdC5rZXlzKHByZXZpb3VzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZpb3VzS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcmV2aW91c0tleXNbaV0pKSBlbnRyaWVzLnVuc2hpZnQoW3ByZXZpb3VzS2V5c1tpXSwgREVGQVVMVCArICdyZW1vdmUnXSk7XG4gICAgfVxuICB9XG4gIGVudHJpZXMuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgdmFyIF9pbnN0YW5jZSRfX3IzZjI7XG4gICAgLy8gQmFpbCBvdXQgb24gcHJpbWl0aXZlIG9iamVjdFxuICAgIGlmICgoX2luc3RhbmNlJF9fcjNmMiA9IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsICYmIF9pbnN0YW5jZSRfX3IzZjIucHJpbWl0aXZlICYmIGtleSA9PT0gJ29iamVjdCcpIHJldHVybjtcbiAgICAvLyBXaGVuIHByb3BzIG1hdGNoIGJhaWwgb3V0XG4gICAgaWYgKGlzLmVxdSh2YWx1ZSwgcHJldmlvdXNba2V5XSkpIHJldHVybjtcbiAgICAvLyBDb2xsZWN0IGhhbmRsZXJzIGFuZCBiYWlsIG91dFxuICAgIGlmICgvXm9uKFBvaW50ZXJ8Q2xpY2t8RG91YmxlQ2xpY2t8Q29udGV4dE1lbnV8V2hlZWwpLy50ZXN0KGtleSkpIHJldHVybiBjaGFuZ2VzLnB1c2goW2tleSwgdmFsdWUsIHRydWUsIFtdXSk7XG4gICAgLy8gU3BsaXQgZGFzaGVkIHByb3BzXG4gICAgbGV0IGVudHJpZXMgPSBbXTtcbiAgICBpZiAoa2V5LmluY2x1ZGVzKCctJykpIGVudHJpZXMgPSBrZXkuc3BsaXQoJy0nKTtcbiAgICBjaGFuZ2VzLnB1c2goW2tleSwgdmFsdWUsIGZhbHNlLCBlbnRyaWVzXSk7XG5cbiAgICAvLyBSZXNldCBwaWVyY2VkIHByb3BzXG4gICAgZm9yIChjb25zdCBwcm9wIGluIHByb3BzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHByb3BzW3Byb3BdO1xuICAgICAgaWYgKHByb3Auc3RhcnRzV2l0aChgJHtrZXl9LWApKSBjaGFuZ2VzLnB1c2goW3Byb3AsIHZhbHVlLCBmYWxzZSwgcHJvcC5zcGxpdCgnLScpXSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgbWVtb2l6ZWQgPSB7XG4gICAgLi4ucHJvcHNcbiAgfTtcbiAgaWYgKGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcyAmJiBsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMuYXJncykgbWVtb2l6ZWQuYXJncyA9IGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcy5hcmdzO1xuICBpZiAobG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzICYmIGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcy5hdHRhY2gpIG1lbW9pemVkLmF0dGFjaCA9IGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcy5hdHRhY2g7XG4gIHJldHVybiB7XG4gICAgbWVtb2l6ZWQsXG4gICAgY2hhbmdlc1xuICB9O1xufVxuY29uc3QgX19ERVZfXyA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nO1xuXG4vLyBUaGlzIGZ1bmN0aW9uIGFwcGxpZXMgYSBzZXQgb2YgY2hhbmdlcyB0byB0aGUgaW5zdGFuY2VcbmZ1bmN0aW9uIGFwcGx5UHJvcHMkMShpbnN0YW5jZSwgZGF0YSkge1xuICB2YXIgX2luc3RhbmNlJF9fcjNmMywgX3Jvb3QkZ2V0U3RhdGUsIF9pbnN0YW5jZSRfX3IzZjQ7XG4gIC8vIEZpbHRlciBlcXVhbHMsIGV2ZW50cyBhbmQgcmVzZXJ2ZWQgcHJvcHNcbiAgY29uc3QgbG9jYWxTdGF0ZSA9IChfaW5zdGFuY2UkX19yM2YzID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2YzIDoge307XG4gIGNvbnN0IHJvb3QgPSBsb2NhbFN0YXRlLnJvb3Q7XG4gIGNvbnN0IHJvb3RTdGF0ZSA9IChfcm9vdCRnZXRTdGF0ZSA9IHJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3QuZ2V0U3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3QuZ2V0U3RhdGUoKSkgIT0gbnVsbCA/IF9yb290JGdldFN0YXRlIDoge307XG4gIGNvbnN0IHtcbiAgICBtZW1vaXplZCxcbiAgICBjaGFuZ2VzXG4gIH0gPSBpc0RpZmZTZXQoZGF0YSkgPyBkYXRhIDogZGlmZlByb3BzKGluc3RhbmNlLCBkYXRhKTtcbiAgY29uc3QgcHJldkhhbmRsZXJzID0gbG9jYWxTdGF0ZS5ldmVudENvdW50O1xuXG4gIC8vIFByZXBhcmUgbWVtb2l6ZWQgcHJvcHNcbiAgaWYgKGluc3RhbmNlLl9fcjNmKSBpbnN0YW5jZS5fX3IzZi5tZW1vaXplZFByb3BzID0gbWVtb2l6ZWQ7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBba2V5LCB2YWx1ZSwgaXNFdmVudCwga2V5c10gPSBjaGFuZ2VzW2ldO1xuXG4gICAgLy8gQWxpYXMgKG91dHB1dCllbmNvZGluZyA9PiAob3V0cHV0KWNvbG9yU3BhY2UgKHNpbmNlIHIxNTIpXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzI4MjlcbiAgICBpZiAoaGFzQ29sb3JTcGFjZShpbnN0YW5jZSkpIHtcbiAgICAgIGNvbnN0IHNSR0JFbmNvZGluZyA9IDMwMDE7XG4gICAgICBjb25zdCBTUkdCQ29sb3JTcGFjZSA9ICdzcmdiJztcbiAgICAgIGNvbnN0IExpbmVhclNSR0JDb2xvclNwYWNlID0gJ3NyZ2ItbGluZWFyJztcbiAgICAgIGlmIChrZXkgPT09ICdlbmNvZGluZycpIHtcbiAgICAgICAga2V5ID0gJ2NvbG9yU3BhY2UnO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSBzUkdCRW5jb2RpbmcgPyBTUkdCQ29sb3JTcGFjZSA6IExpbmVhclNSR0JDb2xvclNwYWNlO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdvdXRwdXRFbmNvZGluZycpIHtcbiAgICAgICAga2V5ID0gJ291dHB1dENvbG9yU3BhY2UnO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSBzUkdCRW5jb2RpbmcgPyBTUkdCQ29sb3JTcGFjZSA6IExpbmVhclNSR0JDb2xvclNwYWNlO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgY3VycmVudEluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgbGV0IHRhcmdldFByb3AgPSBjdXJyZW50SW5zdGFuY2Vba2V5XTtcblxuICAgIC8vIFJldm9sdmUgZGFzaGVkIHByb3BzXG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICB0YXJnZXRQcm9wID0ga2V5cy5yZWR1Y2UoKGFjYywga2V5KSA9PiBhY2Nba2V5XSwgaW5zdGFuY2UpO1xuICAgICAgLy8gSWYgdGhlIHRhcmdldCBpcyBhdG9taWMsIGl0IGZvcmNlcyB1cyB0byBzd2l0Y2ggdGhlIHJvb3RcbiAgICAgIGlmICghKHRhcmdldFByb3AgJiYgdGFyZ2V0UHJvcC5zZXQpKSB7XG4gICAgICAgIGNvbnN0IFtuYW1lLCAuLi5yZXZlcnNlRW50cmllc10gPSBrZXlzLnJldmVyc2UoKTtcbiAgICAgICAgY3VycmVudEluc3RhbmNlID0gcmV2ZXJzZUVudHJpZXMucmV2ZXJzZSgpLnJlZHVjZSgoYWNjLCBrZXkpID0+IGFjY1trZXldLCBpbnN0YW5jZSk7XG4gICAgICAgIGtleSA9IG5hbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMjEyMDlcbiAgICAvLyBITVIvZmFzdC1yZWZyZXNoIHJlbGllcyBvbiB0aGUgYWJpbGl0eSB0byBjYW5jZWwgb3V0IHByb3BzLCBidXQgdGhyZWVqc1xuICAgIC8vIGhhcyBubyBtZWFucyB0byBkbyB0aGlzLiBIZW5jZSB3ZSBjdXJhdGUgYSBzbWFsbCBjb2xsZWN0aW9uIG9mIHZhbHVlLWNsYXNzZXNcbiAgICAvLyB3aXRoIHRoZWlyIHJlc3BlY3RpdmUgY29uc3RydWN0b3Ivc2V0IGFyZ3VtZW50c1xuICAgIC8vIEZvciByZW1vdmVkIHByb3BzLCB0cnkgdG8gc2V0IGRlZmF1bHQgdmFsdWVzLCBpZiBwb3NzaWJsZVxuICAgIGlmICh2YWx1ZSA9PT0gREVGQVVMVCArICdyZW1vdmUnKSB7XG4gICAgICBpZiAoY3VycmVudEluc3RhbmNlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIGJsYW5rIHNsYXRlIG9mIHRoZSBpbnN0YW5jZSBhbmQgY29weSB0aGUgcGFydGljdWxhciBwYXJhbWV0ZXIuXG4gICAgICAgIGxldCBjdG9yID0gREVGQVVMVFMuZ2V0KGN1cnJlbnRJbnN0YW5jZS5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIGlmICghY3Rvcikge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBjdG9yID0gbmV3IGN1cnJlbnRJbnN0YW5jZS5jb25zdHJ1Y3RvcigpO1xuICAgICAgICAgIERFRkFVTFRTLnNldChjdXJyZW50SW5zdGFuY2UuY29uc3RydWN0b3IsIGN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gY3RvcltrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBjb25zdHJ1Y3RvciwganVzdCBzZXQgaXQgdG8gMFxuICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVhbCB3aXRoIHBvaW50ZXIgZXZlbnRzIC4uLlxuICAgIGlmIChpc0V2ZW50KSB7XG4gICAgICBpZiAodmFsdWUpIGxvY2FsU3RhdGUuaGFuZGxlcnNba2V5XSA9IHZhbHVlO2Vsc2UgZGVsZXRlIGxvY2FsU3RhdGUuaGFuZGxlcnNba2V5XTtcbiAgICAgIGxvY2FsU3RhdGUuZXZlbnRDb3VudCA9IE9iamVjdC5rZXlzKGxvY2FsU3RhdGUuaGFuZGxlcnMpLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gU3BlY2lhbCB0cmVhdG1lbnQgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvciBzZXQvY29weSwgYW5kIGxheWVyc1xuICAgIGVsc2UgaWYgKHRhcmdldFByb3AgJiYgdGFyZ2V0UHJvcC5zZXQgJiYgKHRhcmdldFByb3AuY29weSB8fCB0YXJnZXRQcm9wIGluc3RhbmNlb2YgVEhSRUUuTGF5ZXJzKSkge1xuICAgICAgLy8gSWYgdmFsdWUgaXMgYW4gYXJyYXlcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAodGFyZ2V0UHJvcC5mcm9tQXJyYXkpIHRhcmdldFByb3AuZnJvbUFycmF5KHZhbHVlKTtlbHNlIHRhcmdldFByb3Auc2V0KC4uLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIFRlc3QgYWdhaW4gdGFyZ2V0LmNvcHkoY2xhc3MpIG5leHQgLi4uXG4gICAgICBlbHNlIGlmICh0YXJnZXRQcm9wLmNvcHkgJiYgdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgJiYgKFxuICAgICAgLy8gU29tZSBlbnZpcm9ubWVudHMgbWF5IGJyZWFrIHN0cmljdCBpZGVudGl0eSBjaGVja3MgYnkgZHVwbGljYXRpbmcgdmVyc2lvbnMgb2YgdGhyZWUuanMuXG4gICAgICAvLyBMb29zZW4gdG8gdW5taW5pZmllZCBuYW1lcywgaWdub3JpbmcgZGVzY2VuZGVudHMuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8yODU2XG4gICAgICAvLyBUT0RPOiBmaXggdXBzdHJlYW0gYW5kIHJlbW92ZSBpbiB2OVxuICAgICAgX19ERVZfXyA/IHRhcmdldFByb3AuY29uc3RydWN0b3IubmFtZSA9PT0gdmFsdWUuY29uc3RydWN0b3IubmFtZSA6IHRhcmdldFByb3AuY29uc3RydWN0b3IgPT09IHZhbHVlLmNvbnN0cnVjdG9yKSkge1xuICAgICAgICB0YXJnZXRQcm9wLmNvcHkodmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gSWYgbm90aGluZyBlbHNlIGZpdHMsIGp1c3Qgc2V0IHRoZSBzaW5nbGUgdmFsdWUsIGlnbm9yZSB1bmRlZmluZWRcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzI3NFxuICAgICAgZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBpc0NvbG9yID0gdGFyZ2V0UHJvcCBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yO1xuICAgICAgICAvLyBBbGxvdyBzZXR0aW5nIGFycmF5IHNjYWxhcnNcbiAgICAgICAgaWYgKCFpc0NvbG9yICYmIHRhcmdldFByb3Auc2V0U2NhbGFyKSB0YXJnZXRQcm9wLnNldFNjYWxhcih2YWx1ZSk7XG4gICAgICAgIC8vIExheWVycyBoYXZlIG5vIGNvcHkgZnVuY3Rpb24sIHdlIG11c3QgdGhlcmVmb3JlIGNvcHkgdGhlIG1hc2sgcHJvcGVydHlcbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0UHJvcCBpbnN0YW5jZW9mIFRIUkVFLkxheWVycyAmJiB2YWx1ZSBpbnN0YW5jZW9mIFRIUkVFLkxheWVycykgdGFyZ2V0UHJvcC5tYXNrID0gdmFsdWUubWFzaztcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGp1c3Qgc2V0IC4uLlxuICAgICAgICBlbHNlIHRhcmdldFByb3Auc2V0KHZhbHVlKTtcbiAgICAgICAgLy8gRm9yIHZlcnNpb25zIG9mIHRocmVlIHdoaWNoIGRvbid0IHN1cHBvcnQgVEhSRUUuQ29sb3JNYW5hZ2VtZW50LFxuICAgICAgICAvLyBBdXRvLWNvbnZlcnQgc1JHQiBjb2xvcnNcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMzQ0XG4gICAgICAgIGlmICghZ2V0Q29sb3JNYW5hZ2VtZW50KCkgJiYgIXJvb3RTdGF0ZS5saW5lYXIgJiYgaXNDb2xvcikgdGFyZ2V0UHJvcC5jb252ZXJ0U1JHQlRvTGluZWFyKCk7XG4gICAgICB9XG4gICAgICAvLyBFbHNlLCBqdXN0IG92ZXJ3cml0ZSB0aGUgdmFsdWVcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudEluc3RhbmNlW2tleV0gPSB2YWx1ZTtcblxuICAgICAgLy8gQXV0by1jb252ZXJ0IHNSR0IgdGV4dHVyZXMsIGZvciBub3cgLi4uXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8zNDRcbiAgICAgIGlmIChjdXJyZW50SW5zdGFuY2Vba2V5XSBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgJiZcbiAgICAgIC8vIHNSR0IgdGV4dHVyZXMgbXVzdCBiZSBSR0JBOCBzaW5jZSByMTM3IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yMzEyOVxuICAgICAgY3VycmVudEluc3RhbmNlW2tleV0uZm9ybWF0ID09PSBUSFJFRS5SR0JBRm9ybWF0ICYmIGN1cnJlbnRJbnN0YW5jZVtrZXldLnR5cGUgPT09IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGUpIHtcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IGN1cnJlbnRJbnN0YW5jZVtrZXldO1xuICAgICAgICBpZiAoaGFzQ29sb3JTcGFjZSh0ZXh0dXJlKSAmJiBoYXNDb2xvclNwYWNlKHJvb3RTdGF0ZS5nbCkpIHRleHR1cmUuY29sb3JTcGFjZSA9IHJvb3RTdGF0ZS5nbC5vdXRwdXRDb2xvclNwYWNlO2Vsc2UgdGV4dHVyZS5lbmNvZGluZyA9IHJvb3RTdGF0ZS5nbC5vdXRwdXRFbmNvZGluZztcbiAgICAgIH1cbiAgICB9XG4gICAgaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgfVxuICBpZiAobG9jYWxTdGF0ZS5wYXJlbnQgJiYgaW5zdGFuY2UucmF5Y2FzdCAmJiBwcmV2SGFuZGxlcnMgIT09IGxvY2FsU3RhdGUuZXZlbnRDb3VudCkge1xuICAgIC8vIEdldCB0aGUgaW5pdGlhbCByb290IHN0YXRlJ3MgaW50ZXJuYWxzXG4gICAgY29uc3QgaW50ZXJuYWwgPSBmaW5kSW5pdGlhbFJvb3QoaW5zdGFuY2UpLmdldFN0YXRlKCkuaW50ZXJuYWw7XG4gICAgLy8gUHJlLWVtcHRpdmVseSByZW1vdmUgdGhlIGluc3RhbmNlIGZyb20gdGhlIGludGVyYWN0aW9uIG1hbmFnZXJcbiAgICBjb25zdCBpbmRleCA9IGludGVybmFsLmludGVyYWN0aW9uLmluZGV4T2YoaW5zdGFuY2UpO1xuICAgIGlmIChpbmRleCA+IC0xKSBpbnRlcm5hbC5pbnRlcmFjdGlvbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIC8vIEFkZCB0aGUgaW5zdGFuY2UgdG8gdGhlIGludGVyYWN0aW9uIG1hbmFnZXIgb25seSB3aGVuIGl0IGhhcyBoYW5kbGVyc1xuICAgIGlmIChsb2NhbFN0YXRlLmV2ZW50Q291bnQpIGludGVybmFsLmludGVyYWN0aW9uLnB1c2goaW5zdGFuY2UpO1xuICB9XG5cbiAgLy8gQ2FsbCB0aGUgdXBkYXRlIGxpZmVjeWNsZSB3aGVuIGl0IGlzIGJlaW5nIHVwZGF0ZWQsIGJ1dCBvbmx5IHdoZW4gaXQgaXMgcGFydCBvZiB0aGUgc2NlbmUuXG4gIC8vIFNraXAgdXBkYXRlcyB0byB0aGUgYG9uVXBkYXRlYCBwcm9wIGl0c2VsZlxuICBjb25zdCBpc0NpcmN1bGFyID0gY2hhbmdlcy5sZW5ndGggPT09IDEgJiYgY2hhbmdlc1swXVswXSA9PT0gJ29uVXBkYXRlJztcbiAgaWYgKCFpc0NpcmN1bGFyICYmIGNoYW5nZXMubGVuZ3RoICYmIChfaW5zdGFuY2UkX19yM2Y0ID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgJiYgX2luc3RhbmNlJF9fcjNmNC5wYXJlbnQpIHVwZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKSB7XG4gIHZhciBfaW5zdGFuY2UkX19yM2Y1LCBfaW5zdGFuY2UkX19yM2Y1JHJvb3Q7XG4gIGNvbnN0IHN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZjUgPSBpbnN0YW5jZS5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IChfaW5zdGFuY2UkX19yM2Y1JHJvb3QgPSBfaW5zdGFuY2UkX19yM2Y1LnJvb3QpID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2UkX19yM2Y1JHJvb3QuZ2V0U3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRfX3IzZjUkcm9vdC5nZXRTdGF0ZSgpO1xuICBpZiAoc3RhdGUgJiYgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID09PSAwKSBzdGF0ZS5pbnZhbGlkYXRlKCk7XG59XG5mdW5jdGlvbiB1cGRhdGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5vblVwZGF0ZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2Uub25VcGRhdGUoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FtZXJhKGNhbWVyYSwgc2l6ZSkge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy85MlxuICAvLyBEbyBub3QgbWVzcyB3aXRoIHRoZSBjYW1lcmEgaWYgaXQgYmVsb25ncyB0byB0aGUgdXNlclxuICBpZiAoIWNhbWVyYS5tYW51YWwpIHtcbiAgICBpZiAoaXNPcnRob2dyYXBoaWNDYW1lcmEoY2FtZXJhKSkge1xuICAgICAgY2FtZXJhLmxlZnQgPSBzaXplLndpZHRoIC8gLTI7XG4gICAgICBjYW1lcmEucmlnaHQgPSBzaXplLndpZHRoIC8gMjtcbiAgICAgIGNhbWVyYS50b3AgPSBzaXplLmhlaWdodCAvIDI7XG4gICAgICBjYW1lcmEuYm90dG9tID0gc2l6ZS5oZWlnaHQgLyAtMjtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FtZXJhLmFzcGVjdCA9IHNpemUud2lkdGggLyBzaXplLmhlaWdodDtcbiAgICB9XG4gICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8xNzhcbiAgICAvLyBVcGRhdGUgbWF0cml4IHdvcmxkIHNpbmNlIHRoZSByZW5kZXJlciBpcyBhIGZyYW1lIGxhdGVcbiAgICBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlSWQoZXZlbnQpIHtcbiAgcmV0dXJuIChldmVudC5ldmVudE9iamVjdCB8fCBldmVudC5vYmplY3QpLnV1aWQgKyAnLycgKyBldmVudC5pbmRleCArIGV2ZW50Lmluc3RhbmNlSWQ7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC90cmVlL21haW4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlciNnZXRjdXJyZW50ZXZlbnRwcmlvcml0eVxuLy8gR2l2ZXMgUmVhY3QgYSBjbHVlIGFzIHRvIGhvdyBpbXBvcnQgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpb24gaXNcbmZ1bmN0aW9uIGdldEV2ZW50UHJpb3JpdHkoKSB7XG4gIHZhciBfZ2xvYmFsU2NvcGUkZXZlbnQ7XG4gIC8vIEdldCBhIGhhbmRsZSB0byB0aGUgY3VycmVudCBnbG9iYWwgc2NvcGUgaW4gd2luZG93IGFuZCB3b3JrZXIgY29udGV4dHMgaWYgYWJsZVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjQ5M1xuICBjb25zdCBnbG9iYWxTY29wZSA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIHx8IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdztcbiAgaWYgKCFnbG9iYWxTY29wZSkgcmV0dXJuIERlZmF1bHRFdmVudFByaW9yaXR5O1xuICBjb25zdCBuYW1lID0gKF9nbG9iYWxTY29wZSRldmVudCA9IGdsb2JhbFNjb3BlLmV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2dsb2JhbFNjb3BlJGV2ZW50LnR5cGU7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ2NsaWNrJzpcbiAgICBjYXNlICdjb250ZXh0bWVudSc6XG4gICAgY2FzZSAnZGJsY2xpY2snOlxuICAgIGNhc2UgJ3BvaW50ZXJjYW5jZWwnOlxuICAgIGNhc2UgJ3BvaW50ZXJkb3duJzpcbiAgICBjYXNlICdwb2ludGVydXAnOlxuICAgICAgcmV0dXJuIERpc2NyZXRlRXZlbnRQcmlvcml0eTtcbiAgICBjYXNlICdwb2ludGVybW92ZSc6XG4gICAgY2FzZSAncG9pbnRlcm91dCc6XG4gICAgY2FzZSAncG9pbnRlcm92ZXInOlxuICAgIGNhc2UgJ3BvaW50ZXJlbnRlcic6XG4gICAgY2FzZSAncG9pbnRlcmxlYXZlJzpcbiAgICBjYXNlICd3aGVlbCc6XG4gICAgICByZXR1cm4gQ29udGludW91c0V2ZW50UHJpb3JpdHk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbGVhc2UgcG9pbnRlciBjYXB0dXJlcy5cbiAqIFRoaXMgaXMgY2FsbGVkIGJ5IHJlbGVhc2VQb2ludGVyQ2FwdHVyZSBpbiB0aGUgQVBJLCBhbmQgd2hlbiBhbiBvYmplY3QgaXMgcmVtb3ZlZC5cbiAqL1xuZnVuY3Rpb24gcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoY2FwdHVyZWRNYXAsIG9iaiwgY2FwdHVyZXMsIHBvaW50ZXJJZCkge1xuICBjb25zdCBjYXB0dXJlRGF0YSA9IGNhcHR1cmVzLmdldChvYmopO1xuICBpZiAoY2FwdHVyZURhdGEpIHtcbiAgICBjYXB0dXJlcy5kZWxldGUob2JqKTtcbiAgICAvLyBJZiB0aGlzIHdhcyB0aGUgbGFzdCBjYXB0dXJpbmcgb2JqZWN0IGZvciB0aGlzIHBvaW50ZXJcbiAgICBpZiAoY2FwdHVyZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgY2FwdHVyZWRNYXAuZGVsZXRlKHBvaW50ZXJJZCk7XG4gICAgICBjYXB0dXJlRGF0YS50YXJnZXQucmVsZWFzZVBvaW50ZXJDYXB0dXJlKHBvaW50ZXJJZCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZW1vdmVJbnRlcmFjdGl2aXR5KHN0b3JlLCBvYmplY3QpIHtcbiAgY29uc3Qge1xuICAgIGludGVybmFsXG4gIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAvLyBSZW1vdmVzIGV2ZXJ5IHRyYWNlIG9mIGFuIG9iamVjdCBmcm9tIHRoZSBkYXRhIHN0b3JlXG4gIGludGVybmFsLmludGVyYWN0aW9uID0gaW50ZXJuYWwuaW50ZXJhY3Rpb24uZmlsdGVyKG8gPT4gbyAhPT0gb2JqZWN0KTtcbiAgaW50ZXJuYWwuaW5pdGlhbEhpdHMgPSBpbnRlcm5hbC5pbml0aWFsSGl0cy5maWx0ZXIobyA9PiBvICE9PSBvYmplY3QpO1xuICBpbnRlcm5hbC5ob3ZlcmVkLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAodmFsdWUuZXZlbnRPYmplY3QgPT09IG9iamVjdCB8fCB2YWx1ZS5vYmplY3QgPT09IG9iamVjdCkge1xuICAgICAgLy8gQ2xlYXIgb3V0IGludGVyc2VjdHMsIHRoZXkgYXJlIG91dGRhdGVkIGJ5IG5vd1xuICAgICAgaW50ZXJuYWwuaG92ZXJlZC5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH0pO1xuICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5mb3JFYWNoKChjYXB0dXJlcywgcG9pbnRlcklkKSA9PiB7XG4gICAgcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoaW50ZXJuYWwuY2FwdHVyZWRNYXAsIG9iamVjdCwgY2FwdHVyZXMsIHBvaW50ZXJJZCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRXZlbnRzKHN0b3JlKSB7XG4gIC8qKiBDYWxjdWxhdGVzIGRlbHRhICovXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJuYWxcbiAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBkeCA9IGV2ZW50Lm9mZnNldFggLSBpbnRlcm5hbC5pbml0aWFsQ2xpY2tbMF07XG4gICAgY29uc3QgZHkgPSBldmVudC5vZmZzZXRZIC0gaW50ZXJuYWwuaW5pdGlhbENsaWNrWzFdO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkpO1xuICB9XG5cbiAgLyoqIFJldHVybnMgdHJ1ZSBpZiBhbiBpbnN0YW5jZSBoYXMgYSB2YWxpZCBwb2ludGVyLWV2ZW50IHJlZ2lzdGVyZWQsIHRoaXMgZXhjbHVkZXMgc2Nyb2xsLCBjbGlja3MgZXRjICovXG4gIGZ1bmN0aW9uIGZpbHRlclBvaW50ZXJFdmVudHMob2JqZWN0cykge1xuICAgIHJldHVybiBvYmplY3RzLmZpbHRlcihvYmogPT4gWydNb3ZlJywgJ092ZXInLCAnRW50ZXInLCAnT3V0JywgJ0xlYXZlJ10uc29tZShuYW1lID0+IHtcbiAgICAgIHZhciBfcjNmO1xuICAgICAgcmV0dXJuIChfcjNmID0gb2JqLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3IzZi5oYW5kbGVyc1snb25Qb2ludGVyJyArIG5hbWVdO1xuICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiBpbnRlcnNlY3QoZXZlbnQsIGZpbHRlcikge1xuICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBkdXBsaWNhdGVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGludGVyc2VjdGlvbnMgPSBbXTtcbiAgICAvLyBBbGxvdyBjYWxsZXJzIHRvIGVsaW1pbmF0ZSBldmVudCBvYmplY3RzXG4gICAgY29uc3QgZXZlbnRzT2JqZWN0cyA9IGZpbHRlciA/IGZpbHRlcihzdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbikgOiBzdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbjtcbiAgICAvLyBSZXNldCBhbGwgcmF5Y2FzdGVyIGNhbWVyYXMgdG8gdW5kZWZpbmVkXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHNPYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGdldFJvb3RTdGF0ZShldmVudHNPYmplY3RzW2ldKTtcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN0YXRlLnByZXZpb3VzUm9vdCkge1xuICAgICAgLy8gTWFrZSBzdXJlIHJvb3QtbGV2ZWwgcG9pbnRlciBhbmQgcmF5IGFyZSBzZXQgdXBcbiAgICAgIHN0YXRlLmV2ZW50cy5jb21wdXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29tcHV0ZShldmVudCwgc3RhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVSYXljYXN0KG9iaikge1xuICAgICAgY29uc3Qgc3RhdGUgPSBnZXRSb290U3RhdGUob2JqKTtcbiAgICAgIC8vIFNraXAgZXZlbnQgaGFuZGxpbmcgd2hlbiBub0V2ZW50cyBpcyBzZXQsIG9yIHdoZW4gdGhlIHJheWNhc3RlcnMgY2FtZXJhIGlzIG51bGxcbiAgICAgIGlmICghc3RhdGUgfHwgIXN0YXRlLmV2ZW50cy5lbmFibGVkIHx8IHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPT09IG51bGwpIHJldHVybiBbXTtcblxuICAgICAgLy8gV2hlbiB0aGUgY2FtZXJhIGlzIHVuZGVmaW5lZCB3ZSBoYXZlIHRvIGNhbGwgdGhlIGV2ZW50IGxheWVycyB1cGRhdGUgZnVuY3Rpb25cbiAgICAgIGlmIChzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIF9zdGF0ZSRwcmV2aW91c1Jvb3Q7XG4gICAgICAgIHN0YXRlLmV2ZW50cy5jb21wdXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29tcHV0ZShldmVudCwgc3RhdGUsIChfc3RhdGUkcHJldmlvdXNSb290ID0gc3RhdGUucHJldmlvdXNSb290KSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJHByZXZpb3VzUm9vdC5nZXRTdGF0ZSgpKTtcbiAgICAgICAgLy8gSWYgdGhlIGNhbWVyYSBpcyBzdGlsbCB1bmRlZmluZWQgd2UgaGF2ZSB0byBza2lwIHRoaXMgbGF5ZXIgZW50aXJlbHlcbiAgICAgICAgaWYgKHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPT09IHVuZGVmaW5lZCkgc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVyc2VjdCBvYmplY3QgYnkgb2JqZWN0XG4gICAgICByZXR1cm4gc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA/IHN0YXRlLnJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3Qob2JqLCB0cnVlKSA6IFtdO1xuICAgIH1cblxuICAgIC8vIENvbGxlY3QgZXZlbnRzXG4gICAgbGV0IGhpdHMgPSBldmVudHNPYmplY3RzXG4gICAgLy8gSW50ZXJzZWN0IG9iamVjdHNcbiAgICAuZmxhdE1hcChoYW5kbGVSYXljYXN0KVxuICAgIC8vIFNvcnQgYnkgZXZlbnQgcHJpb3JpdHkgYW5kIGRpc3RhbmNlXG4gICAgLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGFTdGF0ZSA9IGdldFJvb3RTdGF0ZShhLm9iamVjdCk7XG4gICAgICBjb25zdCBiU3RhdGUgPSBnZXRSb290U3RhdGUoYi5vYmplY3QpO1xuICAgICAgaWYgKCFhU3RhdGUgfHwgIWJTdGF0ZSkgcmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuICAgICAgcmV0dXJuIGJTdGF0ZS5ldmVudHMucHJpb3JpdHkgLSBhU3RhdGUuZXZlbnRzLnByaW9yaXR5IHx8IGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuICAgIH0pXG4gICAgLy8gRmlsdGVyIG91dCBkdXBsaWNhdGVzXG4gICAgLmZpbHRlcihpdGVtID0+IHtcbiAgICAgIGNvbnN0IGlkID0gbWFrZUlkKGl0ZW0pO1xuICAgICAgaWYgKGR1cGxpY2F0ZXMuaGFzKGlkKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgZHVwbGljYXRlcy5hZGQoaWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8xNjAzMVxuICAgIC8vIEFsbG93IGN1c3RvbSB1c2VybGFuZCBpbnRlcnNlY3Qgc29ydCBvcmRlciwgdGhpcyBsaWtlbHkgb25seSBtYWtlcyBzZW5zZSBvbiB0aGUgcm9vdCBmaWx0ZXJcbiAgICBpZiAoc3RhdGUuZXZlbnRzLmZpbHRlcikgaGl0cyA9IHN0YXRlLmV2ZW50cy5maWx0ZXIoaGl0cywgc3RhdGUpO1xuXG4gICAgLy8gQnViYmxlIHVwIHRoZSBldmVudHMsIGZpbmQgdGhlIGV2ZW50IHNvdXJjZSAoZXZlbnRPYmplY3QpXG4gICAgZm9yIChjb25zdCBoaXQgb2YgaGl0cykge1xuICAgICAgbGV0IGV2ZW50T2JqZWN0ID0gaGl0Lm9iamVjdDtcbiAgICAgIC8vIEJ1YmJsZSBldmVudCB1cFxuICAgICAgd2hpbGUgKGV2ZW50T2JqZWN0KSB7XG4gICAgICAgIHZhciBfcjNmMjtcbiAgICAgICAgaWYgKChfcjNmMiA9IGV2ZW50T2JqZWN0Ll9fcjNmKSAhPSBudWxsICYmIF9yM2YyLmV2ZW50Q291bnQpIGludGVyc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgLi4uaGl0LFxuICAgICAgICAgIGV2ZW50T2JqZWN0XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudE9iamVjdCA9IGV2ZW50T2JqZWN0LnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgaW50ZXJhY3Rpb24gaXMgY2FwdHVyZWQsIG1ha2UgYWxsIGNhcHR1cmluZyB0YXJnZXRzIHBhcnQgb2YgdGhlIGludGVyc2VjdC5cbiAgICBpZiAoJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgc3RhdGUuaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgIGZvciAobGV0IGNhcHR1cmVEYXRhIG9mIHN0YXRlLmludGVybmFsLmNhcHR1cmVkTWFwLmdldChldmVudC5wb2ludGVySWQpLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICghZHVwbGljYXRlcy5oYXMobWFrZUlkKGNhcHR1cmVEYXRhLmludGVyc2VjdGlvbikpKSBpbnRlcnNlY3Rpb25zLnB1c2goY2FwdHVyZURhdGEuaW50ZXJzZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH1cblxuICAvKiogIEhhbmRsZXMgaW50ZXJzZWN0aW9ucyBieSBmb3J3YXJkaW5nIHRoZW0gdG8gaGFuZGxlcnMgKi9cbiAgZnVuY3Rpb24gaGFuZGxlSW50ZXJzZWN0cyhpbnRlcnNlY3Rpb25zLCBldmVudCwgZGVsdGEsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgcm9vdFN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgIC8vIElmIGFueXRoaW5nIGhhcyBiZWVuIGZvdW5kLCBmb3J3YXJkIGl0IHRvIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSB7XG4gICAgICAgIHN0b3BwZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgZm9yIChjb25zdCBoaXQgb2YgaW50ZXJzZWN0aW9ucykge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldFJvb3RTdGF0ZShoaXQub2JqZWN0KSB8fCByb290U3RhdGU7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICByYXljYXN0ZXIsXG4gICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICBjYW1lcmEsXG4gICAgICAgICAgaW50ZXJuYWxcbiAgICAgICAgfSA9IHN0YXRlO1xuICAgICAgICBjb25zdCB1bnByb2plY3RlZFBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjMocG9pbnRlci54LCBwb2ludGVyLnksIDApLnVucHJvamVjdChjYW1lcmEpO1xuICAgICAgICBjb25zdCBoYXNQb2ludGVyQ2FwdHVyZSA9IGlkID0+IHtcbiAgICAgICAgICB2YXIgX2ludGVybmFsJGNhcHR1cmVkTWFwLCBfaW50ZXJuYWwkY2FwdHVyZWRNYXAyO1xuICAgICAgICAgIHJldHVybiAoX2ludGVybmFsJGNhcHR1cmVkTWFwID0gKF9pbnRlcm5hbCRjYXB0dXJlZE1hcDIgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX2ludGVybmFsJGNhcHR1cmVkTWFwMi5oYXMoaGl0LmV2ZW50T2JqZWN0KSkgIT0gbnVsbCA/IF9pbnRlcm5hbCRjYXB0dXJlZE1hcCA6IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzZXRQb2ludGVyQ2FwdHVyZSA9IGlkID0+IHtcbiAgICAgICAgICBjb25zdCBjYXB0dXJlRGF0YSA9IHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvbjogaGl0LFxuICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChpbnRlcm5hbC5jYXB0dXJlZE1hcC5oYXMoaWQpKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgcG9pbnRlcklkIHdhcyBwcmV2aW91c2x5IGNhcHR1cmVkLCB3ZSBhZGQgdGhlIGhpdCB0byB0aGVcbiAgICAgICAgICAgIC8vIGV2ZW50IGNhcHR1cmVkTWFwLlxuICAgICAgICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGlkKS5zZXQoaGl0LmV2ZW50T2JqZWN0LCBjYXB0dXJlRGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwb2ludGVySWQgd2FzIG5vdCBwcmV2aW91c2x5IGNhcHR1cmVkLCB3ZSBjcmVhdGUgYSBtYXBcbiAgICAgICAgICAgIC8vIGNvbnRhaW5pbmcgdGhlIGhpdE9iamVjdCwgYW5kIHRoZSBoaXQuIGhpdE9iamVjdCBpcyB1c2VkIGZvclxuICAgICAgICAgICAgLy8gZmFzdGVyIGFjY2Vzcy5cbiAgICAgICAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLnNldChpZCwgbmV3IE1hcChbW2hpdC5ldmVudE9iamVjdCwgY2FwdHVyZURhdGFdXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBldmVudC50YXJnZXQuc2V0UG9pbnRlckNhcHR1cmUoaWQpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZWxlYXNlUG9pbnRlckNhcHR1cmUgPSBpZCA9PiB7XG4gICAgICAgICAgY29uc3QgY2FwdHVyZXMgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoaWQpO1xuICAgICAgICAgIGlmIChjYXB0dXJlcykge1xuICAgICAgICAgICAgcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoaW50ZXJuYWwuY2FwdHVyZWRNYXAsIGhpdC5ldmVudE9iamVjdCwgY2FwdHVyZXMsIGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWRkIG5hdGl2ZSBldmVudCBwcm9wc1xuICAgICAgICBsZXQgZXh0cmFjdEV2ZW50UHJvcHMgPSB7fTtcbiAgICAgICAgLy8gVGhpcyBpdGVyYXRlcyBvdmVyIHRoZSBldmVudCdzIHByb3BlcnRpZXMgaW5jbHVkaW5nIHRoZSBpbmhlcml0ZWQgb25lcy4gTmF0aXZlIFBvaW50ZXJFdmVudHMgaGF2ZSBtb3N0IG9mIHRoZWlyIHByb3BzIGFzIGdldHRlcnMgd2hpY2ggYXJlIGluaGVyaXRlZCwgYnV0IHBvbHlmaWxsZWQgUG9pbnRlckV2ZW50cyBoYXZlIHRoZW0gYWxsIGFzIHRoZWlyIG93biBwcm9wZXJ0aWVzIChpLmUuIG5vdCBpbmhlcml0ZWQpLiBXZSBjYW4ndCB1c2UgT2JqZWN0LmtleXMoKSBvciBPYmplY3QuZW50cmllcygpIGFzIHRoZXkgb25seSByZXR1cm4gXCJvd25cIiBwcm9wZXJ0aWVzOyBub3IgT2JqZWN0LmdldFByb3RvdHlwZU9mKGV2ZW50KSBhcyB0aGF0ICpkb2Vzbid0KiByZXR1cm4gXCJvd25cIiBwcm9wZXJ0aWVzLCBvbmx5IGluaGVyaXRlZCBvbmVzLlxuICAgICAgICBmb3IgKGxldCBwcm9wIGluIGV2ZW50KSB7XG4gICAgICAgICAgbGV0IHByb3BlcnR5ID0gZXZlbnRbcHJvcF07XG4gICAgICAgICAgLy8gT25seSBjb3B5IG92ZXIgYXRvbWljcywgbGVhdmUgZnVuY3Rpb25zIGFsb25lIGFzIHRoZXNlIHNob3VsZCBiZVxuICAgICAgICAgIC8vIGNhbGxlZCBhcyBldmVudC5uYXRpdmVFdmVudC5mbigpXG4gICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJykgZXh0cmFjdEV2ZW50UHJvcHNbcHJvcF0gPSBwcm9wZXJ0eTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmF5Y2FzdEV2ZW50ID0ge1xuICAgICAgICAgIC4uLmhpdCxcbiAgICAgICAgICAuLi5leHRyYWN0RXZlbnRQcm9wcyxcbiAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgIGludGVyc2VjdGlvbnMsXG4gICAgICAgICAgc3RvcHBlZDogbG9jYWxTdGF0ZS5zdG9wcGVkLFxuICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgIHVucHJvamVjdGVkUG9pbnQsXG4gICAgICAgICAgcmF5OiByYXljYXN0ZXIucmF5LFxuICAgICAgICAgIGNhbWVyYTogY2FtZXJhLFxuICAgICAgICAgIC8vIEhpamFjayBzdG9wUHJvcGFnYXRpb24sIHdoaWNoIGp1c3Qgc2V0cyBhIGZsYWdcbiAgICAgICAgICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy81OTZcbiAgICAgICAgICAgIC8vIEV2ZW50cyBhcmUgbm90IGFsbG93ZWQgdG8gc3RvcCBwcm9wYWdhdGlvbiBpZiB0aGUgcG9pbnRlciBoYXMgYmVlbiBjYXB0dXJlZFxuICAgICAgICAgICAgY29uc3QgY2FwdHVyZXNGb3JQb2ludGVyID0gJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGV2ZW50LnBvaW50ZXJJZCk7XG5cbiAgICAgICAgICAgIC8vIFdlIG9ubHkgYXV0aG9yaXplIHN0b3BQcm9wYWdhdGlvbi4uLlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gLi4uaWYgdGhpcyBwb2ludGVyIGhhc24ndCBiZWVuIGNhcHR1cmVkXG4gICAgICAgICAgICAhY2FwdHVyZXNGb3JQb2ludGVyIHx8XG4gICAgICAgICAgICAvLyAuLi4gb3IgaWYgdGhlIGhpdCBvYmplY3QgaXMgY2FwdHVyaW5nIHRoZSBwb2ludGVyXG4gICAgICAgICAgICBjYXB0dXJlc0ZvclBvaW50ZXIuaGFzKGhpdC5ldmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgcmF5Y2FzdEV2ZW50LnN0b3BwZWQgPSBsb2NhbFN0YXRlLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAvLyBQcm9wYWdhdGlvbiBpcyBzdG9wcGVkLCByZW1vdmUgYWxsIG90aGVyIGhvdmVyIHJlY29yZHNcbiAgICAgICAgICAgICAgLy8gQW4gZXZlbnQgaGFuZGxlciBpcyBvbmx5IGFsbG93ZWQgdG8gZmx1c2ggb3RoZXIgaGFuZGxlcnMgaWYgaXQgaXMgaG92ZXJlZCBpdHNlbGZcbiAgICAgICAgICAgICAgaWYgKGludGVybmFsLmhvdmVyZWQuc2l6ZSAmJiBBcnJheS5mcm9tKGludGVybmFsLmhvdmVyZWQudmFsdWVzKCkpLmZpbmQoaSA9PiBpLmV2ZW50T2JqZWN0ID09PSBoaXQuZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgLy8gT2JqZWN0cyBjYW5ub3QgZmx1c2ggb3V0IGhpZ2hlciB1cCBvYmplY3RzIHRoYXQgaGF2ZSBhbHJlYWR5IGNhdWdodCB0aGUgZXZlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBoaWdoZXIgPSBpbnRlcnNlY3Rpb25zLnNsaWNlKDAsIGludGVyc2VjdGlvbnMuaW5kZXhPZihoaXQpKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxQb2ludGVyKFsuLi5oaWdoZXIsIGhpdF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAvLyB0aGVyZSBzaG91bGQgYmUgYSBkaXN0aW5jdGlvbiBiZXR3ZWVuIHRhcmdldCBhbmQgY3VycmVudFRhcmdldFxuICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgaGFzUG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICBzZXRQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgIHJlbGVhc2VQb2ludGVyQ2FwdHVyZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY3VycmVudFRhcmdldDoge1xuICAgICAgICAgICAgaGFzUG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICBzZXRQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgIHJlbGVhc2VQb2ludGVyQ2FwdHVyZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2FsbCBzdWJzY3JpYmVyc1xuICAgICAgICBjYWxsYmFjayhyYXljYXN0RXZlbnQpO1xuICAgICAgICAvLyBFdmVudCBidWJibGluZyBtYXkgYmUgaW50ZXJydXB0ZWQgYnkgc3RvcFByb3BhZ2F0aW9uXG4gICAgICAgIGlmIChsb2NhbFN0YXRlLnN0b3BwZWQgPT09IHRydWUpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgfVxuICBmdW5jdGlvbiBjYW5jZWxQb2ludGVyKGludGVyc2VjdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbnRlcm5hbFxuICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGZvciAoY29uc3QgaG92ZXJlZE9iaiBvZiBpbnRlcm5hbC5ob3ZlcmVkLnZhbHVlcygpKSB7XG4gICAgICAvLyBXaGVuIG5vIG9iamVjdHMgd2VyZSBoaXQgb3IgdGhlIHRoZSBob3ZlcmVkIG9iamVjdCB3YXNuJ3QgZm91bmQgdW5kZXJuZWF0aCB0aGUgY3Vyc29yXG4gICAgICAvLyB3ZSBjYWxsIG9uUG9pbnRlck91dCBhbmQgZGVsZXRlIHRoZSBvYmplY3QgZnJvbSB0aGUgaG92ZXJlZC1lbGVtZW50cyBtYXBcbiAgICAgIGlmICghaW50ZXJzZWN0aW9ucy5sZW5ndGggfHwgIWludGVyc2VjdGlvbnMuZmluZChoaXQgPT4gaGl0Lm9iamVjdCA9PT0gaG92ZXJlZE9iai5vYmplY3QgJiYgaGl0LmluZGV4ID09PSBob3ZlcmVkT2JqLmluZGV4ICYmIGhpdC5pbnN0YW5jZUlkID09PSBob3ZlcmVkT2JqLmluc3RhbmNlSWQpKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50T2JqZWN0ID0gaG92ZXJlZE9iai5ldmVudE9iamVjdDtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBldmVudE9iamVjdC5fX3IzZjtcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuaGFuZGxlcnM7XG4gICAgICAgIGludGVybmFsLmhvdmVyZWQuZGVsZXRlKG1ha2VJZChob3ZlcmVkT2JqKSk7XG4gICAgICAgIGlmIChpbnN0YW5jZSAhPSBudWxsICYmIGluc3RhbmNlLmV2ZW50Q291bnQpIHtcbiAgICAgICAgICAvLyBDbGVhciBvdXQgaW50ZXJzZWN0cywgdGhleSBhcmUgb3V0ZGF0ZWQgYnkgbm93XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIC4uLmhvdmVyZWRPYmosXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25zXG4gICAgICAgICAgfTtcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJPdXQgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlck91dChkYXRhKTtcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJMZWF2ZSA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyTGVhdmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlck1pc3NlZChldmVudCwgb2JqZWN0cykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBvYmplY3RzW2ldLl9fcjNmO1xuICAgICAgaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmhhbmRsZXJzLm9uUG9pbnRlck1pc3NlZCA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuaGFuZGxlcnMub25Qb2ludGVyTWlzc2VkKGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlUG9pbnRlcihuYW1lKSB7XG4gICAgLy8gRGVhbCB3aXRoIGNhbmNlbGF0aW9uXG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdvblBvaW50ZXJMZWF2ZSc6XG4gICAgICBjYXNlICdvblBvaW50ZXJDYW5jZWwnOlxuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsUG9pbnRlcihbXSk7XG4gICAgICBjYXNlICdvbkxvc3RQb2ludGVyQ2FwdHVyZSc6XG4gICAgICAgIHJldHVybiBldmVudCA9PiB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaW50ZXJuYWxcbiAgICAgICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBpZiAoJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgZXZlbnQgaW50ZXJmYWNlIGhhZCBvbkxvc3RQb2ludGVyQ2FwdHVyZSwgd2UnZCBjYWxsIGl0IGhlcmUgb24gZXZlcnlcbiAgICAgICAgICAgIC8vIG9iamVjdCB0aGF0J3MgZ2V0dGluZyByZW1vdmVkLiBXZSBjYWxsIGl0IG9uIHRoZSBuZXh0IGZyYW1lIGJlY2F1c2Ugb25Mb3N0UG9pbnRlckNhcHR1cmVcbiAgICAgICAgICAgIC8vIGZpcmVzIGJlZm9yZSBvblBvaW50ZXJVcC4gT3RoZXJ3aXNlIHBvaW50ZXJVcCB3b3VsZCBuZXZlciBiZSBjYWxsZWQgaWYgdGhlIGV2ZW50IGRpZG4ndFxuICAgICAgICAgICAgLy8gaGFwcGVuIGluIHRoZSBvYmplY3QgaXQgb3JpZ2luYXRlZCBmcm9tLCBsZWF2aW5nIGNvbXBvbmVudHMgaW4gYSBpbi1iZXR3ZWVuIHN0YXRlLlxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgLy8gT25seSByZWxlYXNlIGlmIHBvaW50ZXItdXAgZGlkbid0IGRvIGl0IGFscmVhZHlcbiAgICAgICAgICAgICAgaWYgKGludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhldmVudC5wb2ludGVySWQpKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZGVsZXRlKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICAgICAgY2FuY2VsUG9pbnRlcihbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBBbnkgb3RoZXIgcG9pbnRlciBnb2VzIGhlcmUgLi4uXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uUG9pbnRlck1pc3NlZCxcbiAgICAgICAgaW50ZXJuYWxcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICAvLyBwcmVwYXJlUmF5KGV2ZW50KVxuICAgICAgaW50ZXJuYWwubGFzdEV2ZW50LmN1cnJlbnQgPSBldmVudDtcblxuICAgICAgLy8gR2V0IGZyZXNoIGludGVyc2VjdHNcbiAgICAgIGNvbnN0IGlzUG9pbnRlck1vdmUgPSBuYW1lID09PSAnb25Qb2ludGVyTW92ZSc7XG4gICAgICBjb25zdCBpc0NsaWNrRXZlbnQgPSBuYW1lID09PSAnb25DbGljaycgfHwgbmFtZSA9PT0gJ29uQ29udGV4dE1lbnUnIHx8IG5hbWUgPT09ICdvbkRvdWJsZUNsaWNrJztcbiAgICAgIGNvbnN0IGZpbHRlciA9IGlzUG9pbnRlck1vdmUgPyBmaWx0ZXJQb2ludGVyRXZlbnRzIDogdW5kZWZpbmVkO1xuICAgICAgY29uc3QgaGl0cyA9IGludGVyc2VjdChldmVudCwgZmlsdGVyKTtcbiAgICAgIGNvbnN0IGRlbHRhID0gaXNDbGlja0V2ZW50ID8gY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpIDogMDtcblxuICAgICAgLy8gU2F2ZSBpbml0aWFsIGNvb3JkaW5hdGVzIG9uIHBvaW50ZXItZG93blxuICAgICAgaWYgKG5hbWUgPT09ICdvblBvaW50ZXJEb3duJykge1xuICAgICAgICBpbnRlcm5hbC5pbml0aWFsQ2xpY2sgPSBbZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WV07XG4gICAgICAgIGludGVybmFsLmluaXRpYWxIaXRzID0gaGl0cy5tYXAoaGl0ID0+IGhpdC5ldmVudE9iamVjdCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGEgY2xpY2sgeWllbGRzIG5vIHJlc3VsdHMsIHBhc3MgaXQgYmFjayB0byB0aGUgdXNlciBhcyBhIG1pc3NcbiAgICAgIC8vIE1pc3NlZCBldmVudHMgaGF2ZSB0byBjb21lIGZpcnN0IGluIG9yZGVyIHRvIGVzdGFibGlzaCB1c2VyLWxhbmQgc2lkZS1lZmZlY3QgY2xlYW4gdXBcbiAgICAgIGlmIChpc0NsaWNrRXZlbnQgJiYgIWhpdHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChkZWx0YSA8PSAyKSB7XG4gICAgICAgICAgcG9pbnRlck1pc3NlZChldmVudCwgaW50ZXJuYWwuaW50ZXJhY3Rpb24pO1xuICAgICAgICAgIGlmIChvblBvaW50ZXJNaXNzZWQpIG9uUG9pbnRlck1pc3NlZChldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFRha2UgY2FyZSBvZiB1bmhvdmVyXG4gICAgICBpZiAoaXNQb2ludGVyTW92ZSkgY2FuY2VsUG9pbnRlcihoaXRzKTtcbiAgICAgIGZ1bmN0aW9uIG9uSW50ZXJzZWN0KGRhdGEpIHtcbiAgICAgICAgY29uc3QgZXZlbnRPYmplY3QgPSBkYXRhLmV2ZW50T2JqZWN0O1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGV2ZW50T2JqZWN0Ll9fcjNmO1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5oYW5kbGVycztcblxuICAgICAgICAvLyBDaGVjayBwcmVzZW5jZSBvZiBoYW5kbGVyc1xuICAgICAgICBpZiAoIShpbnN0YW5jZSAhPSBudWxsICYmIGluc3RhbmNlLmV2ZW50Q291bnQpKSByZXR1cm47XG5cbiAgICAgICAgLypcbiAgICAgICAgTUFZQkUgVE9ETywgREVMRVRFIElGIE5PVDogXG4gICAgICAgICAgQ2hlY2sgaWYgdGhlIG9iamVjdCBpcyBjYXB0dXJlZCwgY2FwdHVyZWQgZXZlbnRzIHNob3VsZCBub3QgaGF2ZSBpbnRlcnNlY3RzIHJ1bm5pbmcgaW4gcGFyYWxsZWxcbiAgICAgICAgICBCdXQgd291bGRuJ3QgaXQgYmUgYmV0dGVyIHRvIGp1c3QgcmVwbGFjZSBjYXB0dXJlZE1hcCB3aXRoIGEgc2luZ2xlIGVudHJ5P1xuICAgICAgICAgIEFsc28sIGFyZSB3ZSBPSyB3aXRoIHN0cmFpZ2h0IHVwIG1ha2luZyBwaWNraW5nIHVwIG11bHRpcGxlIG9iamVjdHMgaW1wb3NzaWJsZT9cbiAgICAgICAgICBcbiAgICAgICAgY29uc3QgcG9pbnRlcklkID0gKGRhdGEgYXMgVGhyZWVFdmVudDxQb2ludGVyRXZlbnQ+KS5wb2ludGVySWQgICAgICAgIFxuICAgICAgICBpZiAocG9pbnRlcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBjYXB0dXJlZE1lc2hTZXQgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQocG9pbnRlcklkKVxuICAgICAgICAgIGlmIChjYXB0dXJlZE1lc2hTZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVkID0gY2FwdHVyZWRNZXNoU2V0LmdldChldmVudE9iamVjdClcbiAgICAgICAgICAgIGlmIChjYXB0dXJlZCAmJiBjYXB0dXJlZC5sb2NhbFN0YXRlLnN0b3BwZWQpIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfSovXG5cbiAgICAgICAgaWYgKGlzUG9pbnRlck1vdmUpIHtcbiAgICAgICAgICAvLyBNb3ZlIGV2ZW50IC4uLlxuICAgICAgICAgIGlmIChoYW5kbGVycy5vblBvaW50ZXJPdmVyIHx8IGhhbmRsZXJzLm9uUG9pbnRlckVudGVyIHx8IGhhbmRsZXJzLm9uUG9pbnRlck91dCB8fCBoYW5kbGVycy5vblBvaW50ZXJMZWF2ZSkge1xuICAgICAgICAgICAgLy8gV2hlbiBlbnRlciBvciBvdXQgaXMgcHJlc2VudCB0YWtlIGNhcmUgb2YgaG92ZXItc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IGlkID0gbWFrZUlkKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgaG92ZXJlZEl0ZW0gPSBpbnRlcm5hbC5ob3ZlcmVkLmdldChpZCk7XG4gICAgICAgICAgICBpZiAoIWhvdmVyZWRJdGVtKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3Qgd2Fzbid0IHByZXZpb3VzbHkgaG92ZXJlZCwgYm9vayBpdCBhbmQgY2FsbCBpdHMgaGFuZGxlclxuICAgICAgICAgICAgICBpbnRlcm5hbC5ob3ZlcmVkLnNldChpZCwgZGF0YSk7XG4gICAgICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlck92ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlck92ZXIoZGF0YSk7XG4gICAgICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlckVudGVyID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJFbnRlcihkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG92ZXJlZEl0ZW0uc3RvcHBlZCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IHdhcyBwcmV2aW91c2x5IGhvdmVyZWQgYW5kIHN0b3BwZWQsIHdlIHNob3VsZG4ndCBhbGxvdyBvdGhlciBpdGVtcyB0byBwcm9jZWVkXG4gICAgICAgICAgICAgIGRhdGEuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENhbGwgbW91c2UgbW92ZVxuICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlck1vdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlck1vdmUoZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWxsIG90aGVyIGV2ZW50cyAuLi5cbiAgICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbbmFtZV07XG4gICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIC8vIEZvcndhcmQgYWxsIGV2ZW50cyBiYWNrIHRvIHRoZWlyIHJlc3BlY3RpdmUgaGFuZGxlcnMgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGNsaWNrIGV2ZW50cyxcbiAgICAgICAgICAgIC8vIHdoaWNoIG11c3QgdXNlIHRoZSBpbml0aWFsIHRhcmdldFxuICAgICAgICAgICAgaWYgKCFpc0NsaWNrRXZlbnQgfHwgaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMoZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgIC8vIE1pc3NlZCBldmVudHMgaGF2ZSB0byBjb21lIGZpcnN0XG4gICAgICAgICAgICAgIHBvaW50ZXJNaXNzZWQoZXZlbnQsIGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcihvYmplY3QgPT4gIWludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKG9iamVjdCkpKTtcbiAgICAgICAgICAgICAgLy8gTm93IGNhbGwgdGhlIGhhbmRsZXJcbiAgICAgICAgICAgICAgaGFuZGxlcihkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJpZ2dlciBvblBvaW50ZXJNaXNzZWQgb24gYWxsIGVsZW1lbnRzIHRoYXQgaGF2ZSBwb2ludGVyIG92ZXIvb3V0IGhhbmRsZXJzLCBidXQgbm90IGNsaWNrIGFuZCB3ZXJlbid0IGhpdFxuICAgICAgICAgICAgaWYgKGlzQ2xpY2tFdmVudCAmJiBpbnRlcm5hbC5pbml0aWFsSGl0cy5pbmNsdWRlcyhldmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgcG9pbnRlck1pc3NlZChldmVudCwgaW50ZXJuYWwuaW50ZXJhY3Rpb24uZmlsdGVyKG9iamVjdCA9PiAhaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMob2JqZWN0KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGFuZGxlSW50ZXJzZWN0cyhoaXRzLCBldmVudCwgZGVsdGEsIG9uSW50ZXJzZWN0KTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaGFuZGxlUG9pbnRlclxuICB9O1xufVxuXG4vLyBLZXlzIHRoYXQgc2hvdWxkbid0IGJlIGNvcGllZCBiZXR3ZWVuIFIzRiBzdG9yZXNcbmNvbnN0IHByaXZhdGVLZXlzID0gWydzZXQnLCAnZ2V0JywgJ3NldFNpemUnLCAnc2V0RnJhbWVsb29wJywgJ3NldERwcicsICdldmVudHMnLCAnaW52YWxpZGF0ZScsICdhZHZhbmNlJywgJ3NpemUnLCAndmlld3BvcnQnXTtcbmNvbnN0IGlzUmVuZGVyZXIgPSBkZWYgPT4gISEoZGVmICE9IG51bGwgJiYgZGVmLnJlbmRlcik7XG5jb25zdCBjb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBjcmVhdGVTdG9yZSA9IChpbnZhbGlkYXRlLCBhZHZhbmNlKSA9PiB7XG4gIGNvbnN0IHJvb3RTdGF0ZSA9IGNyZWF0ZSgoc2V0LCBnZXQpID0+IHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgY29uc3QgZGVmYXVsdFRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgY29uc3QgdGVtcFRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSA9IGdldCgpLmNhbWVyYSwgdGFyZ2V0ID0gZGVmYXVsdFRhcmdldCwgc2l6ZSA9IGdldCgpLnNpemUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdG9wLFxuICAgICAgICBsZWZ0XG4gICAgICB9ID0gc2l6ZTtcbiAgICAgIGNvbnN0IGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMpIHRlbXBUYXJnZXQuY29weSh0YXJnZXQpO2Vsc2UgdGVtcFRhcmdldC5zZXQoLi4udGFyZ2V0KTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gY2FtZXJhLmdldFdvcmxkUG9zaXRpb24ocG9zaXRpb24pLmRpc3RhbmNlVG8odGVtcFRhcmdldCk7XG4gICAgICBpZiAoaXNPcnRob2dyYXBoaWNDYW1lcmEoY2FtZXJhKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiB3aWR0aCAvIGNhbWVyYS56b29tLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0IC8gY2FtZXJhLnpvb20sXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgZmFjdG9yOiAxLFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGFzcGVjdFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZm92ID0gY2FtZXJhLmZvdiAqIE1hdGguUEkgLyAxODA7IC8vIGNvbnZlcnQgdmVydGljYWwgZm92IHRvIHJhZGlhbnNcbiAgICAgICAgY29uc3QgaCA9IDIgKiBNYXRoLnRhbihmb3YgLyAyKSAqIGRpc3RhbmNlOyAvLyB2aXNpYmxlIGhlaWdodFxuICAgICAgICBjb25zdCB3ID0gaCAqICh3aWR0aCAvIGhlaWdodCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgaGVpZ2h0OiBoLFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIGZhY3Rvcjogd2lkdGggLyB3LFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGFzcGVjdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcGVyZm9ybWFuY2VUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHNldFBlcmZvcm1hbmNlQ3VycmVudCA9IGN1cnJlbnQgPT4gc2V0KHN0YXRlID0+ICh7XG4gICAgICBwZXJmb3JtYW5jZToge1xuICAgICAgICAuLi5zdGF0ZS5wZXJmb3JtYW5jZSxcbiAgICAgICAgY3VycmVudFxuICAgICAgfVxuICAgIH0pKTtcbiAgICBjb25zdCBwb2ludGVyID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICBjb25zdCByb290U3RhdGUgPSB7XG4gICAgICBzZXQsXG4gICAgICBnZXQsXG4gICAgICAvLyBNb2NrIG9iamVjdHMgdGhhdCBoYXZlIHRvIGJlIGNvbmZpZ3VyZWRcbiAgICAgIGdsOiBudWxsLFxuICAgICAgY2FtZXJhOiBudWxsLFxuICAgICAgcmF5Y2FzdGVyOiBudWxsLFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIHByaW9yaXR5OiAxLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBjb25uZWN0ZWQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgeHI6IG51bGwsXG4gICAgICBzY2VuZTogbnVsbCxcbiAgICAgIGludmFsaWRhdGU6IChmcmFtZXMgPSAxKSA9PiBpbnZhbGlkYXRlKGdldCgpLCBmcmFtZXMpLFxuICAgICAgYWR2YW5jZTogKHRpbWVzdGFtcCwgcnVuR2xvYmFsRWZmZWN0cykgPT4gYWR2YW5jZSh0aW1lc3RhbXAsIHJ1bkdsb2JhbEVmZmVjdHMsIGdldCgpKSxcbiAgICAgIGxlZ2FjeTogZmFsc2UsXG4gICAgICBsaW5lYXI6IGZhbHNlLFxuICAgICAgZmxhdDogZmFsc2UsXG4gICAgICBjb250cm9sczogbnVsbCxcbiAgICAgIGNsb2NrOiBuZXcgVEhSRUUuQ2xvY2soKSxcbiAgICAgIHBvaW50ZXIsXG4gICAgICBtb3VzZTogcG9pbnRlcixcbiAgICAgIGZyYW1lbG9vcDogJ2Fsd2F5cycsXG4gICAgICBvblBvaW50ZXJNaXNzZWQ6IHVuZGVmaW5lZCxcbiAgICAgIHBlcmZvcm1hbmNlOiB7XG4gICAgICAgIGN1cnJlbnQ6IDEsXG4gICAgICAgIG1pbjogMC41LFxuICAgICAgICBtYXg6IDEsXG4gICAgICAgIGRlYm91bmNlOiAyMDAsXG4gICAgICAgIHJlZ3Jlc3M6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICAgIC8vIENsZWFyIHRpbWVvdXRcbiAgICAgICAgICBpZiAocGVyZm9ybWFuY2VUaW1lb3V0KSBjbGVhclRpbWVvdXQocGVyZm9ybWFuY2VUaW1lb3V0KTtcbiAgICAgICAgICAvLyBTZXQgbG93ZXIgYm91bmQgcGVyZm9ybWFuY2VcbiAgICAgICAgICBpZiAoc3RhdGUucGVyZm9ybWFuY2UuY3VycmVudCAhPT0gc3RhdGUucGVyZm9ybWFuY2UubWluKSBzZXRQZXJmb3JtYW5jZUN1cnJlbnQoc3RhdGUucGVyZm9ybWFuY2UubWluKTtcbiAgICAgICAgICAvLyBHbyBiYWNrIHRvIHVwcGVyIGJvdW5kIHBlcmZvcm1hbmNlIGFmdGVyIGEgd2hpbGUgdW5sZXNzIHNvbWV0aGluZyByZWdyZXNzZXMgbWVhbndoaWxlXG4gICAgICAgICAgcGVyZm9ybWFuY2VUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBzZXRQZXJmb3JtYW5jZUN1cnJlbnQoZ2V0KCkucGVyZm9ybWFuY2UubWF4KSwgc3RhdGUucGVyZm9ybWFuY2UuZGVib3VuY2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHVwZGF0ZVN0eWxlOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIGluaXRpYWxEcHI6IDAsXG4gICAgICAgIGRwcjogMCxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBhc3BlY3Q6IDAsXG4gICAgICAgIGRpc3RhbmNlOiAwLFxuICAgICAgICBmYWN0b3I6IDAsXG4gICAgICAgIGdldEN1cnJlbnRWaWV3cG9ydFxuICAgICAgfSxcbiAgICAgIHNldEV2ZW50czogZXZlbnRzID0+IHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgIC4uLmV2ZW50c1xuICAgICAgICB9XG4gICAgICB9KSksXG4gICAgICBzZXRTaXplOiAod2lkdGgsIGhlaWdodCwgdXBkYXRlU3R5bGUsIHRvcCwgbGVmdCkgPT4ge1xuICAgICAgICBjb25zdCBjYW1lcmEgPSBnZXQoKS5jYW1lcmE7XG4gICAgICAgIGNvbnN0IHNpemUgPSB7XG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIHRvcDogdG9wIHx8IDAsXG4gICAgICAgICAgbGVmdDogbGVmdCB8fCAwLFxuICAgICAgICAgIHVwZGF0ZVN0eWxlXG4gICAgICAgIH07XG4gICAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAgIHNpemUsXG4gICAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LFxuICAgICAgICAgICAgLi4uZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSwgZGVmYXVsdFRhcmdldCwgc2l6ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgICBzZXREcHI6IGRwciA9PiBzZXQoc3RhdGUgPT4ge1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IGNhbGN1bGF0ZURwcihkcHIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS52aWV3cG9ydCxcbiAgICAgICAgICAgIGRwcjogcmVzb2x2ZWQsXG4gICAgICAgICAgICBpbml0aWFsRHByOiBzdGF0ZS52aWV3cG9ydC5pbml0aWFsRHByIHx8IHJlc29sdmVkXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICBzZXRGcmFtZWxvb3A6IChmcmFtZWxvb3AgPSAnYWx3YXlzJykgPT4ge1xuICAgICAgICBjb25zdCBjbG9jayA9IGdldCgpLmNsb2NrO1xuXG4gICAgICAgIC8vIGlmIGZyYW1lbG9vcCA9PT0gXCJuZXZlclwiIGNsb2NrLmVsYXBzZWRUaW1lIGlzIHVwZGF0ZWQgdXNpbmcgYWR2YW5jZSh0aW1lc3RhbXApXG4gICAgICAgIGNsb2NrLnN0b3AoKTtcbiAgICAgICAgY2xvY2suZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICBpZiAoZnJhbWVsb29wICE9PSAnbmV2ZXInKSB7XG4gICAgICAgICAgY2xvY2suc3RhcnQoKTtcbiAgICAgICAgICBjbG9jay5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KCgpID0+ICh7XG4gICAgICAgICAgZnJhbWVsb29wXG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgICBwcmV2aW91c1Jvb3Q6IHVuZGVmaW5lZCxcbiAgICAgIGludGVybmFsOiB7XG4gICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgIHByaW9yaXR5OiAwLFxuICAgICAgICBmcmFtZXM6IDAsXG4gICAgICAgIGxhc3RFdmVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZVJlZigpLFxuICAgICAgICBpbnRlcmFjdGlvbjogW10sXG4gICAgICAgIGhvdmVyZWQ6IG5ldyBNYXAoKSxcbiAgICAgICAgc3Vic2NyaWJlcnM6IFtdLFxuICAgICAgICBpbml0aWFsQ2xpY2s6IFswLCAwXSxcbiAgICAgICAgaW5pdGlhbEhpdHM6IFtdLFxuICAgICAgICBjYXB0dXJlZE1hcDogbmV3IE1hcCgpLFxuICAgICAgICBzdWJzY3JpYmU6IChyZWYsIHByaW9yaXR5LCBzdG9yZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGludGVybmFsID0gZ2V0KCkuaW50ZXJuYWw7XG4gICAgICAgICAgLy8gSWYgdGhpcyBzdWJzY3JpcHRpb24gd2FzIGdpdmVuIGEgcHJpb3JpdHksIGl0IHRha2VzIHJlbmRlcmluZyBpbnRvIGl0cyBvd24gaGFuZHNcbiAgICAgICAgICAvLyBGb3IgdGhhdCByZWFzb24gd2Ugc3dpdGNoIG9mZiBhdXRvbWF0aWMgcmVuZGVyaW5nIGFuZCBpbmNyZWFzZSB0aGUgbWFudWFsIGZsYWdcbiAgICAgICAgICAvLyBBcyBsb25nIGFzIHRoaXMgZmxhZyBpcyBwb3NpdGl2ZSB0aGVyZSBjYW4gYmUgbm8gaW50ZXJuYWwgcmVuZGVyaW5nIGF0IGFsbFxuICAgICAgICAgIC8vIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgcmVuZGVyIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgICBpbnRlcm5hbC5wcmlvcml0eSA9IGludGVybmFsLnByaW9yaXR5ICsgKHByaW9yaXR5ID4gMCA/IDEgOiAwKTtcbiAgICAgICAgICBpbnRlcm5hbC5zdWJzY3JpYmVycy5wdXNoKHtcbiAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgIHByaW9yaXR5LFxuICAgICAgICAgICAgc3RvcmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBSZWdpc3RlciBzdWJzY3JpYmVyIGFuZCBzb3J0IGxheWVycyBmcm9tIGxvd2VzdCB0byBoaWdoZXN0LCBtZWFuaW5nLFxuICAgICAgICAgIC8vIGhpZ2hlc3QgcHJpb3JpdHkgcmVuZGVycyBsYXN0IChvbiB0b3Agb2YgdGhlIG90aGVyIGZyYW1lcylcbiAgICAgICAgICBpbnRlcm5hbC5zdWJzY3JpYmVycyA9IGludGVybmFsLnN1YnNjcmliZXJzLnNvcnQoKGEsIGIpID0+IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5KTtcbiAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJuYWwgPSBnZXQoKS5pbnRlcm5hbDtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbCAhPSBudWxsICYmIGludGVybmFsLnN1YnNjcmliZXJzKSB7XG4gICAgICAgICAgICAgIC8vIERlY3JlYXNlIG1hbnVhbCBmbGFnIGlmIHRoaXMgc3Vic2NyaXB0aW9uIGhhZCBhIHByaW9yaXR5XG4gICAgICAgICAgICAgIGludGVybmFsLnByaW9yaXR5ID0gaW50ZXJuYWwucHJpb3JpdHkgLSAocHJpb3JpdHkgPiAwID8gMSA6IDApO1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgc3Vic2NyaWJlciBmcm9tIGxpc3RcbiAgICAgICAgICAgICAgaW50ZXJuYWwuc3Vic2NyaWJlcnMgPSBpbnRlcm5hbC5zdWJzY3JpYmVycy5maWx0ZXIocyA9PiBzLnJlZiAhPT0gcmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcm9vdFN0YXRlO1xuICB9KTtcbiAgY29uc3Qgc3RhdGUgPSByb290U3RhdGUuZ2V0U3RhdGUoKTtcbiAgbGV0IG9sZFNpemUgPSBzdGF0ZS5zaXplO1xuICBsZXQgb2xkRHByID0gc3RhdGUudmlld3BvcnQuZHByO1xuICBsZXQgb2xkQ2FtZXJhID0gc3RhdGUuY2FtZXJhO1xuICByb290U3RhdGUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjYW1lcmEsXG4gICAgICBzaXplLFxuICAgICAgdmlld3BvcnQsXG4gICAgICBnbCxcbiAgICAgIHNldFxuICAgIH0gPSByb290U3RhdGUuZ2V0U3RhdGUoKTtcblxuICAgIC8vIFJlc2l6ZSBjYW1lcmEgYW5kIHJlbmRlcmVyIG9uIGNoYW5nZXMgdG8gc2l6ZSBhbmQgcGl4ZWxyYXRpb1xuICAgIGlmIChzaXplLndpZHRoICE9PSBvbGRTaXplLndpZHRoIHx8IHNpemUuaGVpZ2h0ICE9PSBvbGRTaXplLmhlaWdodCB8fCB2aWV3cG9ydC5kcHIgIT09IG9sZERwcikge1xuICAgICAgdmFyIF9zaXplJHVwZGF0ZVN0eWxlO1xuICAgICAgb2xkU2l6ZSA9IHNpemU7XG4gICAgICBvbGREcHIgPSB2aWV3cG9ydC5kcHI7XG4gICAgICAvLyBVcGRhdGUgY2FtZXJhICYgcmVuZGVyZXJcbiAgICAgIHVwZGF0ZUNhbWVyYShjYW1lcmEsIHNpemUpO1xuICAgICAgZ2wuc2V0UGl4ZWxSYXRpbyh2aWV3cG9ydC5kcHIpO1xuICAgICAgY29uc3QgdXBkYXRlU3R5bGUgPSAoX3NpemUkdXBkYXRlU3R5bGUgPSBzaXplLnVwZGF0ZVN0eWxlKSAhPSBudWxsID8gX3NpemUkdXBkYXRlU3R5bGUgOiB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGdsLmRvbUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICAgIGdsLnNldFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHVwZGF0ZVN0eWxlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdmlld3BvcnQgb25jZSB0aGUgY2FtZXJhIGNoYW5nZXNcbiAgICBpZiAoY2FtZXJhICE9PSBvbGRDYW1lcmEpIHtcbiAgICAgIG9sZENhbWVyYSA9IGNhbWVyYTtcbiAgICAgIC8vIFVwZGF0ZSB2aWV3cG9ydFxuICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQuZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSlcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gSW52YWxpZGF0ZSBvbiBhbnkgY2hhbmdlXG4gIHJvb3RTdGF0ZS5zdWJzY3JpYmUoc3RhdGUgPT4gaW52YWxpZGF0ZShzdGF0ZSkpO1xuXG4gIC8vIFJldHVybiByb290IHN0YXRlXG4gIHJldHVybiByb290U3RhdGU7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBzdWJzKSB7XG4gIGNvbnN0IHN1YiA9IHtcbiAgICBjYWxsYmFja1xuICB9O1xuICBzdWJzLmFkZChzdWIpO1xuICByZXR1cm4gKCkgPT4gdm9pZCBzdWJzLmRlbGV0ZShzdWIpO1xufVxubGV0IGk7XG5sZXQgZ2xvYmFsRWZmZWN0cyA9IG5ldyBTZXQoKTtcbmxldCBnbG9iYWxBZnRlckVmZmVjdHMgPSBuZXcgU2V0KCk7XG5sZXQgZ2xvYmFsVGFpbEVmZmVjdHMgPSBuZXcgU2V0KCk7XG5cbi8qKlxuICogQWRkcyBhIGdsb2JhbCByZW5kZXIgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGVhY2ggZnJhbWUuXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjYWRkRWZmZWN0XG4gKi9cbmNvbnN0IGFkZEVmZmVjdCA9IGNhbGxiYWNrID0+IGNyZWF0ZVN1YnMoY2FsbGJhY2ssIGdsb2JhbEVmZmVjdHMpO1xuXG4vKipcbiAqIEFkZHMgYSBnbG9iYWwgYWZ0ZXItcmVuZGVyIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBlYWNoIGZyYW1lLlxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2FkZEFmdGVyRWZmZWN0XG4gKi9cbmNvbnN0IGFkZEFmdGVyRWZmZWN0ID0gY2FsbGJhY2sgPT4gY3JlYXRlU3VicyhjYWxsYmFjaywgZ2xvYmFsQWZ0ZXJFZmZlY3RzKTtcblxuLyoqXG4gKiBBZGRzIGEgZ2xvYmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHJlbmRlcmluZyBzdG9wcy5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNhZGRUYWlsXG4gKi9cbmNvbnN0IGFkZFRhaWwgPSBjYWxsYmFjayA9PiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBnbG9iYWxUYWlsRWZmZWN0cyk7XG5mdW5jdGlvbiBydW4oZWZmZWN0cywgdGltZXN0YW1wKSB7XG4gIGlmICghZWZmZWN0cy5zaXplKSByZXR1cm47XG4gIGZvciAoY29uc3Qge1xuICAgIGNhbGxiYWNrXG4gIH0gb2YgZWZmZWN0cy52YWx1ZXMoKSkge1xuICAgIGNhbGxiYWNrKHRpbWVzdGFtcCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoR2xvYmFsRWZmZWN0cyh0eXBlLCB0aW1lc3RhbXApIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYmVmb3JlJzpcbiAgICAgIHJldHVybiBydW4oZ2xvYmFsRWZmZWN0cywgdGltZXN0YW1wKTtcbiAgICBjYXNlICdhZnRlcic6XG4gICAgICByZXR1cm4gcnVuKGdsb2JhbEFmdGVyRWZmZWN0cywgdGltZXN0YW1wKTtcbiAgICBjYXNlICd0YWlsJzpcbiAgICAgIHJldHVybiBydW4oZ2xvYmFsVGFpbEVmZmVjdHMsIHRpbWVzdGFtcCk7XG4gIH1cbn1cbmxldCBzdWJzY3JpYmVycztcbmxldCBzdWJzY3JpcHRpb247XG5mdW5jdGlvbiByZW5kZXIkMSh0aW1lc3RhbXAsIHN0YXRlLCBmcmFtZSkge1xuICAvLyBSdW4gbG9jYWwgZWZmZWN0c1xuICBsZXQgZGVsdGEgPSBzdGF0ZS5jbG9jay5nZXREZWx0YSgpO1xuICAvLyBJbiBmcmFtZWxvb3A9J25ldmVyJyBtb2RlLCBjbG9jayB0aW1lcyBhcmUgdXBkYXRlZCB1c2luZyB0aGUgcHJvdmlkZWQgdGltZXN0YW1wXG4gIGlmIChzdGF0ZS5mcmFtZWxvb3AgPT09ICduZXZlcicgJiYgdHlwZW9mIHRpbWVzdGFtcCA9PT0gJ251bWJlcicpIHtcbiAgICBkZWx0YSA9IHRpbWVzdGFtcCAtIHN0YXRlLmNsb2NrLmVsYXBzZWRUaW1lO1xuICAgIHN0YXRlLmNsb2NrLm9sZFRpbWUgPSBzdGF0ZS5jbG9jay5lbGFwc2VkVGltZTtcbiAgICBzdGF0ZS5jbG9jay5lbGFwc2VkVGltZSA9IHRpbWVzdGFtcDtcbiAgfVxuICAvLyBDYWxsIHN1YnNjcmliZXJzICh1c2VGcmFtZSlcbiAgc3Vic2NyaWJlcnMgPSBzdGF0ZS5pbnRlcm5hbC5zdWJzY3JpYmVycztcbiAgZm9yIChpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlcnNbaV07XG4gICAgc3Vic2NyaXB0aW9uLnJlZi5jdXJyZW50KHN1YnNjcmlwdGlvbi5zdG9yZS5nZXRTdGF0ZSgpLCBkZWx0YSwgZnJhbWUpO1xuICB9XG4gIC8vIFJlbmRlciBjb250ZW50XG4gIGlmICghc3RhdGUuaW50ZXJuYWwucHJpb3JpdHkgJiYgc3RhdGUuZ2wucmVuZGVyKSBzdGF0ZS5nbC5yZW5kZXIoc3RhdGUuc2NlbmUsIHN0YXRlLmNhbWVyYSk7XG4gIC8vIERlY3JlYXNlIGZyYW1lIGNvdW50XG4gIHN0YXRlLmludGVybmFsLmZyYW1lcyA9IE1hdGgubWF4KDAsIHN0YXRlLmludGVybmFsLmZyYW1lcyAtIDEpO1xuICByZXR1cm4gc3RhdGUuZnJhbWVsb29wID09PSAnYWx3YXlzJyA/IDEgOiBzdGF0ZS5pbnRlcm5hbC5mcmFtZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVMb29wKHJvb3RzKSB7XG4gIGxldCBydW5uaW5nID0gZmFsc2U7XG4gIGxldCByZXBlYXQ7XG4gIGxldCBmcmFtZTtcbiAgbGV0IHN0YXRlO1xuICBmdW5jdGlvbiBsb29wKHRpbWVzdGFtcCkge1xuICAgIGZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgIHJlcGVhdCA9IDA7XG5cbiAgICAvLyBSdW4gZWZmZWN0c1xuICAgIGZsdXNoR2xvYmFsRWZmZWN0cygnYmVmb3JlJywgdGltZXN0YW1wKTtcblxuICAgIC8vIFJlbmRlciBhbGwgcm9vdHNcbiAgICBmb3IgKGNvbnN0IHJvb3Qgb2Ygcm9vdHMudmFsdWVzKCkpIHtcbiAgICAgIHZhciBfc3RhdGUkZ2wkeHI7XG4gICAgICBzdGF0ZSA9IHJvb3Quc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIC8vIElmIHRoZSBmcmFtZWxvb3AgaXMgaW52YWxpZGF0ZWQsIGRvIG5vdCBydW4gYW5vdGhlciBmcmFtZVxuICAgICAgaWYgKHN0YXRlLmludGVybmFsLmFjdGl2ZSAmJiAoc3RhdGUuZnJhbWVsb29wID09PSAnYWx3YXlzJyB8fCBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPiAwKSAmJiAhKChfc3RhdGUkZ2wkeHIgPSBzdGF0ZS5nbC54cikgIT0gbnVsbCAmJiBfc3RhdGUkZ2wkeHIuaXNQcmVzZW50aW5nKSkge1xuICAgICAgICByZXBlYXQgKz0gcmVuZGVyJDEodGltZXN0YW1wLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUnVuIGFmdGVyLWVmZmVjdHNcbiAgICBmbHVzaEdsb2JhbEVmZmVjdHMoJ2FmdGVyJywgdGltZXN0YW1wKTtcblxuICAgIC8vIFN0b3AgdGhlIGxvb3AgaWYgbm90aGluZyBpbnZhbGlkYXRlcyBpdFxuICAgIGlmIChyZXBlYXQgPT09IDApIHtcbiAgICAgIC8vIFRhaWwgY2FsbCBlZmZlY3RzLCB0aGV5IGFyZSBjYWxsZWQgd2hlbiByZW5kZXJpbmcgc3RvcHNcbiAgICAgIGZsdXNoR2xvYmFsRWZmZWN0cygndGFpbCcsIHRpbWVzdGFtcCk7XG5cbiAgICAgIC8vIEZsYWcgZW5kIG9mIG9wZXJhdGlvblxuICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaW52YWxpZGF0ZShzdGF0ZSwgZnJhbWVzID0gMSkge1xuICAgIHZhciBfc3RhdGUkZ2wkeHIyO1xuICAgIGlmICghc3RhdGUpIHJldHVybiByb290cy5mb3JFYWNoKHJvb3QgPT4gaW52YWxpZGF0ZShyb290LnN0b3JlLmdldFN0YXRlKCkpLCBmcmFtZXMpO1xuICAgIGlmICgoX3N0YXRlJGdsJHhyMiA9IHN0YXRlLmdsLnhyKSAhPSBudWxsICYmIF9zdGF0ZSRnbCR4cjIuaXNQcmVzZW50aW5nIHx8ICFzdGF0ZS5pbnRlcm5hbC5hY3RpdmUgfHwgc3RhdGUuZnJhbWVsb29wID09PSAnbmV2ZXInKSByZXR1cm47XG4gICAgLy8gSW5jcmVhc2UgZnJhbWVzLCBkbyBub3QgZ28gaGlnaGVyIHRoYW4gNjBcbiAgICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSBNYXRoLm1pbig2MCwgc3RhdGUuaW50ZXJuYWwuZnJhbWVzICsgZnJhbWVzKTtcbiAgICAvLyBJZiB0aGUgcmVuZGVyLWxvb3AgaXNuJ3QgYWN0aXZlLCBzdGFydCBpdFxuICAgIGlmICghcnVubmluZykge1xuICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFkdmFuY2UodGltZXN0YW1wLCBydW5HbG9iYWxFZmZlY3RzID0gdHJ1ZSwgc3RhdGUsIGZyYW1lKSB7XG4gICAgaWYgKHJ1bkdsb2JhbEVmZmVjdHMpIGZsdXNoR2xvYmFsRWZmZWN0cygnYmVmb3JlJywgdGltZXN0YW1wKTtcbiAgICBpZiAoIXN0YXRlKSBmb3IgKGNvbnN0IHJvb3Qgb2Ygcm9vdHMudmFsdWVzKCkpIHJlbmRlciQxKHRpbWVzdGFtcCwgcm9vdC5zdG9yZS5nZXRTdGF0ZSgpKTtlbHNlIHJlbmRlciQxKHRpbWVzdGFtcCwgc3RhdGUsIGZyYW1lKTtcbiAgICBpZiAocnVuR2xvYmFsRWZmZWN0cykgZmx1c2hHbG9iYWxFZmZlY3RzKCdhZnRlcicsIHRpbWVzdGFtcCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsb29wLFxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIHRoZSB2aWV3LCByZXF1ZXN0aW5nIGEgZnJhbWUgdG8gYmUgcmVuZGVyZWQuIFdpbGwgZ2xvYmFsbHkgaW52YWxpZGF0ZSB1bmxlc3MgcGFzc2VkIGEgcm9vdCdzIHN0YXRlLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNpbnZhbGlkYXRlXG4gICAgICovXG4gICAgaW52YWxpZGF0ZSxcbiAgICAvKipcbiAgICAgKiBBZHZhbmNlcyB0aGUgZnJhbWVsb29wIGFuZCBydW5zIHJlbmRlciBlZmZlY3RzLCB1c2VmdWwgZm9yIHdoZW4gbWFudWFsbHkgcmVuZGVyaW5nIHZpYSBgZnJhbWVsb29wPVwibmV2ZXJcImAuXG4gICAgICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2FkdmFuY2VcbiAgICAgKi9cbiAgICBhZHZhbmNlXG4gIH07XG59XG5cbi8qKlxuICogRXhwb3NlcyBhbiBvYmplY3QncyB7QGxpbmsgTG9jYWxTdGF0ZX0uXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjdXNlSW5zdGFuY2VIYW5kbGVcbiAqXG4gKiAqKk5vdGUqKjogdGhpcyBpcyBhbiBlc2NhcGUgaGF0Y2ggdG8gcmVhY3QtaW50ZXJuYWwgZmllbGRzLiBFeHBlY3QgdGhpcyB0byBjaGFuZ2Ugc2lnbmlmaWNhbnRseSBiZXR3ZWVuIHZlcnNpb25zLlxuICovXG5mdW5jdGlvbiB1c2VJbnN0YW5jZUhhbmRsZShyZWYpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gdm9pZCAoaW5zdGFuY2UuY3VycmVudCA9IHJlZi5jdXJyZW50Ll9fcjNmKSwgW3JlZl0pO1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiB1c2VTdG9yZSgpIHtcbiAgY29uc3Qgc3RvcmUgPSBSZWFjdC51c2VDb250ZXh0KGNvbnRleHQpO1xuICBpZiAoIXN0b3JlKSB0aHJvdyBuZXcgRXJyb3IoJ1IzRjogSG9va3MgY2FuIG9ubHkgYmUgdXNlZCB3aXRoaW4gdGhlIENhbnZhcyBjb21wb25lbnQhJyk7XG4gIHJldHVybiBzdG9yZTtcbn1cblxuLyoqXG4gKiBBY2Nlc3NlcyBSM0YncyBpbnRlcm5hbCBzdGF0ZSwgY29udGFpbmluZyByZW5kZXJlciwgY2FudmFzLCBzY2VuZSwgZXRjLlxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNldGhyZWVcbiAqL1xuZnVuY3Rpb24gdXNlVGhyZWUoc2VsZWN0b3IgPSBzdGF0ZSA9PiBzdGF0ZSwgZXF1YWxpdHlGbikge1xuICByZXR1cm4gdXNlU3RvcmUoKShzZWxlY3RvciwgZXF1YWxpdHlGbik7XG59XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBjYWxsYmFjayBiZWZvcmUgcmVuZGVyIGluIGEgc2hhcmVkIGZyYW1lIGxvb3AuXG4gKiBDYW4gb3JkZXIgZWZmZWN0cyB3aXRoIHJlbmRlciBwcmlvcml0eSBvciBtYW51YWxseSByZW5kZXIgd2l0aCBhIHBvc2l0aXZlIHByaW9yaXR5LlxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlZnJhbWVcbiAqL1xuZnVuY3Rpb24gdXNlRnJhbWUoY2FsbGJhY2ssIHJlbmRlclByaW9yaXR5ID0gMCkge1xuICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHN0b3JlLmdldFN0YXRlKCkuaW50ZXJuYWwuc3Vic2NyaWJlO1xuICAvLyBNZW1vaXplIHJlZlxuICBjb25zdCByZWYgPSB1c2VNdXRhYmxlQ2FsbGJhY2soY2FsbGJhY2spO1xuICAvLyBTdWJzY3JpYmUgb24gbW91bnQsIHVuc3Vic2NyaWJlIG9uIHVubW91bnRcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiBzdWJzY3JpYmUocmVmLCByZW5kZXJQcmlvcml0eSwgc3RvcmUpLCBbcmVuZGVyUHJpb3JpdHksIHN1YnNjcmliZSwgc3RvcmVdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5vZGUgZ3JhcGggb2YgYW4gb2JqZWN0IHdpdGggbmFtZWQgbm9kZXMgJiBtYXRlcmlhbHMuXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2VncmFwaFxuICovXG5mdW5jdGlvbiB1c2VHcmFwaChvYmplY3QpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gYnVpbGRHcmFwaChvYmplY3QpLCBbb2JqZWN0XSk7XG59XG5jb25zdCBtZW1vaXplZExvYWRlcnMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gbG9hZGluZ0ZuKGV4dGVuc2lvbnMsIG9uUHJvZ3Jlc3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChQcm90bywgLi4uaW5wdXQpIHtcbiAgICAvLyBDb25zdHJ1Y3QgbmV3IGxvYWRlciBhbmQgcnVuIGV4dGVuc2lvbnNcbiAgICBsZXQgbG9hZGVyID0gbWVtb2l6ZWRMb2FkZXJzLmdldChQcm90byk7XG4gICAgaWYgKCFsb2FkZXIpIHtcbiAgICAgIGxvYWRlciA9IG5ldyBQcm90bygpO1xuICAgICAgbWVtb2l6ZWRMb2FkZXJzLnNldChQcm90bywgbG9hZGVyKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbnMpIGV4dGVuc2lvbnMobG9hZGVyKTtcbiAgICAvLyBHbyB0aHJvdWdoIHRoZSB1cmxzIGFuZCBsb2FkIHRoZW1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoaW5wdXQubWFwKGlucHV0ID0+IG5ldyBQcm9taXNlKChyZXMsIHJlamVjdCkgPT4gbG9hZGVyLmxvYWQoaW5wdXQsIGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEuc2NlbmUpIE9iamVjdC5hc3NpZ24oZGF0YSwgYnVpbGRHcmFwaChkYXRhLnNjZW5lKSk7XG4gICAgICByZXMoZGF0YSk7XG4gICAgfSwgb25Qcm9ncmVzcywgZXJyb3IgPT4gcmVqZWN0KG5ldyBFcnJvcihgQ291bGQgbm90IGxvYWQgJHtpbnB1dH06ICR7ZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2V9YCkpKSkpKS5maW5hbGx5KCgpID0+IGxvYWRlci5kaXNwb3NlID09IG51bGwgPyB2b2lkIDAgOiBsb2FkZXIuZGlzcG9zZSgpKTtcbiAgfTtcbn1cbi8qKlxuICogU3luY2hyb25vdXNseSBsb2FkcyBhbmQgY2FjaGVzIGFzc2V0cyB3aXRoIGEgdGhyZWUgbG9hZGVyLlxuICpcbiAqIE5vdGU6IHRoaXMgaG9vaydzIGNhbGxlciBtdXN0IGJlIHdyYXBwZWQgd2l0aCBgUmVhY3QuU3VzcGVuc2VgXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2Vsb2FkZXJcbiAqL1xuZnVuY3Rpb24gdXNlTG9hZGVyKFByb3RvLCBpbnB1dCwgZXh0ZW5zaW9ucywgb25Qcm9ncmVzcykge1xuICAvLyBVc2Ugc3VzcGVuc2UgdG8gbG9hZCBhc3luYyBhc3NldHNcbiAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBbaW5wdXRdO1xuICBjb25zdCByZXN1bHRzID0gc3VzcGVuZChsb2FkaW5nRm4oZXh0ZW5zaW9ucywgb25Qcm9ncmVzcyksIFtQcm90bywgLi4ua2V5c10sIHtcbiAgICBlcXVhbDogaXMuZXF1XG4gIH0pO1xuICAvLyBSZXR1cm4gdGhlIG9iamVjdC9zXG4gIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KSA/IHJlc3VsdHMgOiByZXN1bHRzWzBdO1xufVxuXG4vKipcbiAqIFByZWxvYWRzIGFuIGFzc2V0IGludG8gY2FjaGUgYXMgYSBzaWRlLWVmZmVjdC5cbiAqL1xudXNlTG9hZGVyLnByZWxvYWQgPSBmdW5jdGlvbiAoUHJvdG8sIGlucHV0LCBleHRlbnNpb25zKSB7XG4gIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW2lucHV0XTtcbiAgcmV0dXJuIHByZWxvYWQobG9hZGluZ0ZuKGV4dGVuc2lvbnMpLCBbUHJvdG8sIC4uLmtleXNdKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGxvYWRlZCBhc3NldCBmcm9tIGNhY2hlLlxuICovXG51c2VMb2FkZXIuY2xlYXIgPSBmdW5jdGlvbiAoUHJvdG8sIGlucHV0KSB7XG4gIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW2lucHV0XTtcbiAgcmV0dXJuIGNsZWFyKFtQcm90bywgLi4ua2V5c10pO1xufTtcblxuY29uc3Qgcm9vdHMgPSBuZXcgTWFwKCk7XG5jb25zdCB7XG4gIGludmFsaWRhdGUsXG4gIGFkdmFuY2Vcbn0gPSBjcmVhdGVMb29wKHJvb3RzKTtcbmNvbnN0IHtcbiAgcmVjb25jaWxlcixcbiAgYXBwbHlQcm9wc1xufSA9IGNyZWF0ZVJlbmRlcmVyKHJvb3RzLCBnZXRFdmVudFByaW9yaXR5KTtcbmNvbnN0IHNoYWxsb3dMb29zZSA9IHtcbiAgb2JqZWN0czogJ3NoYWxsb3cnLFxuICBzdHJpY3Q6IGZhbHNlXG59O1xuY29uc3QgY3JlYXRlUmVuZGVyZXJJbnN0YW5jZSA9IChnbCwgY2FudmFzKSA9PiB7XG4gIGNvbnN0IGN1c3RvbVJlbmRlcmVyID0gdHlwZW9mIGdsID09PSAnZnVuY3Rpb24nID8gZ2woY2FudmFzKSA6IGdsO1xuICBpZiAoaXNSZW5kZXJlcihjdXN0b21SZW5kZXJlcikpIHJldHVybiBjdXN0b21SZW5kZXJlcjtlbHNlIHJldHVybiBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7XG4gICAgcG93ZXJQcmVmZXJlbmNlOiAnaGlnaC1wZXJmb3JtYW5jZScsXG4gICAgY2FudmFzOiBjYW52YXMsXG4gICAgYW50aWFsaWFzOiB0cnVlLFxuICAgIGFscGhhOiB0cnVlLFxuICAgIC4uLmdsXG4gIH0pO1xufTtcbmZ1bmN0aW9uIGNvbXB1dGVJbml0aWFsU2l6ZShjYW52YXMsIGRlZmF1bHRTaXplKSB7XG4gIGNvbnN0IGRlZmF1bHRTdHlsZSA9IHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQ7XG4gIGlmIChkZWZhdWx0U2l6ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdG9wLFxuICAgICAgbGVmdCxcbiAgICAgIHVwZGF0ZVN0eWxlID0gZGVmYXVsdFN0eWxlXG4gICAgfSA9IGRlZmF1bHRTaXplO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnQsXG4gICAgICB1cGRhdGVTdHlsZVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCAmJiBjYW52YXMucGFyZW50RWxlbWVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdG9wLFxuICAgICAgbGVmdFxuICAgIH0gPSBjYW52YXMucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICB0b3AsXG4gICAgICBsZWZ0LFxuICAgICAgdXBkYXRlU3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdXBkYXRlU3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvb3QoY2FudmFzKSB7XG4gIC8vIENoZWNrIGFnYWluc3QgbWlzdGFrZW4gdXNlIG9mIGNyZWF0ZVJvb3RcbiAgY29uc3QgcHJldlJvb3QgPSByb290cy5nZXQoY2FudmFzKTtcbiAgY29uc3QgcHJldkZpYmVyID0gcHJldlJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZSb290LmZpYmVyO1xuICBjb25zdCBwcmV2U3RvcmUgPSBwcmV2Um9vdCA9PSBudWxsID8gdm9pZCAwIDogcHJldlJvb3Quc3RvcmU7XG4gIGlmIChwcmV2Um9vdCkgY29uc29sZS53YXJuKCdSM0YuY3JlYXRlUm9vdCBzaG91bGQgb25seSBiZSBjYWxsZWQgb25jZSEnKTtcblxuICAvLyBSZXBvcnQgd2hlbiBhbiBlcnJvciB3YXMgZGV0ZWN0ZWQgaW4gYSBwcmV2aW91cyByZW5kZXJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzIyNjFcbiAgY29uc3QgbG9nUmVjb3ZlcmFibGVFcnJvciA9IHR5cGVvZiByZXBvcnRFcnJvciA9PT0gJ2Z1bmN0aW9uJyA/XG4gIC8vIEluIG1vZGVybiBicm93c2VycywgcmVwb3J0RXJyb3Igd2lsbCBkaXNwYXRjaCBhbiBlcnJvciBldmVudCxcbiAgLy8gZW11bGF0aW5nIGFuIHVuY2F1Z2h0IEphdmFTY3JpcHQgZXJyb3IuXG4gIHJlcG9ydEVycm9yIDpcbiAgLy8gSW4gb2xkZXIgYnJvd3NlcnMgYW5kIHRlc3QgZW52aXJvbm1lbnRzLCBmYWxsYmFjayB0byBjb25zb2xlLmVycm9yLlxuICBjb25zb2xlLmVycm9yO1xuXG4gIC8vIENyZWF0ZSBzdG9yZVxuICBjb25zdCBzdG9yZSA9IHByZXZTdG9yZSB8fCBjcmVhdGVTdG9yZShpbnZhbGlkYXRlLCBhZHZhbmNlKTtcbiAgLy8gQ3JlYXRlIHJlbmRlcmVyXG4gIGNvbnN0IGZpYmVyID0gcHJldkZpYmVyIHx8IHJlY29uY2lsZXIuY3JlYXRlQ29udGFpbmVyKHN0b3JlLCBDb25jdXJyZW50Um9vdCwgbnVsbCwgZmFsc2UsIG51bGwsICcnLCBsb2dSZWNvdmVyYWJsZUVycm9yLCBudWxsKTtcbiAgLy8gTWFwIGl0XG4gIGlmICghcHJldlJvb3QpIHJvb3RzLnNldChjYW52YXMsIHtcbiAgICBmaWJlcixcbiAgICBzdG9yZVxuICB9KTtcblxuICAvLyBMb2NhbHNcbiAgbGV0IG9uQ3JlYXRlZDtcbiAgbGV0IGNvbmZpZ3VyZWQgPSBmYWxzZTtcbiAgbGV0IGxhc3RDYW1lcmE7XG4gIHJldHVybiB7XG4gICAgY29uZmlndXJlKHByb3BzID0ge30pIHtcbiAgICAgIGxldCB7XG4gICAgICAgIGdsOiBnbENvbmZpZyxcbiAgICAgICAgc2l6ZTogcHJvcHNTaXplLFxuICAgICAgICBzY2VuZTogc2NlbmVPcHRpb25zLFxuICAgICAgICBldmVudHMsXG4gICAgICAgIG9uQ3JlYXRlZDogb25DcmVhdGVkQ2FsbGJhY2ssXG4gICAgICAgIHNoYWRvd3MgPSBmYWxzZSxcbiAgICAgICAgbGluZWFyID0gZmFsc2UsXG4gICAgICAgIGZsYXQgPSBmYWxzZSxcbiAgICAgICAgbGVnYWN5ID0gZmFsc2UsXG4gICAgICAgIG9ydGhvZ3JhcGhpYyA9IGZhbHNlLFxuICAgICAgICBmcmFtZWxvb3AgPSAnYWx3YXlzJyxcbiAgICAgICAgZHByID0gWzEsIDJdLFxuICAgICAgICBwZXJmb3JtYW5jZSxcbiAgICAgICAgcmF5Y2FzdGVyOiByYXljYXN0T3B0aW9ucyxcbiAgICAgICAgY2FtZXJhOiBjYW1lcmFPcHRpb25zLFxuICAgICAgICBvblBvaW50ZXJNaXNzZWRcbiAgICAgIH0gPSBwcm9wcztcbiAgICAgIGxldCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgIC8vIFNldCB1cCByZW5kZXJlciAob25lIHRpbWUgb25seSEpXG4gICAgICBsZXQgZ2wgPSBzdGF0ZS5nbDtcbiAgICAgIGlmICghc3RhdGUuZ2wpIHN0YXRlLnNldCh7XG4gICAgICAgIGdsOiBnbCA9IGNyZWF0ZVJlbmRlcmVySW5zdGFuY2UoZ2xDb25maWcsIGNhbnZhcylcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTZXQgdXAgcmF5Y2FzdGVyIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGxldCByYXljYXN0ZXIgPSBzdGF0ZS5yYXljYXN0ZXI7XG4gICAgICBpZiAoIXJheWNhc3Rlcikgc3RhdGUuc2V0KHtcbiAgICAgICAgcmF5Y2FzdGVyOiByYXljYXN0ZXIgPSBuZXcgVEhSRUUuUmF5Y2FzdGVyKClcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTZXQgcmF5Y2FzdGVyIG9wdGlvbnNcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9ID0gcmF5Y2FzdE9wdGlvbnMgfHwge307XG4gICAgICBpZiAoIWlzLmVxdShvcHRpb25zLCByYXljYXN0ZXIsIHNoYWxsb3dMb29zZSkpIGFwcGx5UHJvcHMocmF5Y2FzdGVyLCB7XG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpcy5lcXUocGFyYW1zLCByYXljYXN0ZXIucGFyYW1zLCBzaGFsbG93TG9vc2UpKSBhcHBseVByb3BzKHJheWNhc3Rlciwge1xuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAuLi5yYXljYXN0ZXIucGFyYW1zLFxuICAgICAgICAgIC4uLnBhcmFtc1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgY2FtZXJhLCBkb24ndCBvdmVyd3JpdGUgYW55IHVzZXItc2V0IHN0YXRlXG4gICAgICBpZiAoIXN0YXRlLmNhbWVyYSB8fCBzdGF0ZS5jYW1lcmEgPT09IGxhc3RDYW1lcmEgJiYgIWlzLmVxdShsYXN0Q2FtZXJhLCBjYW1lcmFPcHRpb25zLCBzaGFsbG93TG9vc2UpKSB7XG4gICAgICAgIGxhc3RDYW1lcmEgPSBjYW1lcmFPcHRpb25zO1xuICAgICAgICBjb25zdCBpc0NhbWVyYSA9IGNhbWVyYU9wdGlvbnMgaW5zdGFuY2VvZiBUSFJFRS5DYW1lcmE7XG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IGlzQ2FtZXJhID8gY2FtZXJhT3B0aW9ucyA6IG9ydGhvZ3JhcGhpYyA/IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoMCwgMCwgMCwgMCwgMC4xLCAxMDAwKSA6IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg3NSwgMCwgMC4xLCAxMDAwKTtcbiAgICAgICAgaWYgKCFpc0NhbWVyYSkge1xuICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi56ID0gNTtcbiAgICAgICAgICBpZiAoY2FtZXJhT3B0aW9ucykgYXBwbHlQcm9wcyhjYW1lcmEsIGNhbWVyYU9wdGlvbnMpO1xuICAgICAgICAgIC8vIEFsd2F5cyBsb29rIGF0IGNlbnRlciBieSBkZWZhdWx0XG4gICAgICAgICAgaWYgKCFzdGF0ZS5jYW1lcmEgJiYgIShjYW1lcmFPcHRpb25zICE9IG51bGwgJiYgY2FtZXJhT3B0aW9ucy5yb3RhdGlvbikpIGNhbWVyYS5sb29rQXQoMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICBjYW1lcmFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ29uZmlndXJlIHJheWNhc3RlclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXhyL2lzc3Vlcy8zMDBcbiAgICAgICAgcmF5Y2FzdGVyLmNhbWVyYSA9IGNhbWVyYTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHVwIHNjZW5lIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGlmICghc3RhdGUuc2NlbmUpIHtcbiAgICAgICAgbGV0IHNjZW5lO1xuICAgICAgICBpZiAoc2NlbmVPcHRpb25zIGluc3RhbmNlb2YgVEhSRUUuU2NlbmUpIHtcbiAgICAgICAgICBzY2VuZSA9IHNjZW5lT3B0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICAgICAgICAgIGlmIChzY2VuZU9wdGlvbnMpIGFwcGx5UHJvcHMoc2NlbmUsIHNjZW5lT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICBzY2VuZTogcHJlcGFyZShzY2VuZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB1cCBYUiAob25lIHRpbWUgb25seSEpXG4gICAgICBpZiAoIXN0YXRlLnhyKSB7XG4gICAgICAgIHZhciBfZ2wkeHI7XG4gICAgICAgIC8vIEhhbmRsZSBmcmFtZSBiZWhhdmlvciBpbiBXZWJYUlxuICAgICAgICBjb25zdCBoYW5kbGVYUkZyYW1lID0gKHRpbWVzdGFtcCwgZnJhbWUpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgaWYgKHN0YXRlLmZyYW1lbG9vcCA9PT0gJ25ldmVyJykgcmV0dXJuO1xuICAgICAgICAgIGFkdmFuY2UodGltZXN0YW1wLCB0cnVlLCBzdGF0ZSwgZnJhbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRvZ2dsZSByZW5kZXIgc3dpdGNoaW5nIG9uIHNlc3Npb25cbiAgICAgICAgY29uc3QgaGFuZGxlU2Vzc2lvbkNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgc3RhdGUuZ2wueHIuZW5hYmxlZCA9IHN0YXRlLmdsLnhyLmlzUHJlc2VudGluZztcbiAgICAgICAgICBzdGF0ZS5nbC54ci5zZXRBbmltYXRpb25Mb29wKHN0YXRlLmdsLnhyLmlzUHJlc2VudGluZyA/IGhhbmRsZVhSRnJhbWUgOiBudWxsKTtcbiAgICAgICAgICBpZiAoIXN0YXRlLmdsLnhyLmlzUHJlc2VudGluZykgaW52YWxpZGF0ZShzdGF0ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gV2ViWFIgc2Vzc2lvbiBtYW5hZ2VyXG4gICAgICAgIGNvbnN0IHhyID0ge1xuICAgICAgICAgIGNvbm5lY3QoKSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHN0b3JlLmdldFN0YXRlKCkuZ2w7XG4gICAgICAgICAgICBnbC54ci5hZGRFdmVudExpc3RlbmVyKCdzZXNzaW9uc3RhcnQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICAgIGdsLnhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25lbmQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHN0b3JlLmdldFN0YXRlKCkuZ2w7XG4gICAgICAgICAgICBnbC54ci5yZW1vdmVFdmVudExpc3RlbmVyKCdzZXNzaW9uc3RhcnQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICAgIGdsLnhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25lbmQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIFdlYlhSIHNlc3Npb24gZXZlbnRzXG4gICAgICAgIGlmICh0eXBlb2YgKChfZ2wkeHIgPSBnbC54cikgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbCR4ci5hZGRFdmVudExpc3RlbmVyKSA9PT0gJ2Z1bmN0aW9uJykgeHIuY29ubmVjdCgpO1xuICAgICAgICBzdGF0ZS5zZXQoe1xuICAgICAgICAgIHhyXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgc2hhZG93bWFwXG4gICAgICBpZiAoZ2wuc2hhZG93TWFwKSB7XG4gICAgICAgIGNvbnN0IG9sZEVuYWJsZWQgPSBnbC5zaGFkb3dNYXAuZW5hYmxlZDtcbiAgICAgICAgY29uc3Qgb2xkVHlwZSA9IGdsLnNoYWRvd01hcC50eXBlO1xuICAgICAgICBnbC5zaGFkb3dNYXAuZW5hYmxlZCA9ICEhc2hhZG93cztcbiAgICAgICAgaWYgKGlzLmJvbyhzaGFkb3dzKSkge1xuICAgICAgICAgIGdsLnNoYWRvd01hcC50eXBlID0gVEhSRUUuUENGU29mdFNoYWRvd01hcDtcbiAgICAgICAgfSBlbHNlIGlmIChpcy5zdHIoc2hhZG93cykpIHtcbiAgICAgICAgICB2YXIgX3R5cGVzJHNoYWRvd3M7XG4gICAgICAgICAgY29uc3QgdHlwZXMgPSB7XG4gICAgICAgICAgICBiYXNpYzogVEhSRUUuQmFzaWNTaGFkb3dNYXAsXG4gICAgICAgICAgICBwZXJjZW50YWdlOiBUSFJFRS5QQ0ZTaGFkb3dNYXAsXG4gICAgICAgICAgICBzb2Z0OiBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwLFxuICAgICAgICAgICAgdmFyaWFuY2U6IFRIUkVFLlZTTVNoYWRvd01hcFxuICAgICAgICAgIH07XG4gICAgICAgICAgZ2wuc2hhZG93TWFwLnR5cGUgPSAoX3R5cGVzJHNoYWRvd3MgPSB0eXBlc1tzaGFkb3dzXSkgIT0gbnVsbCA/IF90eXBlcyRzaGFkb3dzIDogVEhSRUUuUENGU29mdFNoYWRvd01hcDtcbiAgICAgICAgfSBlbHNlIGlmIChpcy5vYmooc2hhZG93cykpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGdsLnNoYWRvd01hcCwgc2hhZG93cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZEVuYWJsZWQgIT09IGdsLnNoYWRvd01hcC5lbmFibGVkIHx8IG9sZFR5cGUgIT09IGdsLnNoYWRvd01hcC50eXBlKSBnbC5zaGFkb3dNYXAubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBTYWZlbHkgc2V0IGNvbG9yIG1hbmFnZW1lbnQgaWYgYXZhaWxhYmxlLlxuICAgICAgLy8gQXZvaWQgYWNjZXNzaW5nIFRIUkVFLkNvbG9yTWFuYWdlbWVudCB0byBwbGF5IG5pY2Ugd2l0aCBvbGRlciB2ZXJzaW9uc1xuICAgICAgY29uc3QgQ29sb3JNYW5hZ2VtZW50ID0gZ2V0Q29sb3JNYW5hZ2VtZW50KCk7XG4gICAgICBpZiAoQ29sb3JNYW5hZ2VtZW50KSB7XG4gICAgICAgIGlmICgnZW5hYmxlZCcgaW4gQ29sb3JNYW5hZ2VtZW50KSBDb2xvck1hbmFnZW1lbnQuZW5hYmxlZCA9ICFsZWdhY3k7ZWxzZSBpZiAoJ2xlZ2FjeU1vZGUnIGluIENvbG9yTWFuYWdlbWVudCkgQ29sb3JNYW5hZ2VtZW50LmxlZ2FjeU1vZGUgPSBsZWdhY3k7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCBjb2xvciBzcGFjZSBhbmQgdG9uZW1hcHBpbmcgcHJlZmVyZW5jZXNcbiAgICAgIGNvbnN0IExpbmVhckVuY29kaW5nID0gMzAwMDtcbiAgICAgIGNvbnN0IHNSR0JFbmNvZGluZyA9IDMwMDE7XG4gICAgICBhcHBseVByb3BzKGdsLCB7XG4gICAgICAgIG91dHB1dEVuY29kaW5nOiBsaW5lYXIgPyBMaW5lYXJFbmNvZGluZyA6IHNSR0JFbmNvZGluZyxcbiAgICAgICAgdG9uZU1hcHBpbmc6IGZsYXQgPyBUSFJFRS5Ob1RvbmVNYXBwaW5nIDogVEhSRUUuQUNFU0ZpbG1pY1RvbmVNYXBwaW5nXG4gICAgICB9KTtcblxuICAgICAgLy8gVXBkYXRlIGNvbG9yIG1hbmFnZW1lbnQgc3RhdGVcbiAgICAgIGlmIChzdGF0ZS5sZWdhY3kgIT09IGxlZ2FjeSkgc3RhdGUuc2V0KCgpID0+ICh7XG4gICAgICAgIGxlZ2FjeVxuICAgICAgfSkpO1xuICAgICAgaWYgKHN0YXRlLmxpbmVhciAhPT0gbGluZWFyKSBzdGF0ZS5zZXQoKCkgPT4gKHtcbiAgICAgICAgbGluZWFyXG4gICAgICB9KSk7XG4gICAgICBpZiAoc3RhdGUuZmxhdCAhPT0gZmxhdCkgc3RhdGUuc2V0KCgpID0+ICh7XG4gICAgICAgIGZsYXRcbiAgICAgIH0pKTtcblxuICAgICAgLy8gU2V0IGdsIHByb3BzXG4gICAgICBpZiAoZ2xDb25maWcgJiYgIWlzLmZ1bihnbENvbmZpZykgJiYgIWlzUmVuZGVyZXIoZ2xDb25maWcpICYmICFpcy5lcXUoZ2xDb25maWcsIGdsLCBzaGFsbG93TG9vc2UpKSBhcHBseVByb3BzKGdsLCBnbENvbmZpZyk7XG4gICAgICAvLyBTdG9yZSBldmVudHMgaW50ZXJuYWxseVxuICAgICAgaWYgKGV2ZW50cyAmJiAhc3RhdGUuZXZlbnRzLmhhbmRsZXJzKSBzdGF0ZS5zZXQoe1xuICAgICAgICBldmVudHM6IGV2ZW50cyhzdG9yZSlcbiAgICAgIH0pO1xuICAgICAgLy8gQ2hlY2sgc2l6ZSwgYWxsb3cgaXQgdG8gdGFrZSBvbiBjb250YWluZXIgYm91bmRzIGluaXRpYWxseVxuICAgICAgY29uc3Qgc2l6ZSA9IGNvbXB1dGVJbml0aWFsU2l6ZShjYW52YXMsIHByb3BzU2l6ZSk7XG4gICAgICBpZiAoIWlzLmVxdShzaXplLCBzdGF0ZS5zaXplLCBzaGFsbG93TG9vc2UpKSB7XG4gICAgICAgIHN0YXRlLnNldFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHNpemUudXBkYXRlU3R5bGUsIHNpemUudG9wLCBzaXplLmxlZnQpO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgcGl4ZWxyYXRpb1xuICAgICAgaWYgKGRwciAmJiBzdGF0ZS52aWV3cG9ydC5kcHIgIT09IGNhbGN1bGF0ZURwcihkcHIpKSBzdGF0ZS5zZXREcHIoZHByKTtcbiAgICAgIC8vIENoZWNrIGZyYW1lbG9vcFxuICAgICAgaWYgKHN0YXRlLmZyYW1lbG9vcCAhPT0gZnJhbWVsb29wKSBzdGF0ZS5zZXRGcmFtZWxvb3AoZnJhbWVsb29wKTtcbiAgICAgIC8vIENoZWNrIHBvaW50ZXIgbWlzc2VkXG4gICAgICBpZiAoIXN0YXRlLm9uUG9pbnRlck1pc3NlZCkgc3RhdGUuc2V0KHtcbiAgICAgICAgb25Qb2ludGVyTWlzc2VkXG4gICAgICB9KTtcbiAgICAgIC8vIENoZWNrIHBlcmZvcm1hbmNlXG4gICAgICBpZiAocGVyZm9ybWFuY2UgJiYgIWlzLmVxdShwZXJmb3JtYW5jZSwgc3RhdGUucGVyZm9ybWFuY2UsIHNoYWxsb3dMb29zZSkpIHN0YXRlLnNldChzdGF0ZSA9PiAoe1xuICAgICAgICBwZXJmb3JtYW5jZToge1xuICAgICAgICAgIC4uLnN0YXRlLnBlcmZvcm1hbmNlLFxuICAgICAgICAgIC4uLnBlcmZvcm1hbmNlXG4gICAgICAgIH1cbiAgICAgIH0pKTtcblxuICAgICAgLy8gU2V0IGxvY2Fsc1xuICAgICAgb25DcmVhdGVkID0gb25DcmVhdGVkQ2FsbGJhY2s7XG4gICAgICBjb25maWd1cmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVuZGVyKGNoaWxkcmVuKSB7XG4gICAgICAvLyBUaGUgcm9vdCBoYXMgdG8gYmUgY29uZmlndXJlZCBiZWZvcmUgaXQgY2FuIGJlIHJlbmRlcmVkXG4gICAgICBpZiAoIWNvbmZpZ3VyZWQpIHRoaXMuY29uZmlndXJlKCk7XG4gICAgICByZWNvbmNpbGVyLnVwZGF0ZUNvbnRhaW5lciggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUHJvdmlkZXIsIHtcbiAgICAgICAgc3RvcmU6IHN0b3JlLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIG9uQ3JlYXRlZDogb25DcmVhdGVkLFxuICAgICAgICByb290RWxlbWVudDogY2FudmFzXG4gICAgICB9KSwgZmliZXIsIG51bGwsICgpID0+IHVuZGVmaW5lZCk7XG4gICAgICByZXR1cm4gc3RvcmU7XG4gICAgfSxcbiAgICB1bm1vdW50KCkge1xuICAgICAgdW5tb3VudENvbXBvbmVudEF0Tm9kZShjYW52YXMpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJlbmRlcihjaGlsZHJlbiwgY2FudmFzLCBjb25maWcpIHtcbiAgY29uc29sZS53YXJuKCdSM0YucmVuZGVyIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgaW4gUmVhY3QgMTguIFVzZSBjcmVhdGVSb290IGluc3RlYWQhJyk7XG4gIGNvbnN0IHJvb3QgPSBjcmVhdGVSb290KGNhbnZhcyk7XG4gIHJvb3QuY29uZmlndXJlKGNvbmZpZyk7XG4gIHJldHVybiByb290LnJlbmRlcihjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBQcm92aWRlcih7XG4gIHN0b3JlLFxuICBjaGlsZHJlbixcbiAgb25DcmVhdGVkLFxuICByb290RWxlbWVudFxufSkge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgLy8gRmxhZyB0aGUgY2FudmFzIGFjdGl2ZSwgcmVuZGVyaW5nIHdpbGwgbm93IGJlZ2luXG4gICAgc3RhdGUuc2V0KHN0YXRlID0+ICh7XG4gICAgICBpbnRlcm5hbDoge1xuICAgICAgICAuLi5zdGF0ZS5pbnRlcm5hbCxcbiAgICAgICAgYWN0aXZlOiB0cnVlXG4gICAgICB9XG4gICAgfSkpO1xuICAgIC8vIE5vdGlmaXkgdGhhdCBpbml0IGlzIGNvbXBsZXRlZCwgdGhlIHNjZW5lIGdyYXBoIGV4aXN0cywgYnV0IG5vdGhpbmcgaGFzIHlldCByZW5kZXJlZFxuICAgIGlmIChvbkNyZWF0ZWQpIG9uQ3JlYXRlZChzdGF0ZSk7XG4gICAgLy8gQ29ubmVjdCBldmVudHMgdG8gdGhlIHRhcmdldHMgcGFyZW50LCB0aGlzIGlzIGRvbmUgdG8gZW5zdXJlIGV2ZW50cyBhcmUgcmVnaXN0ZXJlZCBvblxuICAgIC8vIGEgc2hhcmVkIHRhcmdldCwgYW5kIG5vdCBvbiB0aGUgY2FudmFzIGl0c2VsZlxuICAgIGlmICghc3RvcmUuZ2V0U3RhdGUoKS5ldmVudHMuY29ubmVjdGVkKSBzdGF0ZS5ldmVudHMuY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbm5lY3Qocm9vdEVsZW1lbnQpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzdG9yZVxuICB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNhbnZhcywgY2FsbGJhY2spIHtcbiAgY29uc3Qgcm9vdCA9IHJvb3RzLmdldChjYW52YXMpO1xuICBjb25zdCBmaWJlciA9IHJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3QuZmliZXI7XG4gIGlmIChmaWJlcikge1xuICAgIGNvbnN0IHN0YXRlID0gcm9vdCA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZSkgc3RhdGUuaW50ZXJuYWwuYWN0aXZlID0gZmFsc2U7XG4gICAgcmVjb25jaWxlci51cGRhdGVDb250YWluZXIobnVsbCwgZmliZXIsIG51bGwsICgpID0+IHtcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9zdGF0ZSRnbCwgX3N0YXRlJGdsJHJlbmRlckxpc3RzLCBfc3RhdGUkZ2wyLCBfc3RhdGUkZ2wzO1xuICAgICAgICAgICAgc3RhdGUuZXZlbnRzLmRpc2Nvbm5lY3QgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmV2ZW50cy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAoX3N0YXRlJGdsID0gc3RhdGUuZ2wpID09IG51bGwgPyB2b2lkIDAgOiAoX3N0YXRlJGdsJHJlbmRlckxpc3RzID0gX3N0YXRlJGdsLnJlbmRlckxpc3RzKSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsJHJlbmRlckxpc3RzLmRpc3Bvc2UgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRnbCRyZW5kZXJMaXN0cy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAoX3N0YXRlJGdsMiA9IHN0YXRlLmdsKSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsMi5mb3JjZUNvbnRleHRMb3NzID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZ2wyLmZvcmNlQ29udGV4dExvc3MoKTtcbiAgICAgICAgICAgIGlmICgoX3N0YXRlJGdsMyA9IHN0YXRlLmdsKSAhPSBudWxsICYmIF9zdGF0ZSRnbDMueHIpIHN0YXRlLnhyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGRpc3Bvc2Uoc3RhdGUpO1xuICAgICAgICAgICAgcm9vdHMuZGVsZXRlKGNhbnZhcyk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGNhbnZhcyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLyogLi4uICovXG4gICAgICAgICAgfVxuICAgICAgICB9LCA1MDApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lciwgc3RhdGUpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBvcnRhbCwge1xuICAgIGtleTogY29udGFpbmVyLnV1aWQsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgIHN0YXRlOiBzdGF0ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIFBvcnRhbCh7XG4gIHN0YXRlID0ge30sXG4gIGNoaWxkcmVuLFxuICBjb250YWluZXJcbn0pIHtcbiAgLyoqIFRoaXMgaGFzIHRvIGJlIGEgY29tcG9uZW50IGJlY2F1c2UgaXQgd291bGQgbm90IGJlIGFibGUgdG8gY2FsbCB1c2VUaHJlZS91c2VTdG9yZSBvdGhlcndpc2Ugc2luY2VcbiAgICogIGlmIHRoaXMgaXMgb3VyIGVudmlyb25tZW50LCB0aGVuIHdlIGFyZSBub3QgaW4gcjNmJ3MgcmVuZGVyZXIgYnV0IGluIHJlYWN0LWRvbSwgaXQgd291bGQgdHJpZ2dlclxuICAgKiAgdGhlIFwiUjNGIGhvb2tzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aGluIHRoZSBDYW52YXMgY29tcG9uZW50IVwiIHdhcm5pbmc6XG4gICAqICA8Q2FudmFzPlxuICAgKiAgICB7Y3JlYXRlUG9ydGFsKC4uLil9ICovXG4gIGNvbnN0IHtcbiAgICBldmVudHMsXG4gICAgc2l6ZSxcbiAgICAuLi5yZXN0XG4gIH0gPSBzdGF0ZTtcbiAgY29uc3QgcHJldmlvdXNSb290ID0gdXNlU3RvcmUoKTtcbiAgY29uc3QgW3JheWNhc3Rlcl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgVEhSRUUuUmF5Y2FzdGVyKCkpO1xuICBjb25zdCBbcG9pbnRlcl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgVEhSRUUuVmVjdG9yMigpKTtcbiAgY29uc3QgaW5qZWN0ID0gUmVhY3QudXNlQ2FsbGJhY2soKHJvb3RTdGF0ZSwgaW5qZWN0U3RhdGUpID0+IHtcbiAgICBjb25zdCBpbnRlcnNlY3QgPSB7XG4gICAgICAuLi5yb290U3RhdGVcbiAgICB9OyAvLyBhbGwgcHJldiBzdGF0ZSBwcm9wc1xuXG4gICAgLy8gT25seSB0aGUgZmllbGRzIG9mIFwicm9vdFN0YXRlXCIgdGhhdCBkbyBub3QgZGlmZmVyIGZyb20gaW5qZWN0U3RhdGVcbiAgICAvLyBTb21lIHByb3BzIHNob3VsZCBiZSBvZmYtbGltaXRzXG4gICAgLy8gT3RoZXJ3aXNlIGZpbHRlciBvdXQgdGhlIHByb3BzIHRoYXQgYXJlIGRpZmZlcmVudCBhbmQgbGV0IHRoZSBpbmplY3QgbGF5ZXIgdGFrZSBwcmVjZWRlbmNlXG4gICAgT2JqZWN0LmtleXMocm9vdFN0YXRlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAvLyBTb21lIHByb3BzIHNob3VsZCBiZSBvZmYtbGltaXRzXG4gICAgICBwcml2YXRlS2V5cy5pbmNsdWRlcyhrZXkpIHx8XG4gICAgICAvLyBPdGhlcndpc2UgZmlsdGVyIG91dCB0aGUgcHJvcHMgdGhhdCBhcmUgZGlmZmVyZW50IGFuZCBsZXQgdGhlIGluamVjdCBsYXllciB0YWtlIHByZWNlZGVuY2VcbiAgICAgIC8vIFVubGVzcyB0aGUgaW5qZWN0IGxheWVyIHByb3BzIGlzIHVuZGVmaW5lZCwgdGhlbiB3ZSBrZWVwIHRoZSByb290IGxheWVyXG4gICAgICByb290U3RhdGVba2V5XSAhPT0gaW5qZWN0U3RhdGVba2V5XSAmJiBpbmplY3RTdGF0ZVtrZXldKSB7XG4gICAgICAgIGRlbGV0ZSBpbnRlcnNlY3Rba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgdmlld3BvcnQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGluamVjdFN0YXRlICYmIHNpemUpIHtcbiAgICAgIGNvbnN0IGNhbWVyYSA9IGluamVjdFN0YXRlLmNhbWVyYTtcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgb3ZlcnJpZGUgdmlld3BvcnQsIGlmIHByZXNlbnRcbiAgICAgIHZpZXdwb3J0ID0gcm9vdFN0YXRlLnZpZXdwb3J0LmdldEN1cnJlbnRWaWV3cG9ydChjYW1lcmEsIG5ldyBUSFJFRS5WZWN0b3IzKCksIHNpemUpO1xuICAgICAgLy8gVXBkYXRlIHRoZSBwb3J0YWwgY2FtZXJhLCBpZiBpdCBkaWZmZXJzIGZyb20gdGhlIHByZXZpb3VzIGxheWVyXG4gICAgICBpZiAoY2FtZXJhICE9PSByb290U3RhdGUuY2FtZXJhKSB1cGRhdGVDYW1lcmEoY2FtZXJhLCBzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFRoZSBpbnRlcnNlY3QgY29uc2lzdHMgb2YgdGhlIHByZXZpb3VzIHJvb3Qgc3RhdGVcbiAgICAgIC4uLmludGVyc2VjdCxcbiAgICAgIC8vIFBvcnRhbHMgaGF2ZSB0aGVpciBvd24gc2NlbmUsIHdoaWNoIGZvcm1zIHRoZSByb290LCBhIHJheWNhc3RlciBhbmQgYSBwb2ludGVyXG4gICAgICBzY2VuZTogY29udGFpbmVyLFxuICAgICAgcmF5Y2FzdGVyLFxuICAgICAgcG9pbnRlcixcbiAgICAgIG1vdXNlOiBwb2ludGVyLFxuICAgICAgLy8gVGhlaXIgcHJldmlvdXMgcm9vdCBpcyB0aGUgbGF5ZXIgYmVmb3JlIGl0XG4gICAgICBwcmV2aW91c1Jvb3QsXG4gICAgICAvLyBFdmVudHMsIHNpemUgYW5kIHZpZXdwb3J0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBpbmplY3QgbGF5ZXJcbiAgICAgIGV2ZW50czoge1xuICAgICAgICAuLi5yb290U3RhdGUuZXZlbnRzLFxuICAgICAgICAuLi4oaW5qZWN0U3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGluamVjdFN0YXRlLmV2ZW50cyksXG4gICAgICAgIC4uLmV2ZW50c1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgLi4ucm9vdFN0YXRlLnNpemUsXG4gICAgICAgIC4uLnNpemVcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICAuLi5yb290U3RhdGUudmlld3BvcnQsXG4gICAgICAgIC4uLnZpZXdwb3J0XG4gICAgICB9LFxuICAgICAgLi4ucmVzdFxuICAgIH07XG4gIH0sXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW3N0YXRlXSk7XG4gIGNvbnN0IFt1c2VQb3J0YWxTdG9yZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB7XG4gICAgLy8gQ3JlYXRlIGEgbWlycm9yZWQgc3RvcmUsIGJhc2VkIG9uIHRoZSBwcmV2aW91cyByb290IHdpdGggYSBmZXcgb3ZlcnJpZGVzIC4uLlxuICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBwcmV2aW91c1Jvb3QuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBzdG9yZSA9IGNyZWF0ZSgoc2V0LCBnZXQpID0+ICh7XG4gICAgICAuLi5wcmV2aW91c1N0YXRlLFxuICAgICAgc2NlbmU6IGNvbnRhaW5lcixcbiAgICAgIHJheWNhc3RlcixcbiAgICAgIHBvaW50ZXIsXG4gICAgICBtb3VzZTogcG9pbnRlcixcbiAgICAgIHByZXZpb3VzUm9vdCxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICAuLi5wcmV2aW91c1N0YXRlLmV2ZW50cyxcbiAgICAgICAgLi4uZXZlbnRzXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICAuLi5wcmV2aW91c1N0YXRlLnNpemUsXG4gICAgICAgIC4uLnNpemVcbiAgICAgIH0sXG4gICAgICAuLi5yZXN0LFxuICAgICAgLy8gU2V0IGFuZCBnZXQgcmVmZXIgdG8gdGhpcyByb290LXN0YXRlXG4gICAgICBzZXQsXG4gICAgICBnZXQsXG4gICAgICAvLyBMYXllcnMgYXJlIGFsbG93ZWQgdG8gb3ZlcnJpZGUgZXZlbnRzXG4gICAgICBzZXRFdmVudHM6IGV2ZW50cyA9PiBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIC4uLnN0YXRlLmV2ZW50cyxcbiAgICAgICAgICAuLi5ldmVudHNcbiAgICAgICAgfVxuICAgICAgfSkpXG4gICAgfSkpO1xuICAgIHJldHVybiBzdG9yZTtcbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gU3Vic2NyaWJlIHRvIHByZXZpb3VzIHJvb3Qtc3RhdGUgYW5kIGNvcHkgY2hhbmdlcyBvdmVyIHRvIHRoZSBtaXJyb3JlZCBwb3J0YWwtc3RhdGVcbiAgICBjb25zdCB1bnN1YiA9IHByZXZpb3VzUm9vdC5zdWJzY3JpYmUocHJldiA9PiB1c2VQb3J0YWxTdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiBpbmplY3QocHJldiwgc3RhdGUpKSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVuc3ViKCk7XG4gICAgICB1c2VQb3J0YWxTdG9yZS5kZXN0cm95KCk7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB1c2VQb3J0YWxTdG9yZS5zZXRTdGF0ZShpbmplY3RTdGF0ZSA9PiBpbmplY3QocHJldmlvdXNSb290LmdldFN0YXRlKCksIGluamVjdFN0YXRlKSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbaW5qZWN0XSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgcmVjb25jaWxlci5jcmVhdGVQb3J0YWwoIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KGNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdXNlUG9ydGFsU3RvcmVcbiAgfSwgY2hpbGRyZW4pLCB1c2VQb3J0YWxTdG9yZSwgbnVsbCkpO1xufVxucmVjb25jaWxlci5pbmplY3RJbnRvRGV2VG9vbHMoe1xuICBidW5kbGVUeXBlOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nID8gMCA6IDEsXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6ICdAcmVhY3QtdGhyZWUvZmliZXInLFxuICB2ZXJzaW9uOiBSZWFjdC52ZXJzaW9uXG59KTtcbmNvbnN0IGFjdCA9IFJlYWN0LnVuc3RhYmxlX2FjdDtcblxuZXhwb3J0IHsgdXNlVGhyZWUgYXMgQSwgQmxvY2sgYXMgQiwgdXNlRnJhbWUgYXMgQywgdXNlR3JhcGggYXMgRCwgRXJyb3JCb3VuZGFyeSBhcyBFLCB1c2VMb2FkZXIgYXMgRiwgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCBhcyBhLCBjcmVhdGVSb290IGFzIGIsIGNyZWF0ZUV2ZW50cyBhcyBjLCB1bm1vdW50Q29tcG9uZW50QXROb2RlIGFzIGQsIGV4dGVuZCBhcyBlLCBjb250ZXh0IGFzIGYsIGNyZWF0ZVBvcnRhbCBhcyBnLCByZWNvbmNpbGVyIGFzIGgsIGlzUmVmIGFzIGksIGFwcGx5UHJvcHMgYXMgaiwgZGlzcG9zZSBhcyBrLCBpbnZhbGlkYXRlIGFzIGwsIGFkdmFuY2UgYXMgbSwgYWRkRWZmZWN0IGFzIG4sIGFkZEFmdGVyRWZmZWN0IGFzIG8sIGFkZFRhaWwgYXMgcCwgZmx1c2hHbG9iYWxFZmZlY3RzIGFzIHEsIHJlbmRlciBhcyByLCBnZXRSb290U3RhdGUgYXMgcywgdGhyZWVUeXBlcyBhcyB0LCB1c2VNdXRhYmxlQ2FsbGJhY2sgYXMgdSwgYWN0IGFzIHYsIGJ1aWxkR3JhcGggYXMgdywgcm9vdHMgYXMgeCwgdXNlSW5zdGFuY2VIYW5kbGUgYXMgeSwgdXNlU3RvcmUgYXMgeiB9O1xuIl0sIm5hbWVzIjpbIlRIUkVFIiwiUmVhY3QiLCJEZWZhdWx0RXZlbnRQcmlvcml0eSIsIkNvbnRpbnVvdXNFdmVudFByaW9yaXR5IiwiRGlzY3JldGVFdmVudFByaW9yaXR5IiwiQ29uY3VycmVudFJvb3QiLCJjcmVhdGUiLCJSZWNvbmNpbGVyIiwidW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayIsInVuc3RhYmxlX0lkbGVQcmlvcml0eSIsInN1c3BlbmQiLCJwcmVsb2FkIiwiY2xlYXIiLCJ0aHJlZVR5cGVzIiwiT2JqZWN0IiwiZnJlZXplIiwiX19wcm90b19fIiwiY2F0YWxvZ3VlIiwiZXh0ZW5kIiwib2JqZWN0cyIsImFzc2lnbiIsImNyZWF0ZVJlbmRlcmVyIiwiX3Jvb3RzIiwiX2dldEV2ZW50UHJpb3JpdHkiLCJjcmVhdGVJbnN0YW5jZSIsInR5cGUiLCJhcmdzIiwiYXR0YWNoIiwicHJvcHMiLCJyb290IiwibmFtZSIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJpbnN0YW5jZSIsIm9iamVjdCIsInVuZGVmaW5lZCIsIkVycm9yIiwicHJlcGFyZSIsInByaW1pdGl2ZSIsInRhcmdldCIsIkFycmF5IiwiaXNBcnJheSIsIm1lbW9pemVkUHJvcHMiLCJfX3IzZiIsIkJ1ZmZlckdlb21ldHJ5IiwiTWF0ZXJpYWwiLCJhcHBseVByb3BzJDEiLCJhcHBlbmRDaGlsZCIsInBhcmVudEluc3RhbmNlIiwiY2hpbGQiLCJhZGRlZCIsIl9jaGlsZCRfX3IzZiIsIl9wYXJlbnRJbnN0YW5jZSRfX3IzZiIsImlzT2JqZWN0M0QiLCJhZGQiLCJwdXNoIiwicGFyZW50IiwidXBkYXRlSW5zdGFuY2UiLCJpbnZhbGlkYXRlSW5zdGFuY2UiLCJpbnNlcnRCZWZvcmUiLCJiZWZvcmVDaGlsZCIsIl9jaGlsZCRfX3IzZjIiLCJfcGFyZW50SW5zdGFuY2UkX19yM2YyIiwiZGlzcGF0Y2hFdmVudCIsInJlc3RTaWJsaW5ncyIsImNoaWxkcmVuIiwiZmlsdGVyIiwic2libGluZyIsImluZGV4IiwiaW5kZXhPZiIsInJlbW92ZVJlY3Vyc2l2ZSIsImFycmF5IiwiZGlzcG9zZSIsImZvckVhY2giLCJyZW1vdmVDaGlsZCIsIl9wYXJlbnRJbnN0YW5jZSRfX3IzZjMiLCJfY2hpbGQkX19yM2YzIiwiX2NoaWxkJF9fcjNmNSIsIngiLCJkZXRhY2giLCJfY2hpbGQkX19yM2Y0IiwicmVtb3ZlIiwicmVtb3ZlSW50ZXJhY3Rpdml0eSIsImZpbmRJbml0aWFsUm9vdCIsImlzUHJpbWl0aXZlIiwic2hvdWxkRGlzcG9zZSIsIl9jaGlsZCRfX3IzZjYiLCJjYWxsYmFjayIsImUiLCJJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQiLCJzd2l0Y2hJbnN0YW5jZSIsIm5ld1Byb3BzIiwiZmliZXIiLCJfaW5zdGFuY2UkX19yM2YiLCJuZXdJbnN0YW5jZSIsImF1dG9SZW1vdmVkQmVmb3JlQXBwZW5kIiwicmF5Y2FzdCIsImV2ZW50Q291bnQiLCJyb290U3RhdGUiLCJnZXRTdGF0ZSIsImludGVybmFsIiwiaW50ZXJhY3Rpb24iLCJhbHRlcm5hdGUiLCJzdGF0ZU5vZGUiLCJyZWYiLCJjdXJyZW50IiwiaGFuZGxlVGV4dEluc3RhbmNlIiwiY29uc29sZSIsIndhcm4iLCJyZWNvbmNpbGVyIiwiYXBwZW5kSW5pdGlhbENoaWxkIiwic3VwcG9ydHNNdXRhdGlvbiIsImlzUHJpbWFyeVJlbmRlcmVyIiwic3VwcG9ydHNQZXJzaXN0ZW5jZSIsInN1cHBvcnRzSHlkcmF0aW9uIiwibm9UaW1lb3V0IiwiYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciIsImNvbnRhaW5lciIsInNjZW5lIiwicmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyIiwiaW5zZXJ0SW5Db250YWluZXJCZWZvcmUiLCJnZXRSb290SG9zdENvbnRleHQiLCJnZXRDaGlsZEhvc3RDb250ZXh0IiwicGFyZW50SG9zdENvbnRleHQiLCJmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbiIsIl9pbnN0YW5jZSRfX3IzZjIiLCJsb2NhbFN0YXRlIiwiQm9vbGVhbiIsImhhbmRsZXJzIiwicHJlcGFyZVVwZGF0ZSIsIl90eXBlIiwib2xkUHJvcHMiLCJfaW5zdGFuY2UkX19yM2YzIiwiYXJnc05ldyIsImNOIiwicmVzdE5ldyIsImFyZ3NPbGQiLCJjTyIsInJlc3RPbGQiLCJzb21lIiwidmFsdWUiLCJkaWZmIiwiZGlmZlByb3BzIiwiY2hhbmdlcyIsImxlbmd0aCIsImNvbW1pdFVwZGF0ZSIsInJlY29uc3RydWN0IiwiX29sZFByb3BzIiwiY29tbWl0TW91bnQiLCJfcHJvcHMiLCJfaW50IiwiX2luc3RhbmNlJF9fcjNmNCIsImdldFB1YmxpY0luc3RhbmNlIiwicHJlcGFyZUZvckNvbW1pdCIsInByZXBhcmVQb3J0YWxNb3VudCIsInJlc2V0QWZ0ZXJDb21taXQiLCJzaG91bGRTZXRUZXh0Q29udGVudCIsImNsZWFyQ29udGFpbmVyIiwiaGlkZUluc3RhbmNlIiwiX2luc3RhbmNlJF9fcjNmNSIsInZpc2libGUiLCJ1bmhpZGVJbnN0YW5jZSIsIl9pbnN0YW5jZSRfX3IzZjYiLCJjcmVhdGVUZXh0SW5zdGFuY2UiLCJoaWRlVGV4dEluc3RhbmNlIiwidW5oaWRlVGV4dEluc3RhbmNlIiwiZ2V0Q3VycmVudEV2ZW50UHJpb3JpdHkiLCJiZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXIiLCJhZnRlckFjdGl2ZUluc3RhbmNlQmx1ciIsImRldGFjaERlbGV0ZWRJbnN0YW5jZSIsIm5vdyIsInBlcmZvcm1hbmNlIiwiaXMiLCJmdW4iLCJEYXRlIiwic2NoZWR1bGVUaW1lb3V0Iiwic2V0VGltZW91dCIsImNhbmNlbFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJhcHBseVByb3BzIiwiX3dpbmRvdyRkb2N1bWVudCIsIl93aW5kb3ckbmF2aWdhdG9yIiwiaGFzQ29sb3JTcGFjZSIsImdldENvbG9yTWFuYWdlbWVudCIsIl9Db2xvck1hbmFnZW1lbnQiLCJDb2xvck1hbmFnZW1lbnQiLCJpc09ydGhvZ3JhcGhpY0NhbWVyYSIsImRlZiIsImlzUmVmIiwib2JqIiwiaGFzT3duUHJvcGVydHkiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0Iiwid2luZG93IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwibmF2aWdhdG9yIiwicHJvZHVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsInVzZU11dGFibGVDYWxsYmFjayIsImZuIiwidXNlUmVmIiwiQmxvY2siLCJzZXQiLCJQcm9taXNlIiwiRXJyb3JCb3VuZGFyeSIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwic3RhdGUiLCJlcnJvciIsImNvbXBvbmVudERpZENhdGNoIiwiZXJyIiwicmVuZGVyIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiREVGQVVMVCIsIkRFRkFVTFRTIiwiTWFwIiwiaXNEaWZmU2V0IiwibWVtb2l6ZWQiLCJjYWxjdWxhdGVEcHIiLCJkcHIiLCJfd2luZG93JGRldmljZVBpeGVsUmEiLCJkZXZpY2VQaXhlbFJhdGlvIiwiTWF0aCIsIm1pbiIsIm1heCIsImdldFJvb3RTdGF0ZSIsIl9yM2YiLCJwcmV2aW91c1Jvb3QiLCJhIiwiYXJyIiwic3RyIiwibnVtIiwiYm9vIiwidW5kIiwiZXF1IiwiYiIsImFycmF5cyIsInN0cmljdCIsImlzT2JqIiwiaXNBcnIiLCJpIiwia2V5cyIsImJ1aWxkR3JhcGgiLCJkYXRhIiwibm9kZXMiLCJtYXRlcmlhbHMiLCJ0cmF2ZXJzZSIsIm1hdGVyaWFsIiwicCIsInByZXZpb3VzQXR0YWNoIiwicmVzb2x2ZSIsImtleSIsImluY2x1ZGVzIiwiZW50cmllcyIsInNwbGl0IiwibGFzdCIsInBvcCIsInJlZHVjZSIsImFjYyIsIklOREVYX1JFR0VYIiwidGVzdCIsInJlcGxhY2UiLCJwcmV2aW91cyIsImtOIiwick4iLCJjUCIsImtQIiwiclAiLCJwcmV2aW91c0tleXMiLCJ1bnNoaWZ0IiwicHJvcCIsInN0YXJ0c1dpdGgiLCJfX0RFVl9fIiwicHJvY2VzcyIsIl9yb290JGdldFN0YXRlIiwicHJldkhhbmRsZXJzIiwiaXNFdmVudCIsInNSR0JFbmNvZGluZyIsIlNSR0JDb2xvclNwYWNlIiwiTGluZWFyU1JHQkNvbG9yU3BhY2UiLCJjdXJyZW50SW5zdGFuY2UiLCJ0YXJnZXRQcm9wIiwicmV2ZXJzZUVudHJpZXMiLCJyZXZlcnNlIiwiY3RvciIsImdldCIsImNvcHkiLCJMYXllcnMiLCJmcm9tQXJyYXkiLCJpc0NvbG9yIiwiQ29sb3IiLCJzZXRTY2FsYXIiLCJtYXNrIiwibGluZWFyIiwiY29udmVydFNSR0JUb0xpbmVhciIsIlRleHR1cmUiLCJmb3JtYXQiLCJSR0JBRm9ybWF0IiwiVW5zaWduZWRCeXRlVHlwZSIsInRleHR1cmUiLCJnbCIsImNvbG9yU3BhY2UiLCJvdXRwdXRDb2xvclNwYWNlIiwiZW5jb2RpbmciLCJvdXRwdXRFbmNvZGluZyIsInNwbGljZSIsImlzQ2lyY3VsYXIiLCJfaW5zdGFuY2UkX19yM2Y1JHJvb3QiLCJmcmFtZXMiLCJpbnZhbGlkYXRlIiwib25VcGRhdGUiLCJ1cGRhdGVDYW1lcmEiLCJjYW1lcmEiLCJzaXplIiwibWFudWFsIiwibGVmdCIsIndpZHRoIiwicmlnaHQiLCJ0b3AiLCJoZWlnaHQiLCJib3R0b20iLCJhc3BlY3QiLCJ1cGRhdGVQcm9qZWN0aW9uTWF0cml4IiwidXBkYXRlTWF0cml4V29ybGQiLCJtYWtlSWQiLCJldmVudCIsImV2ZW50T2JqZWN0IiwidXVpZCIsImluc3RhbmNlSWQiLCJnZXRFdmVudFByaW9yaXR5IiwiX2dsb2JhbFNjb3BlJGV2ZW50IiwiZ2xvYmFsU2NvcGUiLCJzZWxmIiwicmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUiLCJjYXB0dXJlZE1hcCIsImNhcHR1cmVzIiwicG9pbnRlcklkIiwiY2FwdHVyZURhdGEiLCJkZWxldGUiLCJyZWxlYXNlUG9pbnRlckNhcHR1cmUiLCJzdG9yZSIsIm8iLCJpbml0aWFsSGl0cyIsImhvdmVyZWQiLCJjcmVhdGVFdmVudHMiLCJjYWxjdWxhdGVEaXN0YW5jZSIsImR4Iiwib2Zmc2V0WCIsImluaXRpYWxDbGljayIsImR5Iiwib2Zmc2V0WSIsInJvdW5kIiwic3FydCIsImZpbHRlclBvaW50ZXJFdmVudHMiLCJpbnRlcnNlY3QiLCJkdXBsaWNhdGVzIiwiU2V0IiwiaW50ZXJzZWN0aW9ucyIsImV2ZW50c09iamVjdHMiLCJyYXljYXN0ZXIiLCJldmVudHMiLCJjb21wdXRlIiwiaGFuZGxlUmF5Y2FzdCIsImVuYWJsZWQiLCJfc3RhdGUkcHJldmlvdXNSb290IiwiaW50ZXJzZWN0T2JqZWN0IiwiaGl0cyIsImZsYXRNYXAiLCJzb3J0IiwiYVN0YXRlIiwiYlN0YXRlIiwiZGlzdGFuY2UiLCJwcmlvcml0eSIsIml0ZW0iLCJpZCIsImhhcyIsImhpdCIsIl9yM2YyIiwidmFsdWVzIiwiaW50ZXJzZWN0aW9uIiwiaGFuZGxlSW50ZXJzZWN0cyIsImRlbHRhIiwic3RvcHBlZCIsInBvaW50ZXIiLCJ1bnByb2plY3RlZFBvaW50IiwiVmVjdG9yMyIsInkiLCJ1bnByb2plY3QiLCJoYXNQb2ludGVyQ2FwdHVyZSIsIl9pbnRlcm5hbCRjYXB0dXJlZE1hcCIsIl9pbnRlcm5hbCRjYXB0dXJlZE1hcDIiLCJzZXRQb2ludGVyQ2FwdHVyZSIsImV4dHJhY3RFdmVudFByb3BzIiwicHJvcGVydHkiLCJyYXljYXN0RXZlbnQiLCJyYXkiLCJzdG9wUHJvcGFnYXRpb24iLCJjYXB0dXJlc0ZvclBvaW50ZXIiLCJmcm9tIiwiZmluZCIsImhpZ2hlciIsImNhbmNlbFBvaW50ZXIiLCJjdXJyZW50VGFyZ2V0IiwibmF0aXZlRXZlbnQiLCJob3ZlcmVkT2JqIiwib25Qb2ludGVyT3V0Iiwib25Qb2ludGVyTGVhdmUiLCJwb2ludGVyTWlzc2VkIiwib25Qb2ludGVyTWlzc2VkIiwiaGFuZGxlUG9pbnRlciIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImhhbmRsZUV2ZW50IiwibGFzdEV2ZW50IiwiaXNQb2ludGVyTW92ZSIsImlzQ2xpY2tFdmVudCIsIm1hcCIsIm9uSW50ZXJzZWN0Iiwib25Qb2ludGVyT3ZlciIsIm9uUG9pbnRlckVudGVyIiwiaG92ZXJlZEl0ZW0iLCJvblBvaW50ZXJNb3ZlIiwiaGFuZGxlciIsInByaXZhdGVLZXlzIiwiaXNSZW5kZXJlciIsImNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiY3JlYXRlU3RvcmUiLCJhZHZhbmNlIiwicG9zaXRpb24iLCJkZWZhdWx0VGFyZ2V0IiwidGVtcFRhcmdldCIsImdldEN1cnJlbnRWaWV3cG9ydCIsImdldFdvcmxkUG9zaXRpb24iLCJkaXN0YW5jZVRvIiwiem9vbSIsImZhY3RvciIsImZvdiIsIlBJIiwiaCIsInRhbiIsInciLCJwZXJmb3JtYW5jZVRpbWVvdXQiLCJzZXRQZXJmb3JtYW5jZUN1cnJlbnQiLCJWZWN0b3IyIiwiY29ubmVjdGVkIiwieHIiLCJ0aW1lc3RhbXAiLCJydW5HbG9iYWxFZmZlY3RzIiwibGVnYWN5IiwiZmxhdCIsImNvbnRyb2xzIiwiY2xvY2siLCJDbG9jayIsIm1vdXNlIiwiZnJhbWVsb29wIiwiZGVib3VuY2UiLCJyZWdyZXNzIiwidXBkYXRlU3R5bGUiLCJ2aWV3cG9ydCIsImluaXRpYWxEcHIiLCJzZXRFdmVudHMiLCJzZXRTaXplIiwic2V0RHByIiwicmVzb2x2ZWQiLCJzZXRGcmFtZWxvb3AiLCJzdG9wIiwiZWxhcHNlZFRpbWUiLCJzdGFydCIsImFjdGl2ZSIsImNyZWF0ZVJlZiIsInN1YnNjcmliZXJzIiwic3Vic2NyaWJlIiwicyIsIm9sZFNpemUiLCJvbGREcHIiLCJvbGRDYW1lcmEiLCJfc2l6ZSR1cGRhdGVTdHlsZSIsInNldFBpeGVsUmF0aW8iLCJIVE1MQ2FudmFzRWxlbWVudCIsImRvbUVsZW1lbnQiLCJjcmVhdGVTdWJzIiwic3VicyIsInN1YiIsImdsb2JhbEVmZmVjdHMiLCJnbG9iYWxBZnRlckVmZmVjdHMiLCJnbG9iYWxUYWlsRWZmZWN0cyIsImFkZEVmZmVjdCIsImFkZEFmdGVyRWZmZWN0IiwiYWRkVGFpbCIsInJ1biIsImVmZmVjdHMiLCJmbHVzaEdsb2JhbEVmZmVjdHMiLCJzdWJzY3JpcHRpb24iLCJyZW5kZXIkMSIsImZyYW1lIiwiZ2V0RGVsdGEiLCJvbGRUaW1lIiwiY3JlYXRlTG9vcCIsInJvb3RzIiwicnVubmluZyIsInJlcGVhdCIsImxvb3AiLCJfc3RhdGUkZ2wkeHIiLCJpc1ByZXNlbnRpbmciLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIl9zdGF0ZSRnbCR4cjIiLCJ1c2VJbnN0YW5jZUhhbmRsZSIsInVzZVN0b3JlIiwidXNlQ29udGV4dCIsInVzZVRocmVlIiwic2VsZWN0b3IiLCJlcXVhbGl0eUZuIiwidXNlRnJhbWUiLCJyZW5kZXJQcmlvcml0eSIsInVzZUdyYXBoIiwidXNlTWVtbyIsIm1lbW9pemVkTG9hZGVycyIsIldlYWtNYXAiLCJsb2FkaW5nRm4iLCJleHRlbnNpb25zIiwib25Qcm9ncmVzcyIsIlByb3RvIiwiaW5wdXQiLCJsb2FkZXIiLCJhbGwiLCJyZXMiLCJyZWplY3QiLCJsb2FkIiwibWVzc2FnZSIsImZpbmFsbHkiLCJ1c2VMb2FkZXIiLCJyZXN1bHRzIiwiZXF1YWwiLCJzaGFsbG93TG9vc2UiLCJjcmVhdGVSZW5kZXJlckluc3RhbmNlIiwiY2FudmFzIiwiY3VzdG9tUmVuZGVyZXIiLCJXZWJHTFJlbmRlcmVyIiwicG93ZXJQcmVmZXJlbmNlIiwiYW50aWFsaWFzIiwiYWxwaGEiLCJjb21wdXRlSW5pdGlhbFNpemUiLCJkZWZhdWx0U2l6ZSIsImRlZmF1bHRTdHlsZSIsInBhcmVudEVsZW1lbnQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJPZmZzY3JlZW5DYW52YXMiLCJjcmVhdGVSb290IiwicHJldlJvb3QiLCJwcmV2RmliZXIiLCJwcmV2U3RvcmUiLCJsb2dSZWNvdmVyYWJsZUVycm9yIiwicmVwb3J0RXJyb3IiLCJjcmVhdGVDb250YWluZXIiLCJvbkNyZWF0ZWQiLCJjb25maWd1cmVkIiwibGFzdENhbWVyYSIsImNvbmZpZ3VyZSIsImdsQ29uZmlnIiwicHJvcHNTaXplIiwic2NlbmVPcHRpb25zIiwib25DcmVhdGVkQ2FsbGJhY2siLCJzaGFkb3dzIiwib3J0aG9ncmFwaGljIiwicmF5Y2FzdE9wdGlvbnMiLCJjYW1lcmFPcHRpb25zIiwiUmF5Y2FzdGVyIiwicGFyYW1zIiwib3B0aW9ucyIsImlzQ2FtZXJhIiwiQ2FtZXJhIiwiT3J0aG9ncmFwaGljQ2FtZXJhIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJ6Iiwicm90YXRpb24iLCJsb29rQXQiLCJTY2VuZSIsIl9nbCR4ciIsImhhbmRsZVhSRnJhbWUiLCJoYW5kbGVTZXNzaW9uQ2hhbmdlIiwic2V0QW5pbWF0aW9uTG9vcCIsImNvbm5lY3QiLCJhZGRFdmVudExpc3RlbmVyIiwiZGlzY29ubmVjdCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzaGFkb3dNYXAiLCJvbGRFbmFibGVkIiwib2xkVHlwZSIsIlBDRlNvZnRTaGFkb3dNYXAiLCJfdHlwZXMkc2hhZG93cyIsInR5cGVzIiwiYmFzaWMiLCJCYXNpY1NoYWRvd01hcCIsInBlcmNlbnRhZ2UiLCJQQ0ZTaGFkb3dNYXAiLCJzb2Z0IiwidmFyaWFuY2UiLCJWU01TaGFkb3dNYXAiLCJuZWVkc1VwZGF0ZSIsImxlZ2FjeU1vZGUiLCJMaW5lYXJFbmNvZGluZyIsInRvbmVNYXBwaW5nIiwiTm9Ub25lTWFwcGluZyIsIkFDRVNGaWxtaWNUb25lTWFwcGluZyIsInVwZGF0ZUNvbnRhaW5lciIsIlByb3ZpZGVyIiwicm9vdEVsZW1lbnQiLCJ1bm1vdW50IiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsImNvbmZpZyIsIl9zdGF0ZSRnbCIsIl9zdGF0ZSRnbCRyZW5kZXJMaXN0cyIsIl9zdGF0ZSRnbDIiLCJfc3RhdGUkZ2wzIiwicmVuZGVyTGlzdHMiLCJmb3JjZUNvbnRleHRMb3NzIiwiY3JlYXRlUG9ydGFsIiwiUG9ydGFsIiwicmVzdCIsInVzZVN0YXRlIiwiaW5qZWN0IiwidXNlQ2FsbGJhY2siLCJpbmplY3RTdGF0ZSIsInVzZVBvcnRhbFN0b3JlIiwicHJldmlvdXNTdGF0ZSIsInVuc3ViIiwicHJldiIsInNldFN0YXRlIiwiZGVzdHJveSIsIkZyYWdtZW50IiwiaW5qZWN0SW50b0RldlRvb2xzIiwiYnVuZGxlVHlwZSIsInJlbmRlcmVyUGFja2FnZU5hbWUiLCJ2ZXJzaW9uIiwiYWN0IiwidW5zdGFibGVfYWN0IiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJGIiwiYyIsImQiLCJmIiwiZyIsImoiLCJrIiwibCIsIm0iLCJuIiwicSIsInIiLCJ0IiwidSIsInYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/index-29b7121b.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Canvas: () => (/* binding */ Canvas),\n/* harmony export */   ReactThreeFiber: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   _roots: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   act: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   addAfterEffect: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   addEffect: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   addTail: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   advance: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   applyProps: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   buildGraph: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   context: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   createEvents: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   createPortal: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   createRoot: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   dispose: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   events: () => (/* binding */ createPointerEvents),\n/* harmony export */   extend: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   flushGlobalEffects: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   getRootState: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   invalidate: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   reconciler: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   render: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   unmountComponentAtNode: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   useFrame: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   useGraph: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   useInstanceHandle: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   useLoader: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   useStore: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   useThree: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.A)\n/* harmony export */ });\n/* harmony import */ var _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-29b7121b.esm.js */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-29b7121b.esm.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react_use_measure__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-use-measure */ \"(ssr)/./node_modules/react-use-measure/dist/web.js\");\n/* harmony import */ var its_fine__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! its-fine */ \"(ssr)/./node_modules/its-fine/dist/index.js\");\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst DOM_EVENTS = {\n    onClick: [\n        \"click\",\n        false\n    ],\n    onContextMenu: [\n        \"contextmenu\",\n        false\n    ],\n    onDoubleClick: [\n        \"dblclick\",\n        false\n    ],\n    onWheel: [\n        \"wheel\",\n        true\n    ],\n    onPointerDown: [\n        \"pointerdown\",\n        true\n    ],\n    onPointerUp: [\n        \"pointerup\",\n        true\n    ],\n    onPointerLeave: [\n        \"pointerleave\",\n        true\n    ],\n    onPointerMove: [\n        \"pointermove\",\n        true\n    ],\n    onPointerCancel: [\n        \"pointercancel\",\n        true\n    ],\n    onLostPointerCapture: [\n        \"lostpointercapture\",\n        true\n    ]\n};\n/** Default R3F event manager for web */ function createPointerEvents(store) {\n    const { handlePointer } = (0,_index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(store);\n    return {\n        priority: 1,\n        enabled: true,\n        compute (event, state, previous) {\n            // https://github.com/pmndrs/react-three-fiber/pull/782\n            // Events trigger outside of canvas when moved, use offsetX/Y by default and allow overrides\n            state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);\n            state.raycaster.setFromCamera(state.pointer, state.camera);\n        },\n        connected: undefined,\n        handlers: Object.keys(DOM_EVENTS).reduce((acc, key)=>({\n                ...acc,\n                [key]: handlePointer(key)\n            }), {}),\n        update: ()=>{\n            var _internal$lastEvent;\n            const { events, internal } = store.getState();\n            if ((_internal$lastEvent = internal.lastEvent) != null && _internal$lastEvent.current && events.handlers) events.handlers.onPointerMove(internal.lastEvent.current);\n        },\n        connect: (target)=>{\n            var _events$handlers;\n            const { set, events } = store.getState();\n            events.disconnect == null ? void 0 : events.disconnect();\n            set((state)=>({\n                    events: {\n                        ...state.events,\n                        connected: target\n                    }\n                }));\n            Object.entries((_events$handlers = events.handlers) != null ? _events$handlers : []).forEach(([name, event])=>{\n                const [eventName, passive] = DOM_EVENTS[name];\n                target.addEventListener(eventName, event, {\n                    passive\n                });\n            });\n        },\n        disconnect: ()=>{\n            const { set, events } = store.getState();\n            if (events.connected) {\n                var _events$handlers2;\n                Object.entries((_events$handlers2 = events.handlers) != null ? _events$handlers2 : []).forEach(([name, event])=>{\n                    if (events && events.connected instanceof HTMLElement) {\n                        const [eventName] = DOM_EVENTS[name];\n                        events.connected.removeEventListener(eventName, event);\n                    }\n                });\n                set((state)=>({\n                        events: {\n                            ...state.events,\n                            connected: undefined\n                        }\n                    }));\n            }\n        }\n    };\n}\nconst CanvasImpl = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(function Canvas({ children, fallback, resize, style, gl, events = createPointerEvents, eventSource, eventPrefix, shadows, linear, flat, legacy, orthographic, frameloop, dpr, performance, raycaster, camera, scene, onPointerMissed, onCreated, ...props }, forwardedRef) {\n    // Create a known catalogue of Threejs-native elements\n    // This will include the entire THREE namespace by default, users can extend\n    // their own elements by using the createRoot API instead\n    react__WEBPACK_IMPORTED_MODULE_2__.useMemo(()=>(0,_index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(three__WEBPACK_IMPORTED_MODULE_6__), []);\n    const Bridge = (0,its_fine__WEBPACK_IMPORTED_MODULE_7__.useContextBridge)();\n    const [containerRef, containerRect] = (0,react_use_measure__WEBPACK_IMPORTED_MODULE_8__[\"default\"])({\n        scroll: true,\n        debounce: {\n            scroll: 50,\n            resize: 0\n        },\n        ...resize\n    });\n    const canvasRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    const divRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_2__.useImperativeHandle(forwardedRef, ()=>canvasRef.current);\n    const handlePointerMissed = (0,_index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)(onPointerMissed);\n    const [block, setBlock] = react__WEBPACK_IMPORTED_MODULE_2__.useState(false);\n    const [error, setError] = react__WEBPACK_IMPORTED_MODULE_2__.useState(false);\n    // Suspend this component if block is a promise (2nd run)\n    if (block) throw block;\n    // Throw exception outwards if anything within canvas throws\n    if (error) throw error;\n    const root = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    (0,_index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(()=>{\n        const canvas = canvasRef.current;\n        if (containerRect.width > 0 && containerRect.height > 0 && canvas) {\n            if (!root.current) root.current = (0,_index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(canvas);\n            root.current.configure({\n                gl,\n                events,\n                shadows,\n                linear,\n                flat,\n                legacy,\n                orthographic,\n                frameloop,\n                dpr,\n                performance,\n                raycaster,\n                camera,\n                scene,\n                size: containerRect,\n                // Pass mutable reference to onPointerMissed so it's free to update\n                onPointerMissed: (...args)=>handlePointerMissed.current == null ? void 0 : handlePointerMissed.current(...args),\n                onCreated: (state)=>{\n                    // Connect to event source\n                    state.events.connect == null ? void 0 : state.events.connect(eventSource ? (0,_index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(eventSource) ? eventSource.current : eventSource : divRef.current);\n                    // Set up compute function\n                    if (eventPrefix) {\n                        state.setEvents({\n                            compute: (event, state)=>{\n                                const x = event[eventPrefix + \"X\"];\n                                const y = event[eventPrefix + \"Y\"];\n                                state.pointer.set(x / state.size.width * 2 - 1, -(y / state.size.height) * 2 + 1);\n                                state.raycaster.setFromCamera(state.pointer, state.camera);\n                            }\n                        });\n                    }\n                    // Call onCreated callback\n                    onCreated == null ? void 0 : onCreated(state);\n                }\n            });\n            root.current.render(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(Bridge, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(_index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.E, {\n                set: setError\n            }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Suspense, {\n                fallback: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(_index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.B, {\n                    set: setBlock\n                })\n            }, children))));\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_2__.useEffect(()=>{\n        const canvas = canvasRef.current;\n        if (canvas) return ()=>(0,_index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(canvas);\n    }, []);\n    // When the event source is not this div, we need to set pointer-events to none\n    // Or else the canvas will block events from reaching the event source\n    const pointerEvents = eventSource ? \"none\" : \"auto\";\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"div\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        ref: divRef,\n        style: {\n            position: \"relative\",\n            width: \"100%\",\n            height: \"100%\",\n            overflow: \"hidden\",\n            pointerEvents,\n            ...style\n        }\n    }, props), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"div\", {\n        ref: containerRef,\n        style: {\n            width: \"100%\",\n            height: \"100%\"\n        }\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"canvas\", {\n        ref: canvasRef,\n        style: {\n            display: \"block\"\n        }\n    }, fallback)));\n});\n/**\n * A DOM canvas which accepts threejs elements as children.\n * @see https://docs.pmnd.rs/react-three-fiber/api/canvas\n */ const Canvas = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(function CanvasWrapper(props, ref) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(its_fine__WEBPACK_IMPORTED_MODULE_7__.FiberProvider, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(CanvasImpl, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({}, props, {\n        ref: ref\n    })));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvcmVhY3QtdGhyZWUtZmliZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNE47QUFDeVI7QUFDM2I7QUFDM0I7QUFDQTtBQUNZO0FBQ2dCO0FBQ3ZCO0FBQ25CO0FBQ1M7QUFDUDtBQUNJO0FBRXZCLE1BQU1zRSxhQUFhO0lBQ2pCQyxTQUFTO1FBQUM7UUFBUztLQUFNO0lBQ3pCQyxlQUFlO1FBQUM7UUFBZTtLQUFNO0lBQ3JDQyxlQUFlO1FBQUM7UUFBWTtLQUFNO0lBQ2xDQyxTQUFTO1FBQUM7UUFBUztLQUFLO0lBQ3hCQyxlQUFlO1FBQUM7UUFBZTtLQUFLO0lBQ3BDQyxhQUFhO1FBQUM7UUFBYTtLQUFLO0lBQ2hDQyxnQkFBZ0I7UUFBQztRQUFnQjtLQUFLO0lBQ3RDQyxlQUFlO1FBQUM7UUFBZTtLQUFLO0lBQ3BDQyxpQkFBaUI7UUFBQztRQUFpQjtLQUFLO0lBQ3hDQyxzQkFBc0I7UUFBQztRQUFzQjtLQUFLO0FBQ3BEO0FBRUEsc0NBQXNDLEdBQ3RDLFNBQVNDLG9CQUFvQkMsS0FBSztJQUNoQyxNQUFNLEVBQ0pDLGFBQWEsRUFDZCxHQUFHbEYseURBQVlBLENBQUNpRjtJQUNqQixPQUFPO1FBQ0xFLFVBQVU7UUFDVkMsU0FBUztRQUNUQyxTQUFRQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsUUFBUTtZQUM1Qix1REFBdUQ7WUFDdkQsNEZBQTRGO1lBQzVGRCxNQUFNRSxPQUFPLENBQUNDLEdBQUcsQ0FBQ0osTUFBTUssT0FBTyxHQUFHSixNQUFNSyxJQUFJLENBQUNDLEtBQUssR0FBRyxJQUFJLEdBQUcsQ0FBRVAsQ0FBQUEsTUFBTVEsT0FBTyxHQUFHUCxNQUFNSyxJQUFJLENBQUNHLE1BQU0sSUFBSSxJQUFJO1lBQ3ZHUixNQUFNUyxTQUFTLENBQUNDLGFBQWEsQ0FBQ1YsTUFBTUUsT0FBTyxFQUFF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QUFPO1FBQ2hDLElBQUlzRCxRQUFRLE9BQU8sSUFBTXZKLHlEQUFzQkEsQ0FBQ3VKO0lBQ2xELEdBQUcsRUFBRTtJQUVMLCtFQUErRTtJQUMvRSxzRUFBc0U7SUFDdEUsTUFBTU8sZ0JBQWdCdkMsY0FBYyxTQUFTO0lBQzdDLE9BQU8sV0FBVyxHQUFFdkUsZ0RBQW1CLENBQUMsT0FBT0QsOEVBQVFBLENBQUM7UUFDdERnSCxLQUFLakI7UUFDTHpCLE9BQU87WUFDTDJDLFVBQVU7WUFDVm5GLE9BQU87WUFDUEUsUUFBUTtZQUNSa0YsVUFBVTtZQUNWSDtZQUNBLEdBQUd6QyxLQUFLO1FBQ1Y7SUFDRixHQUFHZSxRQUFRLFdBQVcsR0FBRXBGLGdEQUFtQixDQUFDLE9BQU87UUFDakQrRyxLQUFLdkI7UUFDTG5CLE9BQU87WUFDTHhDLE9BQU87WUFDUEUsUUFBUTtRQUNWO0lBQ0YsR0FBRyxXQUFXLEdBQUUvQixnREFBbUIsQ0FBQyxVQUFVO1FBQzVDK0csS0FBS25CO1FBQ0x2QixPQUFPO1lBQ0w2QyxTQUFTO1FBQ1g7SUFDRixHQUFHL0M7QUFDTDtBQUVBOzs7Q0FHQyxHQUNELE1BQU1GLFNBQVMsV0FBVyxHQUFFakUsNkNBQWdCLENBQUMsU0FBU21ILGNBQWMvQixLQUFLLEVBQUUyQixHQUFHO0lBQzVFLE9BQU8sV0FBVyxHQUFFL0csZ0RBQW1CLENBQUNHLG1EQUFhQSxFQUFFLE1BQU0sV0FBVyxHQUFFSCxnREFBbUIsQ0FBQytELFlBQVloRSw4RUFBUUEsQ0FBQyxDQUFDLEdBQUdxRixPQUFPO1FBQzVIMkIsS0FBS0E7SUFDUDtBQUNGO0FBRWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2hhaXNhYm0vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvcmVhY3QtdGhyZWUtZmliZXIuZXNtLmpzPzc5Y2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYyBhcyBjcmVhdGVFdmVudHMsIGUgYXMgZXh0ZW5kLCB1IGFzIHVzZU11dGFibGVDYWxsYmFjaywgYSBhcyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LCBiIGFzIGNyZWF0ZVJvb3QsIGkgYXMgaXNSZWYsIEUgYXMgRXJyb3JCb3VuZGFyeSwgQiBhcyBCbG9jaywgZCBhcyB1bm1vdW50Q29tcG9uZW50QXROb2RlIH0gZnJvbSAnLi9pbmRleC0yOWI3MTIxYi5lc20uanMnO1xuZXhwb3J0IHsgdCBhcyBSZWFjdFRocmVlRmliZXIsIHggYXMgX3Jvb3RzLCB2IGFzIGFjdCwgbyBhcyBhZGRBZnRlckVmZmVjdCwgbiBhcyBhZGRFZmZlY3QsIHAgYXMgYWRkVGFpbCwgbSBhcyBhZHZhbmNlLCBqIGFzIGFwcGx5UHJvcHMsIHcgYXMgYnVpbGRHcmFwaCwgZiBhcyBjb250ZXh0LCBjIGFzIGNyZWF0ZUV2ZW50cywgZyBhcyBjcmVhdGVQb3J0YWwsIGIgYXMgY3JlYXRlUm9vdCwgayBhcyBkaXNwb3NlLCBlIGFzIGV4dGVuZCwgcSBhcyBmbHVzaEdsb2JhbEVmZmVjdHMsIHMgYXMgZ2V0Um9vdFN0YXRlLCBsIGFzIGludmFsaWRhdGUsIGggYXMgcmVjb25jaWxlciwgciBhcyByZW5kZXIsIGQgYXMgdW5tb3VudENvbXBvbmVudEF0Tm9kZSwgQyBhcyB1c2VGcmFtZSwgRCBhcyB1c2VHcmFwaCwgeSBhcyB1c2VJbnN0YW5jZUhhbmRsZSwgRiBhcyB1c2VMb2FkZXIsIHogYXMgdXNlU3RvcmUsIEEgYXMgdXNlVGhyZWUgfSBmcm9tICcuL2luZGV4LTI5YjcxMjFiLmVzbS5qcyc7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgdXNlTWVhc3VyZSBmcm9tICdyZWFjdC11c2UtbWVhc3VyZSc7XG5pbXBvcnQgeyBGaWJlclByb3ZpZGVyLCB1c2VDb250ZXh0QnJpZGdlIH0gZnJvbSAnaXRzLWZpbmUnO1xuaW1wb3J0ICdyZWFjdC1yZWNvbmNpbGVyL2NvbnN0YW50cyc7XG5pbXBvcnQgJ3p1c3RhbmQnO1xuaW1wb3J0ICdyZWFjdC1yZWNvbmNpbGVyJztcbmltcG9ydCAnc2NoZWR1bGVyJztcbmltcG9ydCAnc3VzcGVuZC1yZWFjdCc7XG5cbmNvbnN0IERPTV9FVkVOVFMgPSB7XG4gIG9uQ2xpY2s6IFsnY2xpY2snLCBmYWxzZV0sXG4gIG9uQ29udGV4dE1lbnU6IFsnY29udGV4dG1lbnUnLCBmYWxzZV0sXG4gIG9uRG91YmxlQ2xpY2s6IFsnZGJsY2xpY2snLCBmYWxzZV0sXG4gIG9uV2hlZWw6IFsnd2hlZWwnLCB0cnVlXSxcbiAgb25Qb2ludGVyRG93bjogWydwb2ludGVyZG93bicsIHRydWVdLFxuICBvblBvaW50ZXJVcDogWydwb2ludGVydXAnLCB0cnVlXSxcbiAgb25Qb2ludGVyTGVhdmU6IFsncG9pbnRlcmxlYXZlJywgdHJ1ZV0sXG4gIG9uUG9pbnRlck1vdmU6IFsncG9pbnRlcm1vdmUnLCB0cnVlXSxcbiAgb25Qb2ludGVyQ2FuY2VsOiBbJ3BvaW50ZXJjYW5jZWwnLCB0cnVlXSxcbiAgb25Mb3N0UG9pbnRlckNhcHR1cmU6IFsnbG9zdHBvaW50ZXJjYXB0dXJlJywgdHJ1ZV1cbn07XG5cbi8qKiBEZWZhdWx0IFIzRiBldmVudCBtYW5hZ2VyIGZvciB3ZWIgKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50ZXJFdmVudHMoc3RvcmUpIHtcbiAgY29uc3Qge1xuICAgIGhhbmRsZVBvaW50ZXJcbiAgfSA9IGNyZWF0ZUV2ZW50cyhzdG9yZSk7XG4gIHJldHVybiB7XG4gICAgcHJpb3JpdHk6IDEsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBjb21wdXRlKGV2ZW50LCBzdGF0ZSwgcHJldmlvdXMpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC83ODJcbiAgICAgIC8vIEV2ZW50cyB0cmlnZ2VyIG91dHNpZGUgb2YgY2FudmFzIHdoZW4gbW92ZWQsIHVzZSBvZmZzZXRYL1kgYnkgZGVmYXVsdCBhbmQgYWxsb3cgb3ZlcnJpZGVzXG4gICAgICBzdGF0ZS5wb2ludGVyLnNldChldmVudC5vZmZzZXRYIC8gc3RhdGUuc2l6ZS53aWR0aCAqIDIgLSAxLCAtKGV2ZW50Lm9mZnNldFkgLyBzdGF0ZS5zaXplLmhlaWdodCkgKiAyICsgMSk7XG4gICAgICBzdGF0ZS5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYShzdGF0ZS5wb2ludGVyLCBzdGF0ZS5jYW1lcmEpO1xuICAgIH0sXG4gICAgY29ubmVjdGVkOiB1bmRlZmluZWQsXG4gICAgaGFuZGxlcnM6IE9iamVjdC5rZXlzKERPTV9FVkVOVFMpLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7XG4gICAgICAuLi5hY2MsXG4gICAgICBba2V5XTogaGFuZGxlUG9pbnRlcihrZXkpXG4gICAgfSksIHt9KSxcbiAgICB1cGRhdGU6ICgpID0+IHtcbiAgICAgIHZhciBfaW50ZXJuYWwkbGFzdEV2ZW50O1xuICAgICAgY29uc3Qge1xuICAgICAgICBldmVudHMsXG4gICAgICAgIGludGVybmFsXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmICgoX2ludGVybmFsJGxhc3RFdmVudCA9IGludGVybmFsLmxhc3RFdmVudCkgIT0gbnVsbCAmJiBfaW50ZXJuYWwkbGFzdEV2ZW50LmN1cnJlbnQgJiYgZXZlbnRzLmhhbmRsZXJzKSBldmVudHMuaGFuZGxlcnMub25Qb2ludGVyTW92ZShpbnRlcm5hbC5sYXN0RXZlbnQuY3VycmVudCk7XG4gICAgfSxcbiAgICBjb25uZWN0OiB0YXJnZXQgPT4ge1xuICAgICAgdmFyIF9ldmVudHMkaGFuZGxlcnM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNldCxcbiAgICAgICAgZXZlbnRzXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGV2ZW50cy5kaXNjb25uZWN0ID09IG51bGwgPyB2b2lkIDAgOiBldmVudHMuZGlzY29ubmVjdCgpO1xuICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIC4uLnN0YXRlLmV2ZW50cyxcbiAgICAgICAgICBjb25uZWN0ZWQ6IHRhcmdldFxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICBPYmplY3QuZW50cmllcygoX2V2ZW50cyRoYW5kbGVycyA9IGV2ZW50cy5oYW5kbGVycykgIT0gbnVsbCA/IF9ldmVudHMkaGFuZGxlcnMgOiBbXSkuZm9yRWFjaCgoW25hbWUsIGV2ZW50XSkgPT4ge1xuICAgICAgICBjb25zdCBbZXZlbnROYW1lLCBwYXNzaXZlXSA9IERPTV9FVkVOVFNbbmFtZV07XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnQsIHtcbiAgICAgICAgICBwYXNzaXZlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkaXNjb25uZWN0OiAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNldCxcbiAgICAgICAgZXZlbnRzXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmIChldmVudHMuY29ubmVjdGVkKSB7XG4gICAgICAgIHZhciBfZXZlbnRzJGhhbmRsZXJzMjtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoKF9ldmVudHMkaGFuZGxlcnMyID0gZXZlbnRzLmhhbmRsZXJzKSAhPSBudWxsID8gX2V2ZW50cyRoYW5kbGVyczIgOiBbXSkuZm9yRWFjaCgoW25hbWUsIGV2ZW50XSkgPT4ge1xuICAgICAgICAgIGlmIChldmVudHMgJiYgZXZlbnRzLmNvbm5lY3RlZCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBbZXZlbnROYW1lXSA9IERPTV9FVkVOVFNbbmFtZV07XG4gICAgICAgICAgICBldmVudHMuY29ubmVjdGVkLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgICBjb25uZWN0ZWQ6IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgQ2FudmFzSW1wbCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIENhbnZhcyh7XG4gIGNoaWxkcmVuLFxuICBmYWxsYmFjayxcbiAgcmVzaXplLFxuICBzdHlsZSxcbiAgZ2wsXG4gIGV2ZW50cyA9IGNyZWF0ZVBvaW50ZXJFdmVudHMsXG4gIGV2ZW50U291cmNlLFxuICBldmVudFByZWZpeCxcbiAgc2hhZG93cyxcbiAgbGluZWFyLFxuICBmbGF0LFxuICBsZWdhY3ksXG4gIG9ydGhvZ3JhcGhpYyxcbiAgZnJhbWVsb29wLFxuICBkcHIsXG4gIHBlcmZvcm1hbmNlLFxuICByYXljYXN0ZXIsXG4gIGNhbWVyYSxcbiAgc2NlbmUsXG4gIG9uUG9pbnRlck1pc3NlZCxcbiAgb25DcmVhdGVkLFxuICAuLi5wcm9wc1xufSwgZm9yd2FyZGVkUmVmKSB7XG4gIC8vIENyZWF0ZSBhIGtub3duIGNhdGFsb2d1ZSBvZiBUaHJlZWpzLW5hdGl2ZSBlbGVtZW50c1xuICAvLyBUaGlzIHdpbGwgaW5jbHVkZSB0aGUgZW50aXJlIFRIUkVFIG5hbWVzcGFjZSBieSBkZWZhdWx0LCB1c2VycyBjYW4gZXh0ZW5kXG4gIC8vIHRoZWlyIG93biBlbGVtZW50cyBieSB1c2luZyB0aGUgY3JlYXRlUm9vdCBBUEkgaW5zdGVhZFxuICBSZWFjdC51c2VNZW1vKCgpID0+IGV4dGVuZChUSFJFRSksIFtdKTtcbiAgY29uc3QgQnJpZGdlID0gdXNlQ29udGV4dEJyaWRnZSgpO1xuICBjb25zdCBbY29udGFpbmVyUmVmLCBjb250YWluZXJSZWN0XSA9IHVzZU1lYXN1cmUoe1xuICAgIHNjcm9sbDogdHJ1ZSxcbiAgICBkZWJvdW5jZToge1xuICAgICAgc2Nyb2xsOiA1MCxcbiAgICAgIHJlc2l6ZTogMFxuICAgIH0sXG4gICAgLi4ucmVzaXplXG4gIH0pO1xuICBjb25zdCBjYW52YXNSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGRpdlJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShmb3J3YXJkZWRSZWYsICgpID0+IGNhbnZhc1JlZi5jdXJyZW50KTtcbiAgY29uc3QgaGFuZGxlUG9pbnRlck1pc3NlZCA9IHVzZU11dGFibGVDYWxsYmFjayhvblBvaW50ZXJNaXNzZWQpO1xuICBjb25zdCBbYmxvY2ssIHNldEJsb2NrXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gU3VzcGVuZCB0aGlzIGNvbXBvbmVudCBpZiBibG9jayBpcyBhIHByb21pc2UgKDJuZCBydW4pXG4gIGlmIChibG9jaykgdGhyb3cgYmxvY2s7XG4gIC8vIFRocm93IGV4Y2VwdGlvbiBvdXR3YXJkcyBpZiBhbnl0aGluZyB3aXRoaW4gY2FudmFzIHRocm93c1xuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICBjb25zdCByb290ID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoY29udGFpbmVyUmVjdC53aWR0aCA+IDAgJiYgY29udGFpbmVyUmVjdC5oZWlnaHQgPiAwICYmIGNhbnZhcykge1xuICAgICAgaWYgKCFyb290LmN1cnJlbnQpIHJvb3QuY3VycmVudCA9IGNyZWF0ZVJvb3QoY2FudmFzKTtcbiAgICAgIHJvb3QuY3VycmVudC5jb25maWd1cmUoe1xuICAgICAgICBnbCxcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBzaGFkb3dzLFxuICAgICAgICBsaW5lYXIsXG4gICAgICAgIGZsYXQsXG4gICAgICAgIGxlZ2FjeSxcbiAgICAgICAgb3J0aG9ncmFwaGljLFxuICAgICAgICBmcmFtZWxvb3AsXG4gICAgICAgIGRwcixcbiAgICAgICAgcGVyZm9ybWFuY2UsXG4gICAgICAgIHJheWNhc3RlcixcbiAgICAgICAgY2FtZXJhLFxuICAgICAgICBzY2VuZSxcbiAgICAgICAgc2l6ZTogY29udGFpbmVyUmVjdCxcbiAgICAgICAgLy8gUGFzcyBtdXRhYmxlIHJlZmVyZW5jZSB0byBvblBvaW50ZXJNaXNzZWQgc28gaXQncyBmcmVlIHRvIHVwZGF0ZVxuICAgICAgICBvblBvaW50ZXJNaXNzZWQ6ICguLi5hcmdzKSA9PiBoYW5kbGVQb2ludGVyTWlzc2VkLmN1cnJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVBvaW50ZXJNaXNzZWQuY3VycmVudCguLi5hcmdzKSxcbiAgICAgICAgb25DcmVhdGVkOiBzdGF0ZSA9PiB7XG4gICAgICAgICAgLy8gQ29ubmVjdCB0byBldmVudCBzb3VyY2VcbiAgICAgICAgICBzdGF0ZS5ldmVudHMuY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbm5lY3QoZXZlbnRTb3VyY2UgPyBpc1JlZihldmVudFNvdXJjZSkgPyBldmVudFNvdXJjZS5jdXJyZW50IDogZXZlbnRTb3VyY2UgOiBkaXZSZWYuY3VycmVudCk7XG4gICAgICAgICAgLy8gU2V0IHVwIGNvbXB1dGUgZnVuY3Rpb25cbiAgICAgICAgICBpZiAoZXZlbnRQcmVmaXgpIHtcbiAgICAgICAgICAgIHN0YXRlLnNldEV2ZW50cyh7XG4gICAgICAgICAgICAgIGNvbXB1dGU6IChldmVudCwgc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gZXZlbnRbZXZlbnRQcmVmaXggKyAnWCddO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBldmVudFtldmVudFByZWZpeCArICdZJ107XG4gICAgICAgICAgICAgICAgc3RhdGUucG9pbnRlci5zZXQoeCAvIHN0YXRlLnNpemUud2lkdGggKiAyIC0gMSwgLSh5IC8gc3RhdGUuc2l6ZS5oZWlnaHQpICogMiArIDEpO1xuICAgICAgICAgICAgICAgIHN0YXRlLnJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKHN0YXRlLnBvaW50ZXIsIHN0YXRlLmNhbWVyYSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDYWxsIG9uQ3JlYXRlZCBjYWxsYmFja1xuICAgICAgICAgIG9uQ3JlYXRlZCA9PSBudWxsID8gdm9pZCAwIDogb25DcmVhdGVkKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByb290LmN1cnJlbnQucmVuZGVyKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChCcmlkZ2UsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnksIHtcbiAgICAgICAgc2V0OiBzZXRFcnJvclxuICAgICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuU3VzcGVuc2UsIHtcbiAgICAgICAgZmFsbGJhY2s6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEJsb2NrLCB7XG4gICAgICAgICAgc2V0OiBzZXRCbG9ja1xuICAgICAgICB9KVxuICAgICAgfSwgY2hpbGRyZW4pKSkpO1xuICAgIH1cbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGNhbnZhcykgcmV0dXJuICgpID0+IHVubW91bnRDb21wb25lbnRBdE5vZGUoY2FudmFzKTtcbiAgfSwgW10pO1xuXG4gIC8vIFdoZW4gdGhlIGV2ZW50IHNvdXJjZSBpcyBub3QgdGhpcyBkaXYsIHdlIG5lZWQgdG8gc2V0IHBvaW50ZXItZXZlbnRzIHRvIG5vbmVcbiAgLy8gT3IgZWxzZSB0aGUgY2FudmFzIHdpbGwgYmxvY2sgZXZlbnRzIGZyb20gcmVhY2hpbmcgdGhlIGV2ZW50IHNvdXJjZVxuICBjb25zdCBwb2ludGVyRXZlbnRzID0gZXZlbnRTb3VyY2UgPyAnbm9uZScgOiAnYXV0byc7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBkaXZSZWYsXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcG9pbnRlckV2ZW50cyxcbiAgICAgIC4uLnN0eWxlXG4gICAgfVxuICB9LCBwcm9wcyksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICByZWY6IGNvbnRhaW5lclJlZixcbiAgICBzdHlsZToge1xuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnXG4gICAgfVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiLCB7XG4gICAgcmVmOiBjYW52YXNSZWYsXG4gICAgc3R5bGU6IHtcbiAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICB9XG4gIH0sIGZhbGxiYWNrKSkpO1xufSk7XG5cbi8qKlxuICogQSBET00gY2FudmFzIHdoaWNoIGFjY2VwdHMgdGhyZWVqcyBlbGVtZW50cyBhcyBjaGlsZHJlbi5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2NhbnZhc1xuICovXG5jb25zdCBDYW52YXMgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBDYW52YXNXcmFwcGVyKHByb3BzLCByZWYpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZpYmVyUHJvdmlkZXIsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENhbnZhc0ltcGwsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIHJlZjogcmVmXG4gIH0pKSk7XG59KTtcblxuZXhwb3J0IHsgQ2FudmFzLCBjcmVhdGVQb2ludGVyRXZlbnRzIGFzIGV2ZW50cyB9O1xuIl0sIm5hbWVzIjpbImMiLCJjcmVhdGVFdmVudHMiLCJlIiwiZXh0ZW5kIiwidSIsInVzZU11dGFibGVDYWxsYmFjayIsImEiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiYiIsImNyZWF0ZVJvb3QiLCJpIiwiaXNSZWYiLCJFIiwiRXJyb3JCb3VuZGFyeSIsIkIiLCJCbG9jayIsImQiLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwidCIsIlJlYWN0VGhyZWVGaWJlciIsIngiLCJfcm9vdHMiLCJ2IiwiYWN0IiwibyIsImFkZEFmdGVyRWZmZWN0IiwibiIsImFkZEVmZmVjdCIsInAiLCJhZGRUYWlsIiwibSIsImFkdmFuY2UiLCJqIiwiYXBwbHlQcm9wcyIsInciLCJidWlsZEdyYXBoIiwiZiIsImNvbnRleHQiLCJnIiwiY3JlYXRlUG9ydGFsIiwiayIsImRpc3Bvc2UiLCJxIiwiZmx1c2hHbG9iYWxFZmZlY3RzIiwicyIsImdldFJvb3RTdGF0ZSIsImwiLCJpbnZhbGlkYXRlIiwiaCIsInJlY29uY2lsZXIiLCJyIiwicmVuZGVyIiwiQyIsInVzZUZyYW1lIiwiRCIsInVzZUdyYXBoIiwieSIsInVzZUluc3RhbmNlSGFuZGxlIiwiRiIsInVzZUxvYWRlciIsInoiLCJ1c2VTdG9yZSIsIkEiLCJ1c2VUaHJlZSIsIl9leHRlbmRzIiwiUmVhY3QiLCJUSFJFRSIsInVzZU1lYXN1cmUiLCJGaWJlclByb3ZpZGVyIiwidXNlQ29udGV4dEJyaWRnZSIsIkRPTV9FVkVOVFMiLCJvbkNsaWNrIiwib25Db250ZXh0TWVudSIsIm9uRG91YmxlQ2xpY2siLCJvbldoZWVsIiwib25Qb2ludGVyRG93biIsIm9uUG9pbnRlclVwIiwib25Qb2ludGVyTGVhdmUiLCJvblBvaW50ZXJNb3ZlIiwib25Qb2ludGVyQ2FuY2VsIiwib25Mb3N0UG9pbnRlckNhcHR1cmUiLCJjcmVhdGVQb2ludGVyRXZlbnRzIiwic3RvcmUiLCJoYW5kbGVQb2ludGVyIiwicHJpb3JpdHkiLCJlbmFibGVkIiwiY29tcHV0ZSIsImV2ZW50Iiwic3RhdGUiLCJwcmV2aW91cyIsInBvaW50ZXIiLCJzZXQiLCJvZmZzZXRYIiwic2l6ZSIsIndpZHRoIiwib2Zmc2V0WSIsImhlaWdodCIsInJheWNhc3RlciIsInNldEZyb21DYW1lcmEiLCJjYW1lcmEiLCJjb25uZWN0ZWQiLCJ1bmRlZmluZWQiLCJoYW5kbGVycyIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJhY2MiLCJrZXkiLCJ1cGRhdGUiLCJfaW50ZXJuYWwkbGFzdEV2ZW50IiwiZXZlbnRzIiwiaW50ZXJuYWwiLCJnZXRTdGF0ZSIsImxhc3RFdmVudCIsImN1cnJlbnQiLCJjb25uZWN0IiwidGFyZ2V0IiwiX2V2ZW50cyRoYW5kbGVycyIsImRpc2Nvbm5lY3QiLCJlbnRyaWVzIiwiZm9yRWFjaCIsIm5hbWUiLCJldmVudE5hbWUiLCJwYXNzaXZlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9ldmVudHMkaGFuZGxlcnMyIiwiSFRNTEVsZW1lbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiQ2FudmFzSW1wbCIsImZvcndhcmRSZWYiLCJDYW52YXMiLCJjaGlsZHJlbiIsImZhbGxiYWNrIiwicmVzaXplIiwic3R5bGUiLCJnbCIsImV2ZW50U291cmNlIiwiZXZlbnRQcmVmaXgiLCJzaGFkb3dzIiwibGluZWFyIiwiZmxhdCIsImxlZ2FjeSIsIm9ydGhvZ3JhcGhpYyIsImZyYW1lbG9vcCIsImRwciIsInBlcmZvcm1hbmNlIiwic2NlbmUiLCJvblBvaW50ZXJNaXNzZWQiLCJvbkNyZWF0ZWQiLCJwcm9wcyIsImZvcndhcmRlZFJlZiIsInVzZU1lbW8iLCJCcmlkZ2UiLCJjb250YWluZXJSZWYiLCJjb250YWluZXJSZWN0Iiwic2Nyb2xsIiwiZGVib3VuY2UiLCJjYW52YXNSZWYiLCJ1c2VSZWYiLCJkaXZSZWYiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwiaGFuZGxlUG9pbnRlck1pc3NlZCIsImJsb2NrIiwic2V0QmxvY2siLCJ1c2VTdGF0ZSIsImVycm9yIiwic2V0RXJyb3IiLCJyb290IiwiY2FudmFzIiwiY29uZmlndXJlIiwiYXJncyIsInNldEV2ZW50cyIsImNyZWF0ZUVsZW1lbnQiLCJTdXNwZW5zZSIsInVzZUVmZmVjdCIsInBvaW50ZXJFdmVudHMiLCJyZWYiLCJwb3NpdGlvbiIsIm92ZXJmbG93IiwiZGlzcGxheSIsIkNhbnZhc1dyYXBwZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var enableSchedulerDebugging = false;\n        var enableProfiling = false;\n        var frameYieldMs = 5;\n        function push(heap, node) {\n            var index = heap.length;\n            heap.push(node);\n            siftUp(heap, node, index);\n        }\n        function peek(heap) {\n            return heap.length === 0 ? null : heap[0];\n        }\n        function pop(heap) {\n            if (heap.length === 0) {\n                return null;\n            }\n            var first = heap[0];\n            var last = heap.pop();\n            if (last !== first) {\n                heap[0] = last;\n                siftDown(heap, last, 0);\n            }\n            return first;\n        }\n        function siftUp(heap, node, i) {\n            var index = i;\n            while(index > 0){\n                var parentIndex = index - 1 >>> 1;\n                var parent = heap[parentIndex];\n                if (compare(parent, node) > 0) {\n                    // The parent is larger. Swap positions.\n                    heap[parentIndex] = node;\n                    heap[index] = parent;\n                    index = parentIndex;\n                } else {\n                    // The parent is smaller. Exit.\n                    return;\n                }\n            }\n        }\n        function siftDown(heap, node, i) {\n            var index = i;\n            var length = heap.length;\n            var halfLength = length >>> 1;\n            while(index < halfLength){\n                var leftIndex = (index + 1) * 2 - 1;\n                var left = heap[leftIndex];\n                var rightIndex = leftIndex + 1;\n                var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\n                if (compare(left, node) < 0) {\n                    if (rightIndex < length && compare(right, left) < 0) {\n                        heap[index] = right;\n                        heap[rightIndex] = node;\n                        index = rightIndex;\n                    } else {\n                        heap[index] = left;\n                        heap[leftIndex] = node;\n                        index = leftIndex;\n                    }\n                } else if (rightIndex < length && compare(right, node) < 0) {\n                    heap[index] = right;\n                    heap[rightIndex] = node;\n                    index = rightIndex;\n                } else {\n                    // Neither child is smaller. Exit.\n                    return;\n                }\n            }\n        }\n        function compare(a, b) {\n            // Compare sort index first, then task id.\n            var diff = a.sortIndex - b.sortIndex;\n            return diff !== 0 ? diff : a.id - b.id;\n        }\n        // TODO: Use symbols?\n        var ImmediatePriority = 1;\n        var UserBlockingPriority = 2;\n        var NormalPriority = 3;\n        var LowPriority = 4;\n        var IdlePriority = 5;\n        function markTaskErrored(task, ms) {}\n        /* eslint-disable no-var */ var hasPerformanceNow = typeof performance === \"object\" && typeof performance.now === \"function\";\n        if (hasPerformanceNow) {\n            var localPerformance = performance;\n            exports.unstable_now = function() {\n                return localPerformance.now();\n            };\n        } else {\n            var localDate = Date;\n            var initialTime = localDate.now();\n            exports.unstable_now = function() {\n                return localDate.now() - initialTime;\n            };\n        } // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n        // Math.pow(2, 30) - 1\n        // 0b111111111111111111111111111111\n        var maxSigned31BitInt = 1073741823; // Times out immediately\n        var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;\n        var NORMAL_PRIORITY_TIMEOUT = 5000;\n        var LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap\n        var taskQueue = [];\n        var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n        var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\n        var currentTask = null;\n        var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.\n        var isPerformingWork = false;\n        var isHostCallbackScheduled = false;\n        var isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.\n        var localSetTimeout = typeof setTimeout === \"function\" ? setTimeout : null;\n        var localClearTimeout = typeof clearTimeout === \"function\" ? clearTimeout : null;\n        var localSetImmediate = typeof setImmediate !== \"undefined\" ? setImmediate : null; // IE and Node.js + jsdom\n        var isInputPending = typeof navigator !== \"undefined\" && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;\n        function advanceTimers(currentTime) {\n            // Check for tasks that are no longer delayed and add them to the queue.\n            var timer = peek(timerQueue);\n            while(timer !== null){\n                if (timer.callback === null) {\n                    // Timer was cancelled.\n                    pop(timerQueue);\n                } else if (timer.startTime <= currentTime) {\n                    // Timer fired. Transfer to the task queue.\n                    pop(timerQueue);\n                    timer.sortIndex = timer.expirationTime;\n                    push(taskQueue, timer);\n                } else {\n                    // Remaining timers are pending.\n                    return;\n                }\n                timer = peek(timerQueue);\n            }\n        }\n        function handleTimeout(currentTime) {\n            isHostTimeoutScheduled = false;\n            advanceTimers(currentTime);\n            if (!isHostCallbackScheduled) {\n                if (peek(taskQueue) !== null) {\n                    isHostCallbackScheduled = true;\n                    requestHostCallback(flushWork);\n                } else {\n                    var firstTimer = peek(timerQueue);\n                    if (firstTimer !== null) {\n                        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n                    }\n                }\n            }\n        }\n        function flushWork(hasTimeRemaining, initialTime) {\n            isHostCallbackScheduled = false;\n            if (isHostTimeoutScheduled) {\n                // We scheduled a timeout but it's no longer needed. Cancel it.\n                isHostTimeoutScheduled = false;\n                cancelHostTimeout();\n            }\n            isPerformingWork = true;\n            var previousPriorityLevel = currentPriorityLevel;\n            try {\n                if (enableProfiling) {\n                    try {\n                        return workLoop(hasTimeRemaining, initialTime);\n                    } catch (error) {\n                        if (currentTask !== null) {\n                            var currentTime = exports.unstable_now();\n                            markTaskErrored(currentTask, currentTime);\n                            currentTask.isQueued = false;\n                        }\n                        throw error;\n                    }\n                } else {\n                    // No catch in prod code path.\n                    return workLoop(hasTimeRemaining, initialTime);\n                }\n            } finally{\n                currentTask = null;\n                currentPriorityLevel = previousPriorityLevel;\n                isPerformingWork = false;\n            }\n        }\n        function workLoop(hasTimeRemaining, initialTime) {\n            var currentTime = initialTime;\n            advanceTimers(currentTime);\n            currentTask = peek(taskQueue);\n            while(currentTask !== null && !enableSchedulerDebugging){\n                if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n                    break;\n                }\n                var callback = currentTask.callback;\n                if (typeof callback === \"function\") {\n                    currentTask.callback = null;\n                    currentPriorityLevel = currentTask.priorityLevel;\n                    var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n                    var continuationCallback = callback(didUserCallbackTimeout);\n                    currentTime = exports.unstable_now();\n                    if (typeof continuationCallback === \"function\") {\n                        currentTask.callback = continuationCallback;\n                    } else {\n                        if (currentTask === peek(taskQueue)) {\n                            pop(taskQueue);\n                        }\n                    }\n                    advanceTimers(currentTime);\n                } else {\n                    pop(taskQueue);\n                }\n                currentTask = peek(taskQueue);\n            } // Return whether there's additional work\n            if (currentTask !== null) {\n                return true;\n            } else {\n                var firstTimer = peek(timerQueue);\n                if (firstTimer !== null) {\n                    requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n                }\n                return false;\n            }\n        }\n        function unstable_runWithPriority(priorityLevel, eventHandler) {\n            switch(priorityLevel){\n                case ImmediatePriority:\n                case UserBlockingPriority:\n                case NormalPriority:\n                case LowPriority:\n                case IdlePriority:\n                    break;\n                default:\n                    priorityLevel = NormalPriority;\n            }\n            var previousPriorityLevel = currentPriorityLevel;\n            currentPriorityLevel = priorityLevel;\n            try {\n                return eventHandler();\n            } finally{\n                currentPriorityLevel = previousPriorityLevel;\n            }\n        }\n        function unstable_next(eventHandler) {\n            var priorityLevel;\n            switch(currentPriorityLevel){\n                case ImmediatePriority:\n                case UserBlockingPriority:\n                case NormalPriority:\n                    // Shift down to normal priority\n                    priorityLevel = NormalPriority;\n                    break;\n                default:\n                    // Anything lower than normal priority should remain at the current level.\n                    priorityLevel = currentPriorityLevel;\n                    break;\n            }\n            var previousPriorityLevel = currentPriorityLevel;\n            currentPriorityLevel = priorityLevel;\n            try {\n                return eventHandler();\n            } finally{\n                currentPriorityLevel = previousPriorityLevel;\n            }\n        }\n        function unstable_wrapCallback(callback) {\n            var parentPriorityLevel = currentPriorityLevel;\n            return function() {\n                // This is a fork of runWithPriority, inlined for performance.\n                var previousPriorityLevel = currentPriorityLevel;\n                currentPriorityLevel = parentPriorityLevel;\n                try {\n                    return callback.apply(this, arguments);\n                } finally{\n                    currentPriorityLevel = previousPriorityLevel;\n                }\n            };\n        }\n        function unstable_scheduleCallback(priorityLevel, callback, options) {\n            var currentTime = exports.unstable_now();\n            var startTime;\n            if (typeof options === \"object\" && options !== null) {\n                var delay = options.delay;\n                if (typeof delay === \"number\" && delay > 0) {\n                    startTime = currentTime + delay;\n                } else {\n                    startTime = currentTime;\n                }\n            } else {\n                startTime = currentTime;\n            }\n            var timeout;\n            switch(priorityLevel){\n                case ImmediatePriority:\n                    timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n                    break;\n                case UserBlockingPriority:\n                    timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n                    break;\n                case IdlePriority:\n                    timeout = IDLE_PRIORITY_TIMEOUT;\n                    break;\n                case LowPriority:\n                    timeout = LOW_PRIORITY_TIMEOUT;\n                    break;\n                case NormalPriority:\n                default:\n                    timeout = NORMAL_PRIORITY_TIMEOUT;\n                    break;\n            }\n            var expirationTime = startTime + timeout;\n            var newTask = {\n                id: taskIdCounter++,\n                callback: callback,\n                priorityLevel: priorityLevel,\n                startTime: startTime,\n                expirationTime: expirationTime,\n                sortIndex: -1\n            };\n            if (startTime > currentTime) {\n                // This is a delayed task.\n                newTask.sortIndex = startTime;\n                push(timerQueue, newTask);\n                if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n                    // All tasks are delayed, and this is the task with the earliest delay.\n                    if (isHostTimeoutScheduled) {\n                        // Cancel an existing timeout.\n                        cancelHostTimeout();\n                    } else {\n                        isHostTimeoutScheduled = true;\n                    } // Schedule a timeout.\n                    requestHostTimeout(handleTimeout, startTime - currentTime);\n                }\n            } else {\n                newTask.sortIndex = expirationTime;\n                push(taskQueue, newTask);\n                // wait until the next time we yield.\n                if (!isHostCallbackScheduled && !isPerformingWork) {\n                    isHostCallbackScheduled = true;\n                    requestHostCallback(flushWork);\n                }\n            }\n            return newTask;\n        }\n        function unstable_pauseExecution() {}\n        function unstable_continueExecution() {\n            if (!isHostCallbackScheduled && !isPerformingWork) {\n                isHostCallbackScheduled = true;\n                requestHostCallback(flushWork);\n            }\n        }\n        function unstable_getFirstCallbackNode() {\n            return peek(taskQueue);\n        }\n        function unstable_cancelCallback(task) {\n            // remove from the queue because you can't remove arbitrary nodes from an\n            // array based heap, only the first one.)\n            task.callback = null;\n        }\n        function unstable_getCurrentPriorityLevel() {\n            return currentPriorityLevel;\n        }\n        var isMessageLoopRunning = false;\n        var scheduledHostCallback = null;\n        var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main\n        // thread, like user events. By default, it yields multiple times per frame.\n        // It does not attempt to align with frame boundaries, since most tasks don't\n        // need to be frame aligned; for those that do, use requestAnimationFrame.\n        var frameInterval = frameYieldMs;\n        var startTime = -1;\n        function shouldYieldToHost() {\n            var timeElapsed = exports.unstable_now() - startTime;\n            if (timeElapsed < frameInterval) {\n                // The main thread has only been blocked for a really short amount of time;\n                // smaller than a single frame. Don't yield yet.\n                return false;\n            } // The main thread has been blocked for a non-negligible amount of time. We\n            return true;\n        }\n        function requestPaint() {}\n        function forceFrameRate(fps) {\n            if (fps < 0 || fps > 125) {\n                // Using console['error'] to evade Babel and ESLint\n                console[\"error\"](\"forceFrameRate takes a positive int between 0 and 125, \" + \"forcing frame rates higher than 125 fps is not supported\");\n                return;\n            }\n            if (fps > 0) {\n                frameInterval = Math.floor(1000 / fps);\n            } else {\n                // reset the framerate\n                frameInterval = frameYieldMs;\n            }\n        }\n        var performWorkUntilDeadline = function() {\n            if (scheduledHostCallback !== null) {\n                var currentTime = exports.unstable_now(); // Keep track of the start time so we can measure how long the main thread\n                // has been blocked.\n                startTime = currentTime;\n                var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the\n                // error can be observed.\n                //\n                // Intentionally not using a try-catch, since that makes some debugging\n                // techniques harder. Instead, if `scheduledHostCallback` errors, then\n                // `hasMoreWork` will remain true, and we'll continue the work loop.\n                var hasMoreWork = true;\n                try {\n                    hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n                } finally{\n                    if (hasMoreWork) {\n                        // If there's more work, schedule the next message event at the end\n                        // of the preceding one.\n                        schedulePerformWorkUntilDeadline();\n                    } else {\n                        isMessageLoopRunning = false;\n                        scheduledHostCallback = null;\n                    }\n                }\n            } else {\n                isMessageLoopRunning = false;\n            } // Yielding to the browser will give it a chance to paint, so we can\n        };\n        var schedulePerformWorkUntilDeadline;\n        if (typeof localSetImmediate === \"function\") {\n            // Node.js and old IE.\n            // There's a few reasons for why we prefer setImmediate.\n            //\n            // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n            // (Even though this is a DOM fork of the Scheduler, you could get here\n            // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n            // https://github.com/facebook/react/issues/20756\n            //\n            // But also, it runs earlier which is the semantic we want.\n            // If other browsers ever implement it, it's better to use it.\n            // Although both of these would be inferior to native scheduling.\n            schedulePerformWorkUntilDeadline = function() {\n                localSetImmediate(performWorkUntilDeadline);\n            };\n        } else if (typeof MessageChannel !== \"undefined\") {\n            // DOM and Worker environments.\n            // We prefer MessageChannel because of the 4ms setTimeout clamping.\n            var channel = new MessageChannel();\n            var port = channel.port2;\n            channel.port1.onmessage = performWorkUntilDeadline;\n            schedulePerformWorkUntilDeadline = function() {\n                port.postMessage(null);\n            };\n        } else {\n            // We should only fallback here in non-browser environments.\n            schedulePerformWorkUntilDeadline = function() {\n                localSetTimeout(performWorkUntilDeadline, 0);\n            };\n        }\n        function requestHostCallback(callback) {\n            scheduledHostCallback = callback;\n            if (!isMessageLoopRunning) {\n                isMessageLoopRunning = true;\n                schedulePerformWorkUntilDeadline();\n            }\n        }\n        function requestHostTimeout(callback, ms) {\n            taskTimeoutID = localSetTimeout(function() {\n                callback(exports.unstable_now());\n            }, ms);\n        }\n        function cancelHostTimeout() {\n            localClearTimeout(taskTimeoutID);\n            taskTimeoutID = -1;\n        }\n        var unstable_requestPaint = requestPaint;\n        var unstable_Profiling = null;\n        exports.unstable_IdlePriority = IdlePriority;\n        exports.unstable_ImmediatePriority = ImmediatePriority;\n        exports.unstable_LowPriority = LowPriority;\n        exports.unstable_NormalPriority = NormalPriority;\n        exports.unstable_Profiling = unstable_Profiling;\n        exports.unstable_UserBlockingPriority = UserBlockingPriority;\n        exports.unstable_cancelCallback = unstable_cancelCallback;\n        exports.unstable_continueExecution = unstable_continueExecution;\n        exports.unstable_forceFrameRate = forceFrameRate;\n        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n        exports.unstable_next = unstable_next;\n        exports.unstable_pauseExecution = unstable_pauseExecution;\n        exports.unstable_requestPaint = unstable_requestPaint;\n        exports.unstable_runWithPriority = unstable_runWithPriority;\n        exports.unstable_scheduleCallback = unstable_scheduleCallback;\n        exports.unstable_shouldYield = shouldYieldToHost;\n        exports.unstable_wrapCallback = unstable_wrapCallback;\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUVPO1FBRVYseUNBQXlDLEdBQ3pDLElBQ0UsT0FBT0MsbUNBQW1DLGVBQzFDLE9BQU9BLCtCQUErQkMsMkJBQTJCLEtBQy9ELFlBQ0Y7WUFDQUQsK0JBQStCQywyQkFBMkIsQ0FBQyxJQUFJQztRQUNqRTtRQUNVLElBQUlDLDJCQUEyQjtRQUN6QyxJQUFJQyxrQkFBa0I7UUFDdEIsSUFBSUMsZUFBZTtRQUVuQixTQUFTQyxLQUFLQyxJQUFJLEVBQUVDLElBQUk7WUFDdEIsSUFBSUMsUUFBUUYsS0FBS0csTUFBTTtZQUN2QkgsS0FBS0QsSUFBSSxDQUFDRTtZQUNWRyxPQUFPSixNQUFNQyxNQUFNQztRQUNyQjtRQUNBLFNBQVNHLEtBQUtMLElBQUk7WUFDaEIsT0FBT0EsS0FBS0csTUFBTSxLQUFLLElBQUksT0FBT0gsSUFBSSxDQUFDLEVBQUU7UUFDM0M7UUFDQSxTQUFTTSxJQUFJTixJQUFJO1lBQ2YsSUFBSUEsS0FBS0csTUFBTSxLQUFLLEdBQUc7Z0JBQ3JCLE9BQU87WUFDVDtZQUVBLElBQUlJLFFBQVFQLElBQUksQ0FBQyxFQUFFO1lBQ25CLElBQUlRLE9BQU9SLEtBQUtNLEdBQUc7WUFFbkIsSUFBSUUsU0FBU0QsT0FBTztnQkFDbEJQLElBQUksQ0FBQyxFQUFFLEdBQUdRO2dCQUNWQyxTQUFTVCxNQUFNUSxNQUFNO1lBQ3ZCO1lBRUEsT0FBT0Q7UUFDVDtRQUVBLFNBQVNILE9BQU9KLElBQUksRUFBRUMsSUFBSSxFQUFFUyxDQUFDO1lBQzNCLElBQUlSLFFBQVFRO1lBRVosTUFBT1IsUUFBUSxFQUFHO2dCQUNoQixJQUFJUyxjQUFjVCxRQUFRLE1BQU07Z0JBQ2hDLElBQUlV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LHdDQUF3QyxHQUFHbUU7UUFDM0NuRSxxQ0FBcUMsR0FBR2lFO1FBQ3hDakUscUJBQXFCLEdBQUdxRDtRQUN4QnJELCtCQUErQixHQUFHK0Q7UUFDbEMvRCw2QkFBNkIsR0FBR3lGO1FBQ2hDekYsZ0NBQWdDLEdBQUdtRDtRQUNuQ25ELGlDQUFpQyxHQUFHMEQ7UUFDcEMxRCw0QkFBNEIsR0FBRytDO1FBQy9CL0MsNkJBQTZCLEdBQUdzRDtRQUN0Qix5Q0FBeUMsR0FDbkQsSUFDRSxPQUFPakcsbUNBQW1DLGVBQzFDLE9BQU9BLCtCQUErQjZJLDBCQUEwQixLQUM5RCxZQUNGO1lBQ0E3SSwrQkFBK0I2SSwwQkFBMEIsQ0FBQyxJQUFJM0k7UUFDaEU7SUFFRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2hhaXNhYm0vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcz9iMTE2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHNjaGVkdWxlci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xufVxuICAgICAgICAgIHZhciBlbmFibGVTY2hlZHVsZXJEZWJ1Z2dpbmcgPSBmYWxzZTtcbnZhciBlbmFibGVQcm9maWxpbmcgPSBmYWxzZTtcbnZhciBmcmFtZVlpZWxkTXMgPSA1O1xuXG5mdW5jdGlvbiBwdXNoKGhlYXAsIG5vZGUpIHtcbiAgdmFyIGluZGV4ID0gaGVhcC5sZW5ndGg7XG4gIGhlYXAucHVzaChub2RlKTtcbiAgc2lmdFVwKGhlYXAsIG5vZGUsIGluZGV4KTtcbn1cbmZ1bmN0aW9uIHBlZWsoaGVhcCkge1xuICByZXR1cm4gaGVhcC5sZW5ndGggPT09IDAgPyBudWxsIDogaGVhcFswXTtcbn1cbmZ1bmN0aW9uIHBvcChoZWFwKSB7XG4gIGlmIChoZWFwLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGZpcnN0ID0gaGVhcFswXTtcbiAgdmFyIGxhc3QgPSBoZWFwLnBvcCgpO1xuXG4gIGlmIChsYXN0ICE9PSBmaXJzdCkge1xuICAgIGhlYXBbMF0gPSBsYXN0O1xuICAgIHNpZnREb3duKGhlYXAsIGxhc3QsIDApO1xuICB9XG5cbiAgcmV0dXJuIGZpcnN0O1xufVxuXG5mdW5jdGlvbiBzaWZ0VXAoaGVhcCwgbm9kZSwgaSkge1xuICB2YXIgaW5kZXggPSBpO1xuXG4gIHdoaWxlIChpbmRleCA+IDApIHtcbiAgICB2YXIgcGFyZW50SW5kZXggPSBpbmRleCAtIDEgPj4+IDE7XG4gICAgdmFyIHBhcmVudCA9IGhlYXBbcGFyZW50SW5kZXhdO1xuXG4gICAgaWYgKGNvbXBhcmUocGFyZW50LCBub2RlKSA+IDApIHtcbiAgICAgIC8vIFRoZSBwYXJlbnQgaXMgbGFyZ2VyLiBTd2FwIHBvc2l0aW9ucy5cbiAgICAgIGhlYXBbcGFyZW50SW5kZXhdID0gbm9kZTtcbiAgICAgIGhlYXBbaW5kZXhdID0gcGFyZW50O1xuICAgICAgaW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHBhcmVudCBpcyBzbWFsbGVyLiBFeGl0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzaWZ0RG93bihoZWFwLCBub2RlLCBpKSB7XG4gIHZhciBpbmRleCA9IGk7XG4gIHZhciBsZW5ndGggPSBoZWFwLmxlbmd0aDtcbiAgdmFyIGhhbGZMZW5ndGggPSBsZW5ndGggPj4+IDE7XG5cbiAgd2hpbGUgKGluZGV4IDwgaGFsZkxlbmd0aCkge1xuICAgIHZhciBsZWZ0SW5kZXggPSAoaW5kZXggKyAxKSAqIDIgLSAxO1xuICAgIHZhciBsZWZ0ID0gaGVhcFtsZWZ0SW5kZXhdO1xuICAgIHZhciByaWdodEluZGV4ID0gbGVmdEluZGV4ICsgMTtcbiAgICB2YXIgcmlnaHQgPSBoZWFwW3JpZ2h0SW5kZXhdOyAvLyBJZiB0aGUgbGVmdCBvciByaWdodCBub2RlIGlzIHNtYWxsZXIsIHN3YXAgd2l0aCB0aGUgc21hbGxlciBvZiB0aG9zZS5cblxuICAgIGlmIChjb21wYXJlKGxlZnQsIG5vZGUpIDwgMCkge1xuICAgICAgaWYgKHJpZ2h0SW5kZXggPCBsZW5ndGggJiYgY29tcGFyZShyaWdodCwgbGVmdCkgPCAwKSB7XG4gICAgICAgIGhlYXBbaW5kZXhdID0gcmlnaHQ7XG4gICAgICAgIGhlYXBbcmlnaHRJbmRleF0gPSBub2RlO1xuICAgICAgICBpbmRleCA9IHJpZ2h0SW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWFwW2luZGV4XSA9IGxlZnQ7XG4gICAgICAgIGhlYXBbbGVmdEluZGV4XSA9IG5vZGU7XG4gICAgICAgIGluZGV4ID0gbGVmdEluZGV4O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmlnaHRJbmRleCA8IGxlbmd0aCAmJiBjb21wYXJlKHJpZ2h0LCBub2RlKSA8IDApIHtcbiAgICAgIGhlYXBbaW5kZXhdID0gcmlnaHQ7XG4gICAgICBoZWFwW3JpZ2h0SW5kZXhdID0gbm9kZTtcbiAgICAgIGluZGV4ID0gcmlnaHRJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTmVpdGhlciBjaGlsZCBpcyBzbWFsbGVyLiBFeGl0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgLy8gQ29tcGFyZSBzb3J0IGluZGV4IGZpcnN0LCB0aGVuIHRhc2sgaWQuXG4gIHZhciBkaWZmID0gYS5zb3J0SW5kZXggLSBiLnNvcnRJbmRleDtcbiAgcmV0dXJuIGRpZmYgIT09IDAgPyBkaWZmIDogYS5pZCAtIGIuaWQ7XG59XG5cbi8vIFRPRE86IFVzZSBzeW1ib2xzP1xudmFyIEltbWVkaWF0ZVByaW9yaXR5ID0gMTtcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSA9IDI7XG52YXIgTm9ybWFsUHJpb3JpdHkgPSAzO1xudmFyIExvd1ByaW9yaXR5ID0gNDtcbnZhciBJZGxlUHJpb3JpdHkgPSA1O1xuXG5mdW5jdGlvbiBtYXJrVGFza0Vycm9yZWQodGFzaywgbXMpIHtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdmFyICovXG5cbnZhciBoYXNQZXJmb3JtYW5jZU5vdyA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJztcblxuaWYgKGhhc1BlcmZvcm1hbmNlTm93KSB7XG4gIHZhciBsb2NhbFBlcmZvcm1hbmNlID0gcGVyZm9ybWFuY2U7XG5cbiAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxvY2FsUGVyZm9ybWFuY2Uubm93KCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgbG9jYWxEYXRlID0gRGF0ZTtcbiAgdmFyIGluaXRpYWxUaW1lID0gbG9jYWxEYXRlLm5vdygpO1xuXG4gIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsb2NhbERhdGUubm93KCkgLSBpbml0aWFsVGltZTtcbiAgfTtcbn0gLy8gTWF4IDMxIGJpdCBpbnRlZ2VyLiBUaGUgbWF4IGludGVnZXIgc2l6ZSBpbiBWOCBmb3IgMzItYml0IHN5c3RlbXMuXG4vLyBNYXRoLnBvdygyLCAzMCkgLSAxXG4vLyAwYjExMTExMTExMTExMTExMTExMTExMTExMTExMTExMVxuXG5cbnZhciBtYXhTaWduZWQzMUJpdEludCA9IDEwNzM3NDE4MjM7IC8vIFRpbWVzIG91dCBpbW1lZGlhdGVseVxuXG52YXIgSU1NRURJQVRFX1BSSU9SSVRZX1RJTUVPVVQgPSAtMTsgLy8gRXZlbnR1YWxseSB0aW1lcyBvdXRcblxudmFyIFVTRVJfQkxPQ0tJTkdfUFJJT1JJVFlfVElNRU9VVCA9IDI1MDtcbnZhciBOT1JNQUxfUFJJT1JJVFlfVElNRU9VVCA9IDUwMDA7XG52YXIgTE9XX1BSSU9SSVRZX1RJTUVPVVQgPSAxMDAwMDsgLy8gTmV2ZXIgdGltZXMgb3V0XG5cbnZhciBJRExFX1BSSU9SSVRZX1RJTUVPVVQgPSBtYXhTaWduZWQzMUJpdEludDsgLy8gVGFza3MgYXJlIHN0b3JlZCBvbiBhIG1pbiBoZWFwXG5cbnZhciB0YXNrUXVldWUgPSBbXTtcbnZhciB0aW1lclF1ZXVlID0gW107IC8vIEluY3JlbWVudGluZyBpZCBjb3VudGVyLiBVc2VkIHRvIG1haW50YWluIGluc2VydGlvbiBvcmRlci5cblxudmFyIHRhc2tJZENvdW50ZXIgPSAxOyAvLyBQYXVzaW5nIHRoZSBzY2hlZHVsZXIgaXMgdXNlZnVsIGZvciBkZWJ1Z2dpbmcuXG52YXIgY3VycmVudFRhc2sgPSBudWxsO1xudmFyIGN1cnJlbnRQcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7IC8vIFRoaXMgaXMgc2V0IHdoaWxlIHBlcmZvcm1pbmcgd29yaywgdG8gcHJldmVudCByZS1lbnRyYW5jZS5cblxudmFyIGlzUGVyZm9ybWluZ1dvcmsgPSBmYWxzZTtcbnZhciBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IGZhbHNlO1xudmFyIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTsgLy8gQ2FwdHVyZSBsb2NhbCByZWZlcmVuY2VzIHRvIG5hdGl2ZSBBUElzLCBpbiBjYXNlIGEgcG9seWZpbGwgb3ZlcnJpZGVzIHRoZW0uXG5cbnZhciBsb2NhbFNldFRpbWVvdXQgPSB0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJyA/IHNldFRpbWVvdXQgOiBudWxsO1xudmFyIGxvY2FsQ2xlYXJUaW1lb3V0ID0gdHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJyA/IGNsZWFyVGltZW91dCA6IG51bGw7XG52YXIgbG9jYWxTZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyA/IHNldEltbWVkaWF0ZSA6IG51bGw7IC8vIElFIGFuZCBOb2RlLmpzICsganNkb21cblxudmFyIGlzSW5wdXRQZW5kaW5nID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnNjaGVkdWxpbmcgIT09IHVuZGVmaW5lZCAmJiBuYXZpZ2F0b3Iuc2NoZWR1bGluZy5pc0lucHV0UGVuZGluZyAhPT0gdW5kZWZpbmVkID8gbmF2aWdhdG9yLnNjaGVkdWxpbmcuaXNJbnB1dFBlbmRpbmcuYmluZChuYXZpZ2F0b3Iuc2NoZWR1bGluZykgOiBudWxsO1xuXG5mdW5jdGlvbiBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKSB7XG4gIC8vIENoZWNrIGZvciB0YXNrcyB0aGF0IGFyZSBubyBsb25nZXIgZGVsYXllZCBhbmQgYWRkIHRoZW0gdG8gdGhlIHF1ZXVlLlxuICB2YXIgdGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuXG4gIHdoaWxlICh0aW1lciAhPT0gbnVsbCkge1xuICAgIGlmICh0aW1lci5jYWxsYmFjayA9PT0gbnVsbCkge1xuICAgICAgLy8gVGltZXIgd2FzIGNhbmNlbGxlZC5cbiAgICAgIHBvcCh0aW1lclF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKHRpbWVyLnN0YXJ0VGltZSA8PSBjdXJyZW50VGltZSkge1xuICAgICAgLy8gVGltZXIgZmlyZWQuIFRyYW5zZmVyIHRvIHRoZSB0YXNrIHF1ZXVlLlxuICAgICAgcG9wKHRpbWVyUXVldWUpO1xuICAgICAgdGltZXIuc29ydEluZGV4ID0gdGltZXIuZXhwaXJhdGlvblRpbWU7XG4gICAgICBwdXNoKHRhc2tRdWV1ZSwgdGltZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1haW5pbmcgdGltZXJzIGFyZSBwZW5kaW5nLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUaW1lb3V0KGN1cnJlbnRUaW1lKSB7XG4gIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTtcbiAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG5cbiAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCkge1xuICAgIGlmIChwZWVrKHRhc2tRdWV1ZSkgIT09IG51bGwpIHtcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuXG4gICAgICBpZiAoZmlyc3RUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoV29yayhoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSkge1xuXG5cbiAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSBmYWxzZTtcblxuICBpZiAoaXNIb3N0VGltZW91dFNjaGVkdWxlZCkge1xuICAgIC8vIFdlIHNjaGVkdWxlZCBhIHRpbWVvdXQgYnV0IGl0J3Mgbm8gbG9uZ2VyIG5lZWRlZC4gQ2FuY2VsIGl0LlxuICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBjYW5jZWxIb3N0VGltZW91dCgpO1xuICB9XG5cbiAgaXNQZXJmb3JtaW5nV29yayA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcblxuICB0cnkge1xuICAgIGlmIChlbmFibGVQcm9maWxpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB3b3JrTG9vcChoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoY3VycmVudFRhc2sgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgICAgIG1hcmtUYXNrRXJyb3JlZChjdXJyZW50VGFzaywgY3VycmVudFRpbWUpO1xuICAgICAgICAgIGN1cnJlbnRUYXNrLmlzUXVldWVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gY2F0Y2ggaW4gcHJvZCBjb2RlIHBhdGguXG4gICAgICByZXR1cm4gd29ya0xvb3AoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50VGFzayA9IG51bGw7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgaXNQZXJmb3JtaW5nV29yayA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdvcmtMb29wKGhhc1RpbWVSZW1haW5pbmcsIGluaXRpYWxUaW1lKSB7XG4gIHZhciBjdXJyZW50VGltZSA9IGluaXRpYWxUaW1lO1xuICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG5cbiAgd2hpbGUgKGN1cnJlbnRUYXNrICE9PSBudWxsICYmICEoZW5hYmxlU2NoZWR1bGVyRGVidWdnaW5nICkpIHtcbiAgICBpZiAoY3VycmVudFRhc2suZXhwaXJhdGlvblRpbWUgPiBjdXJyZW50VGltZSAmJiAoIWhhc1RpbWVSZW1haW5pbmcgfHwgc2hvdWxkWWllbGRUb0hvc3QoKSkpIHtcbiAgICAgIC8vIFRoaXMgY3VycmVudFRhc2sgaGFzbid0IGV4cGlyZWQsIGFuZCB3ZSd2ZSByZWFjaGVkIHRoZSBkZWFkbGluZS5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBjYWxsYmFjayA9IGN1cnJlbnRUYXNrLmNhbGxiYWNrO1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBudWxsO1xuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50VGFzay5wcmlvcml0eUxldmVsO1xuICAgICAgdmFyIGRpZFVzZXJDYWxsYmFja1RpbWVvdXQgPSBjdXJyZW50VGFzay5leHBpcmF0aW9uVGltZSA8PSBjdXJyZW50VGltZTtcblxuICAgICAgdmFyIGNvbnRpbnVhdGlvbkNhbGxiYWNrID0gY2FsbGJhY2soZGlkVXNlckNhbGxiYWNrVGltZW91dCk7XG4gICAgICBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG5cbiAgICAgIGlmICh0eXBlb2YgY29udGludWF0aW9uQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBjb250aW51YXRpb25DYWxsYmFjaztcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRUYXNrID09PSBwZWVrKHRhc2tRdWV1ZSkpIHtcbiAgICAgICAgICBwb3AodGFza1F1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9wKHRhc2tRdWV1ZSk7XG4gICAgfVxuXG4gICAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG4gIH0gLy8gUmV0dXJuIHdoZXRoZXIgdGhlcmUncyBhZGRpdGlvbmFsIHdvcmtcblxuXG4gIGlmIChjdXJyZW50VGFzayAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuICAgIGlmIChmaXJzdFRpbWVyICE9PSBudWxsKSB7XG4gICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3J1bldpdGhQcmlvcml0eShwcmlvcml0eUxldmVsLCBldmVudEhhbmRsZXIpIHtcbiAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTtcbiAgfVxuXG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xuICB9IGZpbmFsbHkge1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX25leHQoZXZlbnRIYW5kbGVyKSB7XG4gIHZhciBwcmlvcml0eUxldmVsO1xuXG4gIHN3aXRjaCAoY3VycmVudFByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICAgIC8vIFNoaWZ0IGRvd24gdG8gbm9ybWFsIHByaW9yaXR5XG4gICAgICBwcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBBbnl0aGluZyBsb3dlciB0aGFuIG5vcm1hbCBwcmlvcml0eSBzaG91bGQgcmVtYWluIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuICAgICAgcHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcblxuICB0cnkge1xuICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV93cmFwQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgdmFyIHBhcmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUaGlzIGlzIGEgZm9yayBvZiBydW5XaXRoUHJpb3JpdHksIGlubGluZWQgZm9yIHBlcmZvcm1hbmNlLlxuICAgIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHBhcmVudFByaW9yaXR5TGV2ZWw7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayhwcmlvcml0eUxldmVsLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICB2YXIgc3RhcnRUaW1lO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgIHZhciBkZWxheSA9IG9wdGlvbnMuZGVsYXk7XG5cbiAgICBpZiAodHlwZW9mIGRlbGF5ID09PSAnbnVtYmVyJyAmJiBkZWxheSA+IDApIHtcbiAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lICsgZGVsYXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgfVxuXG4gIHZhciB0aW1lb3V0O1xuXG4gIHN3aXRjaCAocHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgICB0aW1lb3V0ID0gSU1NRURJQVRFX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgICB0aW1lb3V0ID0gVVNFUl9CTE9DS0lOR19QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgIHRpbWVvdXQgPSBJRExFX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgTG93UHJpb3JpdHk6XG4gICAgICB0aW1lb3V0ID0gTE9XX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgZGVmYXVsdDpcbiAgICAgIHRpbWVvdXQgPSBOT1JNQUxfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdmFyIGV4cGlyYXRpb25UaW1lID0gc3RhcnRUaW1lICsgdGltZW91dDtcbiAgdmFyIG5ld1Rhc2sgPSB7XG4gICAgaWQ6IHRhc2tJZENvdW50ZXIrKyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgcHJpb3JpdHlMZXZlbDogcHJpb3JpdHlMZXZlbCxcbiAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgc29ydEluZGV4OiAtMVxuICB9O1xuXG4gIGlmIChzdGFydFRpbWUgPiBjdXJyZW50VGltZSkge1xuICAgIC8vIFRoaXMgaXMgYSBkZWxheWVkIHRhc2suXG4gICAgbmV3VGFzay5zb3J0SW5kZXggPSBzdGFydFRpbWU7XG4gICAgcHVzaCh0aW1lclF1ZXVlLCBuZXdUYXNrKTtcblxuICAgIGlmIChwZWVrKHRhc2tRdWV1ZSkgPT09IG51bGwgJiYgbmV3VGFzayA9PT0gcGVlayh0aW1lclF1ZXVlKSkge1xuICAgICAgLy8gQWxsIHRhc2tzIGFyZSBkZWxheWVkLCBhbmQgdGhpcyBpcyB0aGUgdGFzayB3aXRoIHRoZSBlYXJsaWVzdCBkZWxheS5cbiAgICAgIGlmIChpc0hvc3RUaW1lb3V0U2NoZWR1bGVkKSB7XG4gICAgICAgIC8vIENhbmNlbCBhbiBleGlzdGluZyB0aW1lb3V0LlxuICAgICAgICBjYW5jZWxIb3N0VGltZW91dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IHRydWU7XG4gICAgICB9IC8vIFNjaGVkdWxlIGEgdGltZW91dC5cblxuXG4gICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBuZXdUYXNrLnNvcnRJbmRleCA9IGV4cGlyYXRpb25UaW1lO1xuICAgIHB1c2godGFza1F1ZXVlLCBuZXdUYXNrKTtcbiAgICAvLyB3YWl0IHVudGlsIHRoZSBuZXh0IHRpbWUgd2UgeWllbGQuXG5cblxuICAgIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgJiYgIWlzUGVyZm9ybWluZ1dvcmspIHtcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3VGFzaztcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfcGF1c2VFeGVjdXRpb24oKSB7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uKCkge1xuXG4gIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgJiYgIWlzUGVyZm9ybWluZ1dvcmspIHtcbiAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgcmVxdWVzdEhvc3RDYWxsYmFjayhmbHVzaFdvcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlKCkge1xuICByZXR1cm4gcGVlayh0YXNrUXVldWUpO1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9jYW5jZWxDYWxsYmFjayh0YXNrKSB7XG4gIC8vIHJlbW92ZSBmcm9tIHRoZSBxdWV1ZSBiZWNhdXNlIHlvdSBjYW4ndCByZW1vdmUgYXJiaXRyYXJ5IG5vZGVzIGZyb20gYW5cbiAgLy8gYXJyYXkgYmFzZWQgaGVhcCwgb25seSB0aGUgZmlyc3Qgb25lLilcblxuXG4gIHRhc2suY2FsbGJhY2sgPSBudWxsO1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpIHtcbiAgcmV0dXJuIGN1cnJlbnRQcmlvcml0eUxldmVsO1xufVxuXG52YXIgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbnZhciBzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgPSBudWxsO1xudmFyIHRhc2tUaW1lb3V0SUQgPSAtMTsgLy8gU2NoZWR1bGVyIHBlcmlvZGljYWxseSB5aWVsZHMgaW4gY2FzZSB0aGVyZSBpcyBvdGhlciB3b3JrIG9uIHRoZSBtYWluXG4vLyB0aHJlYWQsIGxpa2UgdXNlciBldmVudHMuIEJ5IGRlZmF1bHQsIGl0IHlpZWxkcyBtdWx0aXBsZSB0aW1lcyBwZXIgZnJhbWUuXG4vLyBJdCBkb2VzIG5vdCBhdHRlbXB0IHRvIGFsaWduIHdpdGggZnJhbWUgYm91bmRhcmllcywgc2luY2UgbW9zdCB0YXNrcyBkb24ndFxuLy8gbmVlZCB0byBiZSBmcmFtZSBhbGlnbmVkOyBmb3IgdGhvc2UgdGhhdCBkbywgdXNlIHJlcXVlc3RBbmltYXRpb25GcmFtZS5cblxudmFyIGZyYW1lSW50ZXJ2YWwgPSBmcmFtZVlpZWxkTXM7XG52YXIgc3RhcnRUaW1lID0gLTE7XG5cbmZ1bmN0aW9uIHNob3VsZFlpZWxkVG9Ib3N0KCkge1xuICB2YXIgdGltZUVsYXBzZWQgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpIC0gc3RhcnRUaW1lO1xuXG4gIGlmICh0aW1lRWxhcHNlZCA8IGZyYW1lSW50ZXJ2YWwpIHtcbiAgICAvLyBUaGUgbWFpbiB0aHJlYWQgaGFzIG9ubHkgYmVlbiBibG9ja2VkIGZvciBhIHJlYWxseSBzaG9ydCBhbW91bnQgb2YgdGltZTtcbiAgICAvLyBzbWFsbGVyIHRoYW4gYSBzaW5nbGUgZnJhbWUuIERvbid0IHlpZWxkIHlldC5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gVGhlIG1haW4gdGhyZWFkIGhhcyBiZWVuIGJsb2NrZWQgZm9yIGEgbm9uLW5lZ2xpZ2libGUgYW1vdW50IG9mIHRpbWUuIFdlXG5cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVxdWVzdFBhaW50KCkge1xuXG59XG5cbmZ1bmN0aW9uIGZvcmNlRnJhbWVSYXRlKGZwcykge1xuICBpZiAoZnBzIDwgMCB8fCBmcHMgPiAxMjUpIHtcbiAgICAvLyBVc2luZyBjb25zb2xlWydlcnJvciddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcbiAgICBjb25zb2xlWydlcnJvciddKCdmb3JjZUZyYW1lUmF0ZSB0YWtlcyBhIHBvc2l0aXZlIGludCBiZXR3ZWVuIDAgYW5kIDEyNSwgJyArICdmb3JjaW5nIGZyYW1lIHJhdGVzIGhpZ2hlciB0aGFuIDEyNSBmcHMgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChmcHMgPiAwKSB7XG4gICAgZnJhbWVJbnRlcnZhbCA9IE1hdGguZmxvb3IoMTAwMCAvIGZwcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzZXQgdGhlIGZyYW1lcmF0ZVxuICAgIGZyYW1lSW50ZXJ2YWwgPSBmcmFtZVlpZWxkTXM7XG4gIH1cbn1cblxudmFyIHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHNjaGVkdWxlZEhvc3RDYWxsYmFjayAhPT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7IC8vIEtlZXAgdHJhY2sgb2YgdGhlIHN0YXJ0IHRpbWUgc28gd2UgY2FuIG1lYXN1cmUgaG93IGxvbmcgdGhlIG1haW4gdGhyZWFkXG4gICAgLy8gaGFzIGJlZW4gYmxvY2tlZC5cblxuICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHZhciBoYXNUaW1lUmVtYWluaW5nID0gdHJ1ZTsgLy8gSWYgYSBzY2hlZHVsZXIgdGFzayB0aHJvd3MsIGV4aXQgdGhlIGN1cnJlbnQgYnJvd3NlciB0YXNrIHNvIHRoZVxuICAgIC8vIGVycm9yIGNhbiBiZSBvYnNlcnZlZC5cbiAgICAvL1xuICAgIC8vIEludGVudGlvbmFsbHkgbm90IHVzaW5nIGEgdHJ5LWNhdGNoLCBzaW5jZSB0aGF0IG1ha2VzIHNvbWUgZGVidWdnaW5nXG4gICAgLy8gdGVjaG5pcXVlcyBoYXJkZXIuIEluc3RlYWQsIGlmIGBzY2hlZHVsZWRIb3N0Q2FsbGJhY2tgIGVycm9ycywgdGhlblxuICAgIC8vIGBoYXNNb3JlV29ya2Agd2lsbCByZW1haW4gdHJ1ZSwgYW5kIHdlJ2xsIGNvbnRpbnVlIHRoZSB3b3JrIGxvb3AuXG5cbiAgICB2YXIgaGFzTW9yZVdvcmsgPSB0cnVlO1xuXG4gICAgdHJ5IHtcbiAgICAgIGhhc01vcmVXb3JrID0gc2NoZWR1bGVkSG9zdENhbGxiYWNrKGhhc1RpbWVSZW1haW5pbmcsIGN1cnJlbnRUaW1lKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGhhc01vcmVXb3JrKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3MgbW9yZSB3b3JrLCBzY2hlZHVsZSB0aGUgbmV4dCBtZXNzYWdlIGV2ZW50IGF0IHRoZSBlbmRcbiAgICAgICAgLy8gb2YgdGhlIHByZWNlZGluZyBvbmUuXG4gICAgICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IGZhbHNlO1xuICAgICAgICBzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IGZhbHNlO1xuICB9IC8vIFlpZWxkaW5nIHRvIHRoZSBicm93c2VyIHdpbGwgZ2l2ZSBpdCBhIGNoYW5jZSB0byBwYWludCwgc28gd2UgY2FuXG59O1xuXG52YXIgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmU7XG5cbmlmICh0eXBlb2YgbG9jYWxTZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gTm9kZS5qcyBhbmQgb2xkIElFLlxuICAvLyBUaGVyZSdzIGEgZmV3IHJlYXNvbnMgZm9yIHdoeSB3ZSBwcmVmZXIgc2V0SW1tZWRpYXRlLlxuICAvL1xuICAvLyBVbmxpa2UgTWVzc2FnZUNoYW5uZWwsIGl0IGRvZXNuJ3QgcHJldmVudCBhIE5vZGUuanMgcHJvY2VzcyBmcm9tIGV4aXRpbmcuXG4gIC8vIChFdmVuIHRob3VnaCB0aGlzIGlzIGEgRE9NIGZvcmsgb2YgdGhlIFNjaGVkdWxlciwgeW91IGNvdWxkIGdldCBoZXJlXG4gIC8vIHdpdGggYSBtaXggb2YgTm9kZS5qcyAxNSssIHdoaWNoIGhhcyBhIE1lc3NhZ2VDaGFubmVsLCBhbmQganNkb20uKVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIwNzU2XG4gIC8vXG4gIC8vIEJ1dCBhbHNvLCBpdCBydW5zIGVhcmxpZXIgd2hpY2ggaXMgdGhlIHNlbWFudGljIHdlIHdhbnQuXG4gIC8vIElmIG90aGVyIGJyb3dzZXJzIGV2ZXIgaW1wbGVtZW50IGl0LCBpdCdzIGJldHRlciB0byB1c2UgaXQuXG4gIC8vIEFsdGhvdWdoIGJvdGggb2YgdGhlc2Ugd291bGQgYmUgaW5mZXJpb3IgdG8gbmF0aXZlIHNjaGVkdWxpbmcuXG4gIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgIGxvY2FsU2V0SW1tZWRpYXRlKHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSk7XG4gIH07XG59IGVsc2UgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gRE9NIGFuZCBXb3JrZXIgZW52aXJvbm1lbnRzLlxuICAvLyBXZSBwcmVmZXIgTWVzc2FnZUNoYW5uZWwgYmVjYXVzZSBvZiB0aGUgNG1zIHNldFRpbWVvdXQgY2xhbXBpbmcuXG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIHZhciBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmU7XG5cbiAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcG9ydC5wb3N0TWVzc2FnZShudWxsKTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIFdlIHNob3VsZCBvbmx5IGZhbGxiYWNrIGhlcmUgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzLlxuICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBsb2NhbFNldFRpbWVvdXQocGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lLCAwKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVxdWVzdEhvc3RDYWxsYmFjayhjYWxsYmFjaykge1xuICBzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICBpZiAoIWlzTWVzc2FnZUxvb3BSdW5uaW5nKSB7XG4gICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSB0cnVlO1xuICAgIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVxdWVzdEhvc3RUaW1lb3V0KGNhbGxiYWNrLCBtcykge1xuICB0YXNrVGltZW91dElEID0gbG9jYWxTZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjayhleHBvcnRzLnVuc3RhYmxlX25vdygpKTtcbiAgfSwgbXMpO1xufVxuXG5mdW5jdGlvbiBjYW5jZWxIb3N0VGltZW91dCgpIHtcbiAgbG9jYWxDbGVhclRpbWVvdXQodGFza1RpbWVvdXRJRCk7XG4gIHRhc2tUaW1lb3V0SUQgPSAtMTtcbn1cblxudmFyIHVuc3RhYmxlX3JlcXVlc3RQYWludCA9IHJlcXVlc3RQYWludDtcbnZhciB1bnN0YWJsZV9Qcm9maWxpbmcgPSAgbnVsbDtcblxuZXhwb3J0cy51bnN0YWJsZV9JZGxlUHJpb3JpdHkgPSBJZGxlUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5ID0gSW1tZWRpYXRlUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX0xvd1ByaW9yaXR5ID0gTG93UHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5ID0gTm9ybWFsUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX1Byb2ZpbGluZyA9IHVuc3RhYmxlX1Byb2ZpbGluZztcbmV4cG9ydHMudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHkgPSBVc2VyQmxvY2tpbmdQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2sgPSB1bnN0YWJsZV9jYW5jZWxDYWxsYmFjaztcbmV4cG9ydHMudW5zdGFibGVfY29udGludWVFeGVjdXRpb24gPSB1bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbjtcbmV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGUgPSBmb3JjZUZyYW1lUmF0ZTtcbmV4cG9ydHMudW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwgPSB1bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbDtcbmV4cG9ydHMudW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUgPSB1bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZTtcbmV4cG9ydHMudW5zdGFibGVfbmV4dCA9IHVuc3RhYmxlX25leHQ7XG5leHBvcnRzLnVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uID0gdW5zdGFibGVfcGF1c2VFeGVjdXRpb247XG5leHBvcnRzLnVuc3RhYmxlX3JlcXVlc3RQYWludCA9IHVuc3RhYmxlX3JlcXVlc3RQYWludDtcbmV4cG9ydHMudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5ID0gdW5zdGFibGVfcnVuV2l0aFByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrID0gdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjaztcbmV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQgPSBzaG91bGRZaWVsZFRvSG9zdDtcbmV4cG9ydHMudW5zdGFibGVfd3JhcENhbGxiYWNrID0gdW5zdGFibGVfd3JhcENhbGxiYWNrO1xuICAgICAgICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PT1cbiAgICAnZnVuY3Rpb24nXG4pIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgXG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsInJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCIsIkVycm9yIiwiZW5hYmxlU2NoZWR1bGVyRGVidWdnaW5nIiwiZW5hYmxlUHJvZmlsaW5nIiwiZnJhbWVZaWVsZE1zIiwicHVzaCIsImhlYXAiLCJub2RlIiwiaW5kZXgiLCJsZW5ndGgiLCJzaWZ0VXAiLCJwZWVrIiwicG9wIiwiZmlyc3QiLCJsYXN0Iiwic2lmdERvd24iLCJpIiwicGFyZW50SW5kZXgiLCJwYXJlbnQiLCJjb21wYXJlIiwiaGFsZkxlbmd0aCIsImxlZnRJbmRleCIsImxlZnQiLCJyaWdodEluZGV4IiwicmlnaHQiLCJhIiwiYiIsImRpZmYiLCJzb3J0SW5kZXgiLCJpZCIsIkltbWVkaWF0ZVByaW9yaXR5IiwiVXNlckJsb2NraW5nUHJpb3JpdHkiLCJOb3JtYWxQcmlvcml0eSIsIkxvd1ByaW9yaXR5IiwiSWRsZVByaW9yaXR5IiwibWFya1Rhc2tFcnJvcmVkIiwidGFzayIsIm1zIiwiaGFzUGVyZm9ybWFuY2VOb3ciLCJwZXJmb3JtYW5jZSIsIm5vdyIsImxvY2FsUGVyZm9ybWFuY2UiLCJleHBvcnRzIiwidW5zdGFibGVfbm93IiwibG9jYWxEYXRlIiwiRGF0ZSIsImluaXRpYWxUaW1lIiwibWF4U2lnbmVkMzFCaXRJbnQiLCJJTU1FRElBVEVfUFJJT1JJVFlfVElNRU9VVCIsIlVTRVJfQkxPQ0tJTkdfUFJJT1JJVFlfVElNRU9VVCIsIk5PUk1BTF9QUklPUklUWV9USU1FT1VUIiwiTE9XX1BSSU9SSVRZX1RJTUVPVVQiLCJJRExFX1BSSU9SSVRZX1RJTUVPVVQiLCJ0YXNrUXVldWUiLCJ0aW1lclF1ZXVlIiwidGFza0lkQ291bnRlciIsImN1cnJlbnRUYXNrIiwiY3VycmVudFByaW9yaXR5TGV2ZWwiLCJpc1BlcmZvcm1pbmdXb3JrIiwiaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQiLCJpc0hvc3RUaW1lb3V0U2NoZWR1bGVkIiwibG9jYWxTZXRUaW1lb3V0Iiwic2V0VGltZW91dCIsImxvY2FsQ2xlYXJUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwibG9jYWxTZXRJbW1lZGlhdGUiLCJzZXRJbW1lZGlhdGUiLCJpc0lucHV0UGVuZGluZyIsIm5hdmlnYXRvciIsInNjaGVkdWxpbmciLCJ1bmRlZmluZWQiLCJiaW5kIiwiYWR2YW5jZVRpbWVycyIsImN1cnJlbnRUaW1lIiwidGltZXIiLCJjYWxsYmFjayIsInN0YXJ0VGltZSIsImV4cGlyYXRpb25UaW1lIiwiaGFuZGxlVGltZW91dCIsInJlcXVlc3RIb3N0Q2FsbGJhY2siLCJmbHVzaFdvcmsiLCJmaXJzdFRpbWVyIiwicmVxdWVzdEhvc3RUaW1lb3V0IiwiaGFzVGltZVJlbWFpbmluZyIsImNhbmNlbEhvc3RUaW1lb3V0IiwicHJldmlvdXNQcmlvcml0eUxldmVsIiwid29ya0xvb3AiLCJlcnJvciIsImlzUXVldWVkIiwic2hvdWxkWWllbGRUb0hvc3QiLCJwcmlvcml0eUxldmVsIiwiZGlkVXNlckNhbGxiYWNrVGltZW91dCIsImNvbnRpbnVhdGlvbkNhbGxiYWNrIiwidW5zdGFibGVfcnVuV2l0aFByaW9yaXR5IiwiZXZlbnRIYW5kbGVyIiwidW5zdGFibGVfbmV4dCIsInVuc3RhYmxlX3dyYXBDYWxsYmFjayIsInBhcmVudFByaW9yaXR5TGV2ZWwiLCJhcHBseSIsImFyZ3VtZW50cyIsInVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2siLCJvcHRpb25zIiwiZGVsYXkiLCJ0aW1lb3V0IiwibmV3VGFzayIsInVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uIiwidW5zdGFibGVfY29udGludWVFeGVjdXRpb24iLCJ1bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZSIsInVuc3RhYmxlX2NhbmNlbENhbGxiYWNrIiwidW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwiLCJpc01lc3NhZ2VMb29wUnVubmluZyIsInNjaGVkdWxlZEhvc3RDYWxsYmFjayIsInRhc2tUaW1lb3V0SUQiLCJmcmFtZUludGVydmFsIiwidGltZUVsYXBzZWQiLCJyZXF1ZXN0UGFpbnQiLCJmb3JjZUZyYW1lUmF0ZSIsImZwcyIsImNvbnNvbGUiLCJNYXRoIiwiZmxvb3IiLCJwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUiLCJoYXNNb3JlV29yayIsInNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lIiwiTWVzc2FnZUNoYW5uZWwiLCJjaGFubmVsIiwicG9ydCIsInBvcnQyIiwicG9ydDEiLCJvbm1lc3NhZ2UiLCJwb3N0TWVzc2FnZSIsInVuc3RhYmxlX3JlcXVlc3RQYWludCIsInVuc3RhYmxlX1Byb2ZpbGluZyIsInVuc3RhYmxlX0lkbGVQcmlvcml0eSIsInVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5IiwidW5zdGFibGVfTG93UHJpb3JpdHkiLCJ1bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSIsInVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5IiwidW5zdGFibGVfZm9yY2VGcmFtZVJhdGUiLCJ1bnN0YWJsZV9zaG91bGRZaWVsZCIsInJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/node_modules/scheduler/index.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxLQUF5QixFQUFjLEVBRTFDLE1BQU07SUFDTEMseUtBQXlCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2hhaXNhYm0vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvaW5kZXguanM/NmJhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js\n");

/***/ })

};
;